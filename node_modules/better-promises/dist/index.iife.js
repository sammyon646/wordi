var betterPromises=function(c){"use strict";var K=Object.defineProperty;var N=(c,h,y)=>h in c?K(c,h,{enumerable:!0,configurable:!0,writable:!0,value:y}):c[h]=y;var P=(c,h,y)=>N(c,typeof h!="symbol"?h+"":h,y);var h=Object.defineProperty,y=(t,r,e)=>r in t?h(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e,g=(t,r,e)=>y(t,typeof r!="symbol"?r+"":r,e);function S(t){return r=>r instanceof t}function k(t,r){const e=class extends Error{constructor(...b){const u=typeof r=="function"?r(...b):typeof r=="string"?[r]:r||[];super(...u),this.name=t}};g(e,"is",S(e));let i=e;return Object.defineProperty(i,"name",{value:t}),i}function B(t,r,e){const i=class extends k(t,e){constructor(...u){super(...u),g(this,"data"),this.data=r(...u)}};g(i,"is",S(i));let o=i;return Object.defineProperty(o,"name",{value:t}),o}class C extends k("CancelledError","Promise was canceled"){}class z extends B("TimeoutError",r=>({timeout:r}),(r,e)=>[`Timeout reached: ${r}ms`,{cause:e}]){}const I=Symbol("resolved");function D(t){return typeof t=="object"&&!!t&&"tag"in t&&t.tag===I}function L(t){return{tag:I,value:t}}function x(t,r){return t.reject=r.reject,t.resolve=r.resolve,t}class R extends Promise{constructor(e,i){let o,b,u,j;typeof e=="function"?(u=e,j=i||{}):j=e||{};let d,l;const F=()=>!!l,A=()=>!!d;let f={};const p=[],M=()=>{p.forEach(O=>O()),p.splice(0,p.length),f={}},w=new AbortController,$=()=>A()||F();super((O,G)=>{const{abortOnResolve:H=!0,abortOnReject:J=!0}=j;b=n=>{var v,s;$()||(O(n),d=[n],(v=f.resolved)==null||v.forEach(a=>a(n)),(s=f.finalized)==null||s.forEach(a=>a({kind:"resolved",result:n})),M(),H&&w.abort(L(n)))},o=n=>{var v,s;$()||(G(n),l=[n],(v=f.rejected)==null||v.forEach(a=>a(n)),(s=f.finalized)==null||s.forEach(a=>a({kind:"rejected",reason:n})),M(),J&&w.abort(n))};const{abortSignal:m}=j;if(m){if(m.aborted)return o(m.reason);const n=()=>{o(m.reason)};m.addEventListener("abort",n,!0),p.push(()=>{m.removeEventListener("abort",n,!0)})}const{timeout:T}=j;if(T){const n=setTimeout(()=>{o(new z(T))},T);p.push(()=>{clearTimeout(n)})}try{const n=()=>{},v=u&&u(b,o,{abortSignal:w.signal,get isRejected(){return F()},get isResolved(){return A()},on(s,a){if(d||l){if(s==="finalized"){const E=d?{kind:"resolved",result:d[0]}:{kind:"rejected",reason:l[0]};a(E)}else s==="resolved"&&d?a(d[0]):s==="rejected"&&l&&a(l[0]);return n}return f[s]||(f[s]=[]),f[s].push(a),()=>{const E=f[s]||[],q=E.indexOf(a);q>=0&&E.splice(q,1)}},get result(){return d==null?void 0:d[0]},get rejectReason(){return l==null?void 0:l[0]},throwIfRejected(){if(l)throw l[0]}});v instanceof Promise&&v.catch(o)}catch(n){o(n)}});P(this,"reject");P(this,"resolve");this.reject=o,this.resolve=b}static fn(e,i){return new R(async(o,b,u)=>{try{o(await e(u))}catch(j){b(j)}},i)}static resolve(e){return this.fn(()=>e)}static reject(e){return new R((i,o)=>{o(e)})}cancel(){this.reject(new C)}catch(e){return this.then(void 0,e)}finally(e){return x(super.finally(e),this)}then(e,i){return x(super.then(e,i),this)}}return c.BetterPromise=R,c.CancelledError=C,c.TimeoutError=z,c.isResolved=D,c.withResolved=L,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"}),c}({});
//# sourceMappingURL=index.iife.js.map

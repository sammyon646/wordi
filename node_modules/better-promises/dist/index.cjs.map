{"version":3,"file":"index.cjs","sources":["../node_modules/.pnpm/error-kid@1.0.1/node_modules/error-kid/dist/index.js","../src/errors.ts","../src/resolved-utils.ts","../src/BetterPromise.ts"],"sourcesContent":["var l = Object.defineProperty;\nvar o = (e, t, n) => t in e ? l(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar c = (e, t, n) => o(e, typeof t != \"symbol\" ? t + \"\" : t, n);\nfunction f(e) {\n  return (t) => t instanceof e;\n}\nfunction u(e, t) {\n  const s = class s extends Error {\n    constructor(...d) {\n      const i = typeof t == \"function\" ? t(...d) : typeof t == \"string\" ? [t] : t || [];\n      super(...i), this.name = e;\n    }\n  };\n  c(s, \"is\", f(s));\n  let n = s;\n  return Object.defineProperty(n, \"name\", { value: e }), n;\n}\nfunction y(e, t, n) {\n  const a = class a extends u(e, n) {\n    constructor(...r) {\n      super(...r);\n      c(this, \"data\");\n      this.data = t(...r);\n    }\n  };\n  c(a, \"is\", f(a));\n  let s = a;\n  return Object.defineProperty(s, \"name\", { value: e }), s;\n}\nexport {\n  u as errorClass,\n  y as errorClassWithData\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass, errorClassWithData } from 'error-kid';\r\n\r\nexport class CancelledError extends errorClass('CancelledError', 'Promise was canceled') {\r\n}\r\n\r\nexport class TimeoutError extends errorClassWithData<\r\n  { timeout: number },\r\n  [timeout: number, cause?: unknown]\r\n>(\r\n  'TimeoutError',\r\n  timeout => ({ timeout }),\r\n  (timeout, cause) => [`Timeout reached: ${timeout}ms`, { cause }],\r\n) {\r\n}","const tag = Symbol('resolved');\r\n\r\nexport interface Resolved<T> {\r\n  tag: symbol;\r\n  value: T;\r\n}\r\n\r\nexport function isResolved<T = unknown>(value: unknown): value is Resolved<T> {\r\n  return typeof value === 'object'\r\n    && !!value\r\n    && 'tag' in value\r\n    && value.tag === tag;\r\n}\r\n\r\nexport function withResolved<T>(value: T): Resolved<T> {\r\n  return { tag, value };\r\n}","import { CancelledError, TimeoutError } from './errors.js';\r\nimport { withResolved } from './resolved-utils.js';\r\n\r\ntype Maybe<T> = T | undefined | null;\r\n\r\nexport interface BetterPromiseOptions {\r\n  /**\r\n   * Should the `abortSignal` passed to the executor be aborted if the promise was rejected.\r\n   *\r\n   * By default, as long as there is no point to perform any operations at the moment of rejection,\r\n   * the signal will be aborted.\r\n   * @default true\r\n   */\r\n  abortOnReject?: boolean;\r\n  /**\r\n   * Should the `abortSignal` passed to the executor be aborted if the promise was fulfilled.\r\n   *\r\n   * By default, as long as there is no point to perform any operations at the moment of resolve,\r\n   * the signal will be aborted.\r\n   * @default true\r\n   */\r\n  abortOnResolve?: boolean;\r\n  /**\r\n   * Signal to abort the execution.\r\n   */\r\n  abortSignal?: AbortSignal;\r\n  /**\r\n   * Execution timeout. After the timeout was reached, the promise will be aborted\r\n   * with the `TimeoutError` error.\r\n   */\r\n  timeout?: number;\r\n}\r\n\r\nexport type BetterPromiseResolveFn<T> = undefined extends T\r\n  ? (value?: T) => void\r\n  : (value: T) => void;\r\n\r\nexport type BetterPromiseRejectFn = (reason?: any) => void;\r\n\r\nexport type BetterPromiseRejectReason = TimeoutError | CancelledError | unknown;\r\n\r\ninterface EventMap<Result> {\r\n  resolved: Result;\r\n  rejected: BetterPromiseRejectReason;\r\n  finalized:\r\n    | { kind: 'resolved', result: Result }\r\n    | { kind: 'rejected', reason: BetterPromiseRejectReason };\r\n}\r\n\r\nexport interface BetterPromiseExecutorContext<Result> {\r\n  /**\r\n   * Abort signal. Will be aborted if the promise was rejected.\r\n   */\r\n  readonly abortSignal: AbortSignal;\r\n  /**\r\n   * @returns True if the promise was rejected.\r\n   */\r\n  get isRejected(): boolean;\r\n  /**\r\n   * @returns True if the promise was resolved.\r\n   */\r\n  get isResolved(): boolean;\r\n  /**\r\n   * Adds a new event listener to the specified event.\r\n   * @param event - event to listen to.\r\n   * @param listener - a corresponding callback function to call.\r\n   */\r\n  on<E extends keyof EventMap<Result>>(\r\n    event: E,\r\n    listener: (ev: EventMap<Result>[E]) => void,\r\n  ): VoidFunction;\r\n  /**\r\n   * @returns Promise resolve result if it was resolved.\r\n   */\r\n  get result(): Result | undefined;\r\n  /**\r\n   * @returns Promise rejection reason if the promise was rejected.\r\n   */\r\n  get rejectReason(): BetterPromiseRejectReason | undefined;\r\n  /**\r\n   * Will throw a rejection reason if the promise was rejected.\r\n   */\r\n  throwIfRejected: () => void;\r\n}\r\n\r\nexport type BetterPromiseExecutorFn<T> = (\r\n  res: BetterPromiseResolveFn<T>,\r\n  rej: BetterPromiseRejectFn,\r\n  context: BetterPromiseExecutorContext<T>,\r\n) => any;\r\n\r\nexport type BetterPromiseOnFulfilledFn<TResult1, TResult2> =\r\n  (value: TResult1) => TResult2 | PromiseLike<TResult2>;\r\n\r\nexport type BetterPromiseOnRejectedFn<T> = (value: any) => T | PromiseLike<T>;\r\n\r\nfunction withInheritedResolvers<P extends BetterPromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: BetterPromise<any>,\r\n): P {\r\n  childPromise.reject = parentPromise.reject;\r\n  childPromise.resolve = parentPromise.resolve;\r\n  return childPromise;\r\n}\r\n\r\nexport class BetterPromise<Result> extends Promise<Result> {\r\n  static fn<Result>(\r\n    fn: (context: BetterPromiseExecutorContext<Result>) => (Result | PromiseLike<Result>),\r\n    options?: BetterPromiseOptions,\r\n  ): BetterPromise<Awaited<Result>> {\r\n    return new BetterPromise(async (res, rej, context) => {\r\n      try {\r\n        res(await fn(context));\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): BetterPromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): BetterPromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): BetterPromise<Awaited<T>> {\r\n    return this.fn(() => value) as BetterPromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject(reason?: unknown): BetterPromise<never> {\r\n    return new BetterPromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n\r\n  constructor(options?: BetterPromiseOptions);\r\n  constructor(executor?: BetterPromiseExecutorFn<Result>, options?: BetterPromiseOptions);\r\n  constructor(\r\n    arg1?: BetterPromiseExecutorFn<Result> | BetterPromiseOptions,\r\n    maybeOptions?: BetterPromiseOptions,\r\n  ) {\r\n    let reject!: BetterPromiseRejectFn;\r\n    let resolve!: BetterPromiseResolveFn<Result>;\r\n    let executor: BetterPromiseExecutorFn<Result> | undefined;\r\n    let options: BetterPromiseOptions;\r\n\r\n    if (typeof arg1 === 'function') {\r\n      executor = arg1;\r\n      options = maybeOptions || {};\r\n    } else {\r\n      options = arg1 || {};\r\n    }\r\n\r\n    let resolved: [Result] | undefined;\r\n    let rejected: [BetterPromiseRejectReason] | undefined;\r\n    const isRejected = () => !!rejected;\r\n    const isResolved = () => !!resolved;\r\n    let listeners: {\r\n      [E in keyof EventMap<Result>]?: ((data: EventMap<Result>[E]) => void)[];\r\n    } = {};\r\n\r\n    //#region Cleanup section.\r\n    const cleanupFns: VoidFunction[] = [];\r\n    const cleanup = () => {\r\n      cleanupFns.forEach(fn => fn());\r\n      cleanupFns.splice(0, cleanupFns.length);\r\n      listeners = {};\r\n    };\r\n    //#endregion\r\n\r\n    // We are going to use our controller signal in the executor because we can control it.\r\n    // We can't say the same about the abort signal passed from above - we can't abort it by\r\n    // ourselves.\r\n    const controller = new AbortController();\r\n    const isResolvedOrRejected = () => isResolved() || isRejected();\r\n\r\n    super((res, rej) => {\r\n      // Enhance resolve and reject functions with cleanup and controller abortion.\r\n      const { abortOnResolve = true, abortOnReject = true } = options;\r\n      resolve = ((result: Result) => {\r\n        if (!isResolvedOrRejected()) {\r\n          res(result);\r\n          resolved = [result];\r\n          listeners.resolved?.forEach(l => l(result));\r\n          listeners.finalized?.forEach(l => l({ kind: 'resolved', result }));\r\n          cleanup();\r\n\r\n          if (abortOnResolve) {\r\n            controller.abort(withResolved<Result>(result));\r\n          }\r\n        }\r\n      }) as BetterPromiseResolveFn<Result>;\r\n      reject = reason => {\r\n        if (!isResolvedOrRejected()) {\r\n          rej(reason);\r\n          rejected = [reason];\r\n          listeners.rejected?.forEach(l => l(reason));\r\n          listeners.finalized?.forEach(l => l({ kind: 'rejected', reason }));\r\n          cleanup();\r\n\r\n          if (abortOnReject) {\r\n            controller.abort(reason);\r\n          }\r\n        }\r\n      };\r\n\r\n      //#region Process abortSignal option.\r\n      const { abortSignal } = options;\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          return reject(abortSignal.reason);\r\n        }\r\n        // Whenever the passed abort signal aborts, we are also aborting our locally created\r\n        // signal.\r\n        const listener = () => {\r\n          reject(abortSignal.reason);\r\n        };\r\n        abortSignal.addEventListener('abort', listener, true);\r\n        cleanupFns.push(() => {\r\n          abortSignal.removeEventListener('abort', listener, true);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      //#region Process timeout option.\r\n      const { timeout } = options;\r\n      if (timeout) {\r\n        const timeoutId = setTimeout(() => {\r\n          reject(new TimeoutError(timeout));\r\n        }, timeout);\r\n        cleanupFns.push(() => {\r\n          clearTimeout(timeoutId);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      try {\r\n        const voidFn = () => undefined;\r\n        const result = executor && executor(resolve, reject, {\r\n          abortSignal: controller.signal,\r\n          get isRejected() {\r\n            return isRejected();\r\n          },\r\n          get isResolved() {\r\n            return isResolved();\r\n          },\r\n          on(event, listener) {\r\n            // The promise may already be finalized. In this case we just call the listener.\r\n            if (resolved || rejected) {\r\n              if (event === 'finalized') {\r\n                const payload = resolved\r\n                  ? { kind: 'resolved', result: resolved[0] } as const\r\n                  : { kind: 'rejected', reason: rejected![0] } as const;\r\n                (\r\n                  listener as (\r\n                    data:\r\n                      | { kind: 'resolved', result: Result }\r\n                      | { kind: 'rejected', reason: BetterPromiseRejectReason },\r\n                  ) => void\r\n                )(payload);\r\n              } else if (event === 'resolved' && resolved) {\r\n                (listener as (result: Result) => void)(resolved[0]);\r\n              } else if (event === 'rejected' && rejected) {\r\n                (listener as (reason: BetterPromiseRejectReason) => void)(rejected[0]);\r\n              }\r\n              return voidFn;\r\n            }\r\n            listeners[event] ||= [];\r\n            listeners[event].push(listener);\r\n\r\n            return () => {\r\n              const eventListeners: any[] = listeners[event] || [];\r\n              const index = eventListeners.indexOf(listener);\r\n              if (index >= 0) {\r\n                eventListeners.splice(index, 1);\r\n              }\r\n            };\r\n          },\r\n          get result() {\r\n            return resolved?.[0];\r\n          },\r\n          get rejectReason() {\r\n            return rejected?.[0];\r\n          },\r\n          throwIfRejected() {\r\n            if (rejected) {\r\n              throw rejected[0];\r\n            }\r\n          },\r\n        });\r\n\r\n        // If a promise was returned, we want to handle its rejection because the JS Promise\r\n        // will not do it for us. Not catching the promise rejection this way, an unhandled promise\r\n        // rejection error will be thrown. We also need to perform reject properly cleaning up\r\n        // all effects.\r\n        if (result instanceof Promise) {\r\n          result.catch(reject);\r\n        }\r\n      } catch (e) {\r\n        // The wrapped executor may throw an error. Here we are following the same logic described\r\n        // in result.catch() line above.\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n    this.reject = reject;\r\n    this.resolve = resolve;\r\n  }\r\n\r\n  /**\r\n   * Rejects the promise with the `CancelledError` error.\r\n   */\r\n  cancel(): void {\r\n    this.reject(new CancelledError());\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<BetterPromiseOnRejectedFn<CatchResult>>,\r\n  ): BetterPromise<Result | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): BetterPromise<Result> {\r\n    // Here we follow the same logic described in the \"then\" method.\r\n    return withInheritedResolvers(super.finally(onFinally) as BetterPromise<Result>, this);\r\n  }\r\n\r\n  /**\r\n   * Rejects the initially created promise.\r\n   *\r\n   * This method not only aborts the signal passed to the executor, but also rejects the\r\n   * promise itself calling all chained listeners.\r\n   *\r\n   * The reason passed to the method is being passed as-is to the executor's context.\r\n   */\r\n  reject: BetterPromiseRejectFn;\r\n\r\n  /**\r\n   * Resolves the promise.\r\n   */\r\n  resolve: BetterPromiseResolveFn<Result>;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = Result, B = never>(\r\n    onFulfilled?: Maybe<BetterPromiseOnFulfilledFn<Result, A>>,\r\n    onRejected?: Maybe<BetterPromiseOnRejectedFn<B>>,\r\n  ): BetterPromise<A | B> {\r\n    // Use the original promise \"then\" method because in fact, it creates an AbortablePromise\r\n    // instance.\r\n    // Then, reassign the promise \"reject\" method, because not doing it and rejecting the promise\r\n    // it will lead to an unhandled promise rejection.\r\n    //\r\n    // Here is an example:\r\n    // const myPromise = new AbortablePromise(...)\r\n    //   .catch(() => console.log('Catched'));\r\n    //\r\n    // If we don't reassign myPromise's \"reject\" method here, it will reject the promise, returned\r\n    // from the \"catch\" method, which is unexpected. So, even using several catches in a row,\r\n    // a developer will not be able to catch the error, thrown using the \"reject\" method.\r\n    //\r\n    // The expected behavior here is the \"reject\" method rejecting the initially created promise.\r\n    // Then, this error will be handled via the \"catch\" method.\r\n    return withInheritedResolvers(\r\n      super.then(onFulfilled, onRejected) as BetterPromise<A | B>,\r\n      this,\r\n    );\r\n  }\r\n}"],"names":["l","o","e","t","n","c","f","u","s","d","i","y","a","r","CancelledError","errorClass","TimeoutError","errorClassWithData","timeout","cause","tag","isResolved","value","withResolved","withInheritedResolvers","childPromise","parentPromise","BetterPromise","arg1","maybeOptions","reject","resolve","executor","options","resolved","rejected","isRejected","listeners","cleanupFns","cleanup","fn","controller","isResolvedOrRejected","res","rej","abortOnResolve","abortOnReject","result","_a","_b","reason","abortSignal","listener","timeoutId","voidFn","event","payload","eventListeners","index","__publicField","context","_","onRejected","onFinally","onFulfilled"],"mappings":"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","x_google_ignoreList":[0]}
{"version":3,"file":"index.js","sources":["../node_modules/.pnpm/error-kid@1.0.1/node_modules/error-kid/dist/index.js","../src/errors.ts","../src/resolved-utils.ts","../src/BetterPromise.ts"],"sourcesContent":["var l = Object.defineProperty;\nvar o = (e, t, n) => t in e ? l(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar c = (e, t, n) => o(e, typeof t != \"symbol\" ? t + \"\" : t, n);\nfunction f(e) {\n  return (t) => t instanceof e;\n}\nfunction u(e, t) {\n  const s = class s extends Error {\n    constructor(...d) {\n      const i = typeof t == \"function\" ? t(...d) : typeof t == \"string\" ? [t] : t || [];\n      super(...i), this.name = e;\n    }\n  };\n  c(s, \"is\", f(s));\n  let n = s;\n  return Object.defineProperty(n, \"name\", { value: e }), n;\n}\nfunction y(e, t, n) {\n  const a = class a extends u(e, n) {\n    constructor(...r) {\n      super(...r);\n      c(this, \"data\");\n      this.data = t(...r);\n    }\n  };\n  c(a, \"is\", f(a));\n  let s = a;\n  return Object.defineProperty(s, \"name\", { value: e }), s;\n}\nexport {\n  u as errorClass,\n  y as errorClassWithData\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass, errorClassWithData } from 'error-kid';\r\n\r\nexport class CancelledError extends errorClass('CancelledError', 'Promise was canceled') {\r\n}\r\n\r\nexport class TimeoutError extends errorClassWithData<\r\n  { timeout: number },\r\n  [timeout: number, cause?: unknown]\r\n>(\r\n  'TimeoutError',\r\n  timeout => ({ timeout }),\r\n  (timeout, cause) => [`Timeout reached: ${timeout}ms`, { cause }],\r\n) {\r\n}","const tag = Symbol('resolved');\r\n\r\nexport interface Resolved<T> {\r\n  tag: symbol;\r\n  value: T;\r\n}\r\n\r\nexport function isResolved<T = unknown>(value: unknown): value is Resolved<T> {\r\n  return typeof value === 'object'\r\n    && !!value\r\n    && 'tag' in value\r\n    && value.tag === tag;\r\n}\r\n\r\nexport function withResolved<T>(value: T): Resolved<T> {\r\n  return { tag, value };\r\n}","import { CancelledError, TimeoutError } from './errors.js';\r\nimport { withResolved } from './resolved-utils.js';\r\n\r\ntype Maybe<T> = T | undefined | null;\r\n\r\nexport interface BetterPromiseOptions {\r\n  /**\r\n   * Should the `abortSignal` passed to the executor be aborted if the promise was rejected.\r\n   *\r\n   * By default, as long as there is no point to perform any operations at the moment of rejection,\r\n   * the signal will be aborted.\r\n   * @default true\r\n   */\r\n  abortOnReject?: boolean;\r\n  /**\r\n   * Should the `abortSignal` passed to the executor be aborted if the promise was fulfilled.\r\n   *\r\n   * By default, as long as there is no point to perform any operations at the moment of resolve,\r\n   * the signal will be aborted.\r\n   * @default true\r\n   */\r\n  abortOnResolve?: boolean;\r\n  /**\r\n   * Signal to abort the execution.\r\n   */\r\n  abortSignal?: AbortSignal;\r\n  /**\r\n   * Execution timeout. After the timeout was reached, the promise will be aborted\r\n   * with the `TimeoutError` error.\r\n   */\r\n  timeout?: number;\r\n}\r\n\r\nexport type BetterPromiseResolveFn<T> = undefined extends T\r\n  ? (value?: T) => void\r\n  : (value: T) => void;\r\n\r\nexport type BetterPromiseRejectFn = (reason?: any) => void;\r\n\r\nexport type BetterPromiseRejectReason = TimeoutError | CancelledError | unknown;\r\n\r\ninterface EventMap<Result> {\r\n  resolved: Result;\r\n  rejected: BetterPromiseRejectReason;\r\n  finalized:\r\n    | { kind: 'resolved', result: Result }\r\n    | { kind: 'rejected', reason: BetterPromiseRejectReason };\r\n}\r\n\r\nexport interface BetterPromiseExecutorContext<Result> {\r\n  /**\r\n   * Abort signal. Will be aborted if the promise was rejected.\r\n   */\r\n  readonly abortSignal: AbortSignal;\r\n  /**\r\n   * @returns True if the promise was rejected.\r\n   */\r\n  get isRejected(): boolean;\r\n  /**\r\n   * @returns True if the promise was resolved.\r\n   */\r\n  get isResolved(): boolean;\r\n  /**\r\n   * Adds a new event listener to the specified event.\r\n   * @param event - event to listen to.\r\n   * @param listener - a corresponding callback function to call.\r\n   */\r\n  on<E extends keyof EventMap<Result>>(\r\n    event: E,\r\n    listener: (ev: EventMap<Result>[E]) => void,\r\n  ): VoidFunction;\r\n  /**\r\n   * @returns Promise resolve result if it was resolved.\r\n   */\r\n  get result(): Result | undefined;\r\n  /**\r\n   * @returns Promise rejection reason if the promise was rejected.\r\n   */\r\n  get rejectReason(): BetterPromiseRejectReason | undefined;\r\n  /**\r\n   * Will throw a rejection reason if the promise was rejected.\r\n   */\r\n  throwIfRejected: () => void;\r\n}\r\n\r\nexport type BetterPromiseExecutorFn<T> = (\r\n  res: BetterPromiseResolveFn<T>,\r\n  rej: BetterPromiseRejectFn,\r\n  context: BetterPromiseExecutorContext<T>,\r\n) => any;\r\n\r\nexport type BetterPromiseOnFulfilledFn<TResult1, TResult2> =\r\n  (value: TResult1) => TResult2 | PromiseLike<TResult2>;\r\n\r\nexport type BetterPromiseOnRejectedFn<T> = (value: any) => T | PromiseLike<T>;\r\n\r\nfunction withInheritedResolvers<P extends BetterPromise<any>>(\r\n  childPromise: P,\r\n  parentPromise: BetterPromise<any>,\r\n): P {\r\n  childPromise.reject = parentPromise.reject;\r\n  childPromise.resolve = parentPromise.resolve;\r\n  return childPromise;\r\n}\r\n\r\nexport class BetterPromise<Result> extends Promise<Result> {\r\n  static fn<Result>(\r\n    fn: (context: BetterPromiseExecutorContext<Result>) => (Result | PromiseLike<Result>),\r\n    options?: BetterPromiseOptions,\r\n  ): BetterPromise<Awaited<Result>> {\r\n    return new BetterPromise(async (res, rej, context) => {\r\n      try {\r\n        res(await fn(context));\r\n      } catch (e) {\r\n        rej(e);\r\n      }\r\n    }, options);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve(): BetterPromise<void>;\r\n  /**\r\n   * @see Promise.resolve\r\n   */\r\n  static override resolve<T>(value: T | PromiseLike<T>): BetterPromise<Awaited<T>>;\r\n  static override resolve<T>(value?: T | PromiseLike<T>): BetterPromise<Awaited<T>> {\r\n    return this.fn(() => value) as BetterPromise<Awaited<T>>;\r\n  }\r\n\r\n  /**\r\n   * @see Promise.reject\r\n   */\r\n  static override reject(reason?: unknown): BetterPromise<never> {\r\n    return new BetterPromise((_, rej) => {\r\n      rej(reason);\r\n    });\r\n  }\r\n\r\n\r\n  constructor(options?: BetterPromiseOptions);\r\n  constructor(executor?: BetterPromiseExecutorFn<Result>, options?: BetterPromiseOptions);\r\n  constructor(\r\n    arg1?: BetterPromiseExecutorFn<Result> | BetterPromiseOptions,\r\n    maybeOptions?: BetterPromiseOptions,\r\n  ) {\r\n    let reject!: BetterPromiseRejectFn;\r\n    let resolve!: BetterPromiseResolveFn<Result>;\r\n    let executor: BetterPromiseExecutorFn<Result> | undefined;\r\n    let options: BetterPromiseOptions;\r\n\r\n    if (typeof arg1 === 'function') {\r\n      executor = arg1;\r\n      options = maybeOptions || {};\r\n    } else {\r\n      options = arg1 || {};\r\n    }\r\n\r\n    let resolved: [Result] | undefined;\r\n    let rejected: [BetterPromiseRejectReason] | undefined;\r\n    const isRejected = () => !!rejected;\r\n    const isResolved = () => !!resolved;\r\n    let listeners: {\r\n      [E in keyof EventMap<Result>]?: ((data: EventMap<Result>[E]) => void)[];\r\n    } = {};\r\n\r\n    //#region Cleanup section.\r\n    const cleanupFns: VoidFunction[] = [];\r\n    const cleanup = () => {\r\n      cleanupFns.forEach(fn => fn());\r\n      cleanupFns.splice(0, cleanupFns.length);\r\n      listeners = {};\r\n    };\r\n    //#endregion\r\n\r\n    // We are going to use our controller signal in the executor because we can control it.\r\n    // We can't say the same about the abort signal passed from above - we can't abort it by\r\n    // ourselves.\r\n    const controller = new AbortController();\r\n    const isResolvedOrRejected = () => isResolved() || isRejected();\r\n\r\n    super((res, rej) => {\r\n      // Enhance resolve and reject functions with cleanup and controller abortion.\r\n      const { abortOnResolve = true, abortOnReject = true } = options;\r\n      resolve = ((result: Result) => {\r\n        if (!isResolvedOrRejected()) {\r\n          res(result);\r\n          resolved = [result];\r\n          listeners.resolved?.forEach(l => l(result));\r\n          listeners.finalized?.forEach(l => l({ kind: 'resolved', result }));\r\n          cleanup();\r\n\r\n          if (abortOnResolve) {\r\n            controller.abort(withResolved<Result>(result));\r\n          }\r\n        }\r\n      }) as BetterPromiseResolveFn<Result>;\r\n      reject = reason => {\r\n        if (!isResolvedOrRejected()) {\r\n          rej(reason);\r\n          rejected = [reason];\r\n          listeners.rejected?.forEach(l => l(reason));\r\n          listeners.finalized?.forEach(l => l({ kind: 'rejected', reason }));\r\n          cleanup();\r\n\r\n          if (abortOnReject) {\r\n            controller.abort(reason);\r\n          }\r\n        }\r\n      };\r\n\r\n      //#region Process abortSignal option.\r\n      const { abortSignal } = options;\r\n      if (abortSignal) {\r\n        if (abortSignal.aborted) {\r\n          return reject(abortSignal.reason);\r\n        }\r\n        // Whenever the passed abort signal aborts, we are also aborting our locally created\r\n        // signal.\r\n        const listener = () => {\r\n          reject(abortSignal.reason);\r\n        };\r\n        abortSignal.addEventListener('abort', listener, true);\r\n        cleanupFns.push(() => {\r\n          abortSignal.removeEventListener('abort', listener, true);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      //#region Process timeout option.\r\n      const { timeout } = options;\r\n      if (timeout) {\r\n        const timeoutId = setTimeout(() => {\r\n          reject(new TimeoutError(timeout));\r\n        }, timeout);\r\n        cleanupFns.push(() => {\r\n          clearTimeout(timeoutId);\r\n        });\r\n      }\r\n      //#endregion\r\n\r\n      try {\r\n        const voidFn = () => undefined;\r\n        const result = executor && executor(resolve, reject, {\r\n          abortSignal: controller.signal,\r\n          get isRejected() {\r\n            return isRejected();\r\n          },\r\n          get isResolved() {\r\n            return isResolved();\r\n          },\r\n          on(event, listener) {\r\n            // The promise may already be finalized. In this case we just call the listener.\r\n            if (resolved || rejected) {\r\n              if (event === 'finalized') {\r\n                const payload = resolved\r\n                  ? { kind: 'resolved', result: resolved[0] } as const\r\n                  : { kind: 'rejected', reason: rejected![0] } as const;\r\n                (\r\n                  listener as (\r\n                    data:\r\n                      | { kind: 'resolved', result: Result }\r\n                      | { kind: 'rejected', reason: BetterPromiseRejectReason },\r\n                  ) => void\r\n                )(payload);\r\n              } else if (event === 'resolved' && resolved) {\r\n                (listener as (result: Result) => void)(resolved[0]);\r\n              } else if (event === 'rejected' && rejected) {\r\n                (listener as (reason: BetterPromiseRejectReason) => void)(rejected[0]);\r\n              }\r\n              return voidFn;\r\n            }\r\n            listeners[event] ||= [];\r\n            listeners[event].push(listener);\r\n\r\n            return () => {\r\n              const eventListeners: any[] = listeners[event] || [];\r\n              const index = eventListeners.indexOf(listener);\r\n              if (index >= 0) {\r\n                eventListeners.splice(index, 1);\r\n              }\r\n            };\r\n          },\r\n          get result() {\r\n            return resolved?.[0];\r\n          },\r\n          get rejectReason() {\r\n            return rejected?.[0];\r\n          },\r\n          throwIfRejected() {\r\n            if (rejected) {\r\n              throw rejected[0];\r\n            }\r\n          },\r\n        });\r\n\r\n        // If a promise was returned, we want to handle its rejection because the JS Promise\r\n        // will not do it for us. Not catching the promise rejection this way, an unhandled promise\r\n        // rejection error will be thrown. We also need to perform reject properly cleaning up\r\n        // all effects.\r\n        if (result instanceof Promise) {\r\n          result.catch(reject);\r\n        }\r\n      } catch (e) {\r\n        // The wrapped executor may throw an error. Here we are following the same logic described\r\n        // in result.catch() line above.\r\n        reject(e);\r\n      }\r\n    });\r\n\r\n    this.reject = reject;\r\n    this.resolve = resolve;\r\n  }\r\n\r\n  /**\r\n   * Rejects the promise with the `CancelledError` error.\r\n   */\r\n  cancel(): void {\r\n    this.reject(new CancelledError());\r\n  }\r\n\r\n  /**\r\n   * @see Promise.catch\r\n   */\r\n  override catch<CatchResult = never>(\r\n    onRejected?: Maybe<BetterPromiseOnRejectedFn<CatchResult>>,\r\n  ): BetterPromise<Result | CatchResult> {\r\n    return this.then(undefined, onRejected);\r\n  }\r\n\r\n  /**\r\n   * @see Promise.finally\r\n   */\r\n  override finally(onFinally?: Maybe<() => void>): BetterPromise<Result> {\r\n    // Here we follow the same logic described in the \"then\" method.\r\n    return withInheritedResolvers(super.finally(onFinally) as BetterPromise<Result>, this);\r\n  }\r\n\r\n  /**\r\n   * Rejects the initially created promise.\r\n   *\r\n   * This method not only aborts the signal passed to the executor, but also rejects the\r\n   * promise itself calling all chained listeners.\r\n   *\r\n   * The reason passed to the method is being passed as-is to the executor's context.\r\n   */\r\n  reject: BetterPromiseRejectFn;\r\n\r\n  /**\r\n   * Resolves the promise.\r\n   */\r\n  resolve: BetterPromiseResolveFn<Result>;\r\n\r\n  /**\r\n   * @see Promise.then\r\n   */\r\n  override then<A = Result, B = never>(\r\n    onFulfilled?: Maybe<BetterPromiseOnFulfilledFn<Result, A>>,\r\n    onRejected?: Maybe<BetterPromiseOnRejectedFn<B>>,\r\n  ): BetterPromise<A | B> {\r\n    // Use the original promise \"then\" method because in fact, it creates an AbortablePromise\r\n    // instance.\r\n    // Then, reassign the promise \"reject\" method, because not doing it and rejecting the promise\r\n    // it will lead to an unhandled promise rejection.\r\n    //\r\n    // Here is an example:\r\n    // const myPromise = new AbortablePromise(...)\r\n    //   .catch(() => console.log('Catched'));\r\n    //\r\n    // If we don't reassign myPromise's \"reject\" method here, it will reject the promise, returned\r\n    // from the \"catch\" method, which is unexpected. So, even using several catches in a row,\r\n    // a developer will not be able to catch the error, thrown using the \"reject\" method.\r\n    //\r\n    // The expected behavior here is the \"reject\" method rejecting the initially created promise.\r\n    // Then, this error will be handled via the \"catch\" method.\r\n    return withInheritedResolvers(\r\n      super.then(onFulfilled, onRejected) as BetterPromise<A | B>,\r\n      this,\r\n    );\r\n  }\r\n}"],"names":["l","o","e","t","n","c","f","u","s","i","y","a","r","CancelledError","errorClass","TimeoutError","errorClassWithData","timeout","cause","tag","isResolved","value","withResolved","withInheritedResolvers","childPromise","parentPromise","BetterPromise","arg1","maybeOptions","reject","resolve","executor","options","resolved","rejected","isRejected","listeners","cleanupFns","cleanup","fn","controller","isResolvedOrRejected","res","rej","abortOnResolve","abortOnReject","result","_a","_b","reason","abortSignal","listener","timeoutId","voidFn","event","payload","eventListeners","index","__publicField","context","_","onRejected","onFinally","onFulfilled"],"mappings":"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","x_google_ignoreList":[0]}
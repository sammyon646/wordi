"use strict";var B=Object.defineProperty;var D=(r,e,t)=>e in r?B(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var g=(r,e,t)=>D(r,typeof e!="symbol"?e+"":e,t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});var G=Object.defineProperty,H=(r,e,t)=>e in r?G(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,w=(r,e,t)=>H(r,typeof e!="symbol"?e+"":e,t);function P(r){return e=>e instanceof r}function z(r,e){const t=class extends Error{constructor(...f){const l=typeof e=="function"?e(...f):typeof e=="string"?[e]:e||[];super(...l),this.name=r}};w(t,"is",P(t));let c=t;return Object.defineProperty(c,"name",{value:r}),c}function J(r,e,t){const c=class extends z(r,t){constructor(...l){super(...l),w(this,"data"),this.data=e(...l)}};w(c,"is",P(c));let n=c;return Object.defineProperty(n,"name",{value:r}),n}class I extends z("CancelledError","Promise was canceled"){}class L extends J("TimeoutError",e=>({timeout:e}),(e,t)=>[`Timeout reached: ${e}ms`,{cause:t}]){}const F=Symbol("resolved");function K(r){return typeof r=="object"&&!!r&&"tag"in r&&r.tag===F}function A(r){return{tag:F,value:r}}function C(r,e){return r.reject=e.reject,r.resolve=e.resolve,r}class y extends Promise{constructor(t,c){let n,f,l,p;typeof t=="function"?(l=t,p=c||{}):p=t||{};let u,a;const x=()=>!!a,O=()=>!!u;let d={};const j=[],T=()=>{j.forEach(R=>R()),j.splice(0,j.length),d={}},m=new AbortController,S=()=>O()||x();super((R,M)=>{const{abortOnResolve:$=!0,abortOnReject:q=!0}=p;f=o=>{var h,s;S()||(R(o),u=[o],(h=d.resolved)==null||h.forEach(i=>i(o)),(s=d.finalized)==null||s.forEach(i=>i({kind:"resolved",result:o})),T(),$&&m.abort(A(o)))},n=o=>{var h,s;S()||(M(o),a=[o],(h=d.rejected)==null||h.forEach(i=>i(o)),(s=d.finalized)==null||s.forEach(i=>i({kind:"rejected",reason:o})),T(),q&&m.abort(o))};const{abortSignal:b}=p;if(b){if(b.aborted)return n(b.reason);const o=()=>{n(b.reason)};b.addEventListener("abort",o,!0),j.push(()=>{b.removeEventListener("abort",o,!0)})}const{timeout:E}=p;if(E){const o=setTimeout(()=>{n(new L(E))},E);j.push(()=>{clearTimeout(o)})}try{const o=()=>{},h=l&&l(f,n,{abortSignal:m.signal,get isRejected(){return x()},get isResolved(){return O()},on(s,i){if(u||a){if(s==="finalized"){const v=u?{kind:"resolved",result:u[0]}:{kind:"rejected",reason:a[0]};i(v)}else s==="resolved"&&u?i(u[0]):s==="rejected"&&a&&i(a[0]);return o}return d[s]||(d[s]=[]),d[s].push(i),()=>{const v=d[s]||[],k=v.indexOf(i);k>=0&&v.splice(k,1)}},get result(){return u==null?void 0:u[0]},get rejectReason(){return a==null?void 0:a[0]},throwIfRejected(){if(a)throw a[0]}});h instanceof Promise&&h.catch(n)}catch(o){n(o)}});g(this,"reject");g(this,"resolve");this.reject=n,this.resolve=f}static fn(t,c){return new y(async(n,f,l)=>{try{n(await t(l))}catch(p){f(p)}},c)}static resolve(t){return this.fn(()=>t)}static reject(t){return new y((c,n)=>{n(t)})}cancel(){this.reject(new I)}catch(t){return this.then(void 0,t)}finally(t){return C(super.finally(t),this)}then(t,c){return C(super.then(t,c),this)}}exports.BetterPromise=y;exports.CancelledError=I;exports.TimeoutError=L;exports.isResolved=K;exports.withResolved=A;
//# sourceMappingURL=index.cjs.map

var Rt = Object.defineProperty;
var Lt = (s, t, r) => t in s ? Rt(s, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : s[t] = r;
var e = (s, t, r) => Lt(s, typeof t != "symbol" ? t + "" : t, r);
import { batch as Ce, signal as j, computed as F } from "@tma.js/signals";
import { supports as oe, isTMAFp as Pt, postEventFp as Ot, off as le, on as Z, requestFp as Dt, request2Fp as Ut, invokeCustomMethodFp as Gt, retrieveRawInitDataFp as jt, retrieveLaunchParamsFp as Se, captureSameReq as Ht, logger as ot } from "@tma.js/bridge";
import { CancelledError as wo, InvalidLaunchParamsError as Co, InvokeCustomMethodFailedError as So, LaunchParamsRetrieveError as vo, MethodParameterUnsupportedError as yo, MethodUnsupportedError as ko, TimeoutError as Io, UnknownEnvError as Eo, applyPolyfills as Ao, createLogger as xo, createPostEvent as qo, createStartParam as Bo, createStartParamFp as Mo, debug as To, decodeBase64Url as Vo, decodeBase64UrlFp as $o, decodeStartParam as Ro, decodeStartParamFp as Lo, deepSnakeToCamelObjKeys as Po, emitEvent as Oo, encodeBase64Url as Do, getReleaseVersion as Uo, isSafeToCreateStartParam as Go, isTMA as jo, isTMAFp as Ho, logger as Wo, mockTelegramEnv as Ko, off as No, offAll as Qo, on as zo, retrieveLaunchParams as Jo, retrieveLaunchParamsFp as Yo, retrieveRawInitData as Zo, retrieveRawInitDataFp as Xo, retrieveRawLaunchParams as ei, retrieveRawLaunchParamsFp as ti, setDebug as si, setTargetOrigin as ri, supports as ni, targetOrigin as oi } from "@tma.js/bridge";
import { throwifyFpFn as ye, throwifyAnyEither as lt, getStorageValue as Wt, setStorageValue as Kt, snakeToKebab as Nt, createCbCollector as Re, camelToKebab as ht, BetterTaskEither as qe } from "@tma.js/toolkit";
import { BetterPromise as Qt } from "better-promises";
import { toRGBFullFp as zt, isRGB as Ie, pipeQueryToSchema as Jt, pipeJsonToSchema as Yt } from "@tma.js/transformers";
import { isAnyRGB as ai, isRGB as ui, isRGBA as ci, isRGBAShort as pi, isRGBShort as li, parseInitDataQuery as hi, parseInitDataQueryFp as di, parseLaunchParamsQuery as fi, parseLaunchParamsQueryFp as _i, serializeInitDataQuery as mi, serializeLaunchParamsQuery as bi, toRGB as gi, toRGBFp as Fi, toRGBFull as wi, toRGBFullFp as Ci } from "@tma.js/transformers";
import { errorClassWithData as Le, errorClass as W } from "error-kid";
import { parse as it, record as Zt, string as Y, array as Xt, safeParse as Be, looseObject as at, pipe as dt, transform as ft, date as _t, optional as es, number as mt, integer as ts } from "valibot";
var ss = function(s, t, r) {
  if (r || arguments.length === 2) for (var n = 0, i = t.length, o; n < i; n++)
    (o || !(n in t)) && (o || (o = Array.prototype.slice.call(t, 0, n)), o[n] = t[n]);
  return s.concat(o || Array.prototype.slice.call(t));
};
function bt(s, t, r, n, i, o, u, a, l) {
  switch (arguments.length) {
    case 1:
      return s;
    case 2:
      return function() {
        return t(s.apply(this, arguments));
      };
    case 3:
      return function() {
        return r(t(s.apply(this, arguments)));
      };
    case 4:
      return function() {
        return n(r(t(s.apply(this, arguments))));
      };
    case 5:
      return function() {
        return i(n(r(t(s.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return o(i(n(r(t(s.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return u(o(i(n(r(t(s.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return a(u(o(i(n(r(t(s.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return l(a(u(o(i(n(r(t(s.apply(this, arguments)))))))));
      };
  }
}
function c(s, t, r, n, i, o, u, a, l) {
  switch (arguments.length) {
    case 1:
      return s;
    case 2:
      return t(s);
    case 3:
      return r(t(s));
    case 4:
      return n(r(t(s)));
    case 5:
      return i(n(r(t(s))));
    case 6:
      return o(i(n(r(t(s)))));
    case 7:
      return u(o(i(n(r(t(s))))));
    case 8:
      return a(u(o(i(n(r(t(s)))))));
    case 9:
      return l(a(u(o(i(n(r(t(s))))))));
    default: {
      for (var p = arguments[0], m = 1; m < arguments.length; m++)
        p = arguments[m](p);
      return p;
    }
  }
}
var he = function(s, t) {
  var r = typeof s == "number" ? function(n) {
    return n.length >= s;
  } : s;
  return function() {
    var n = Array.from(arguments);
    return r(arguments) ? t.apply(this, n) : function(i) {
      return t.apply(void 0, ss([i], n, !1));
    };
  };
}, rs = { _tag: "None" }, ns = function(s) {
  return { _tag: "Some", value: s };
}, os = function(s) {
  return s._tag === "Left";
}, gt = function(s) {
  return { _tag: "Left", left: s };
}, Ft = function(s) {
  return { _tag: "Right", right: s };
}, Pe = {};
function is(s, t) {
  return function(r) {
    return function(n) {
      return s.ap(s.map(n, function(i) {
        return function(o) {
          return t.ap(i, o);
        };
      }), r);
    };
  };
}
function as(s, t) {
  return function(r) {
    return function(n) {
      return s.map(n, function(i) {
        return t.map(i, r);
      });
    };
  };
}
function Oe(s) {
  return function(t, r) {
    return function(n) {
      return s.chain(n, function(i) {
        return s.map(r(i), function(o) {
          var u;
          return Object.assign({}, i, (u = {}, u[t] = o, u));
        });
      });
    };
  };
}
var T = gt, x = Ft, us = /* @__PURE__ */ he(2, function(s, t) {
  return re(s) ? s : t(s.right);
}), De = function(s, t) {
  return c(s, D(t));
}, wt = function(s, t) {
  return c(s, hs(t));
}, Ue = "Either", D = function(s) {
  return function(t) {
    return re(t) ? t : x(s(t.right));
  };
}, cs = {
  URI: Ue,
  map: De
}, ps = x, ls = function(s) {
  return function(t) {
    return re(t) ? t : re(s) ? s : x(t.right(s.right));
  };
}, hs = ls, ds = {
  URI: Ue,
  map: De,
  ap: wt
}, fs = {
  URI: Ue,
  map: De,
  ap: wt,
  chain: us
}, _s = function(s, t) {
  return function(r) {
    return re(r) ? T(s(r.left)) : x(t(r.right));
  };
}, re = os, Ct = function(s, t) {
  return function(r) {
    return re(r) ? s(r.left) : t(r.right);
  };
}, de = Ct, ms = function(s, t) {
  try {
    return x(s());
  } catch (r) {
    return T(t(r));
  }
}, bs = /* @__PURE__ */ ps(Pe), gs = /* @__PURE__ */ Oe(fs), ut = gs;
function U(s) {
  return typeof s == "function" ? s() : s;
}
class fe {
  constructor({
    onMounted: t,
    restoreState: r,
    initialState: n,
    onUnmounted: i,
    isPageReload: o
  }) {
    e(this, "_isMounted", j(!1));
    /**
     * Signal indicating if the component is mounted.
     */
    e(this, "isMounted", F(this._isMounted));
    /**
     * Mounts the component restoring its state and calling required side effects.
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    this.mount = () => {
      if (this.isMounted())
        return x(void 0);
      const u = U(o) ? r() : void 0, a = u ? x(u) : typeof n == "function" ? n() : x(n);
      return c(a, D((l) => {
        Ce(() => {
          this._isMounted.set(!0), t == null || t(l);
        });
      }));
    }, this.unmount = () => {
      this._isMounted() && Ce(() => {
        this._isMounted.set(!1), i == null || i();
      });
    };
  }
}
function Me(s) {
  const t = {};
  for (const r in s) {
    const n = s[r];
    n !== void 0 && (t[r] = n);
  }
  return t;
}
function Ee(s, t) {
  const r = Object.keys(s), n = Object.keys(t);
  return r.length !== n.length ? !1 : r.every((i) => Object.prototype.hasOwnProperty.call(t, i) && s[i] === t[i]);
}
class ee {
  constructor({ initialState: t, onChange: r }) {
    e(this, "_state");
    /**
     * The current state.
     */
    e(this, "state");
    /**
     * Updates the state.
     * @param state - updates to apply.
     */
    e(this, "setState", (t) => {
      const r = { ...this.state(), ...Me(t) };
      Ee(r, this.state()) || this._state.set(r);
    });
    this._state = j(t, { equals: Ee }), this.state = F(this._state), this.state.sub(r);
  }
  /**
   * Creates a computed signal based on the state.
   * @param key - a state key to use as a source.
   */
  getter(t) {
    return F(() => this._state()[t]);
  }
  /**
   * @returns True if specified payload will update the state.
   * @param state
   */
  hasDiff(t) {
    return !Ee({ ...this.state(), ...Me(t) }, this.state());
  }
}
function z(s, t) {
  return F(() => oe(s, U(t)));
}
var ie = rs, _e = ns, Fs = function(s, t) {
  return c(s, Ss(t));
}, ws = function(s, t) {
  return c(s, ys(t));
}, Cs = "Option", Ss = function(s) {
  return function(t) {
    return pe(t) ? ie : _e(s(t.value));
  };
}, vs = _e, ys = function(s) {
  return function(t) {
    return pe(t) || pe(s) ? ie : _e(t.value(s.value));
  };
}, ks = /* @__PURE__ */ he(2, function(s, t) {
  return pe(s) ? ie : t(s.value);
}), Is = {
  URI: Cs,
  map: Fs,
  ap: ws,
  chain: ks
}, pe = function(s) {
  return s._tag === "None";
}, Es = function(s, t) {
  return function(r) {
    return pe(r) ? s() : t(r.value);
  };
}, St = Es, As = /* @__PURE__ */ vs(Pe), ct = /* @__PURE__ */ Oe(Is);
function h(s) {
  return Object.assign(ye(s), {
    ifAvailable(...t) {
      return c(
        s.ifAvailable(...t),
        St(
          () => ({ ok: !1 }),
          (r) => ({
            ok: !0,
            data: lt(r)
          })
        )
      );
    }
  });
}
function xs(s) {
  return bt(x, s.of);
}
function qs(s) {
  return bt(T, s.of);
}
function Bs(s) {
  return as(s, cs);
}
function Ms(s) {
  return is(s, ds);
}
function Ts(s) {
  return function(t, r) {
    return s.chain(t, function(n) {
      return re(n) ? s.of(n) : r(n.right);
    });
  };
}
function Vs(s) {
  return function(t, r, n) {
    return s.map(t, _s(r, n));
  };
}
function $s(s) {
  return function(t, r) {
    return function(n) {
      return s.map(n, de(t, r));
    };
  };
}
var Ge = function(s, t) {
  return c(s, Rs(t));
}, vt = function(s, t) {
  return c(s, Ls(t));
}, Rs = function(s) {
  return function(t) {
    return function() {
      return Promise.resolve().then(t).then(s);
    };
  };
}, Ls = function(s) {
  return function(t) {
    return function() {
      return Promise.all([Promise.resolve().then(t), Promise.resolve().then(s)]).then(function(r) {
        var n = r[0], i = r[1];
        return n(i);
      });
    };
  };
}, je = function(s) {
  return function() {
    return Promise.resolve(s);
  };
}, Ps = /* @__PURE__ */ he(2, function(s, t) {
  return function() {
    return Promise.resolve().then(s).then(function(r) {
      return t(r)();
    });
  };
}), He = "Task", We = {
  URI: He,
  map: Ge
}, yt = {
  of: je
}, Os = {
  URI: He,
  map: Ge,
  ap: vt
}, Ds = {
  URI: He,
  map: Ge,
  of: je,
  ap: vt,
  chain: Ps
}, Us = function(s, t, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(u) {
      u(o);
    });
  }
  return new (r || (r = Promise))(function(o, u) {
    function a(m) {
      try {
        p(n.next(m));
      } catch (d) {
        u(d);
      }
    }
    function l(m) {
      try {
        p(n.throw(m));
      } catch (d) {
        u(d);
      }
    }
    function p(m) {
      m.done ? o(m.value) : i(m.value).then(a, l);
    }
    p((n = n.apply(s, t || [])).next());
  });
}, Gs = function(s, t) {
  var r = { label: 0, sent: function() {
    if (o[0] & 1) throw o[1];
    return o[1];
  }, trys: [], ops: [] }, n, i, o, u;
  return u = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function a(p) {
    return function(m) {
      return l([p, m]);
    };
  }
  function l(p) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; u && (u = 0, p[0] && (r = 0)), r; ) try {
      if (n = 1, i && (o = p[0] & 2 ? i.return : p[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, p[1])).done) return o;
      switch (i = 0, o && (p = [p[0] & 2, o.value]), p[0]) {
        case 0:
        case 1:
          o = p;
          break;
        case 4:
          return r.label++, { value: p[1], done: !1 };
        case 5:
          r.label++, i = p[1], p = [0];
          continue;
        case 7:
          p = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (p[0] === 6 || p[0] === 2)) {
            r = 0;
            continue;
          }
          if (p[0] === 3 && (!o || p[1] > o[0] && p[1] < o[3])) {
            r.label = p[1];
            break;
          }
          if (p[0] === 6 && r.label < o[1]) {
            r.label = o[1], o = p;
            break;
          }
          if (o && r.label < o[2]) {
            r.label = o[2], r.ops.push(p);
            break;
          }
          o[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      p = t.call(s, r);
    } catch (m) {
      p = [6, m], i = 0;
    } finally {
      n = o = 0;
    }
    if (p[0] & 5) throw p[1];
    return { value: p[0] ? p[1] : void 0, done: !0 };
  }
}, V = /* @__PURE__ */ qs(yt), q = /* @__PURE__ */ xs(yt), kt = je, js = /* @__PURE__ */ $s(We), Hs = function(s, t) {
  return function() {
    return Us(void 0, void 0, void 0, function() {
      var r;
      return Gs(this, function(n) {
        switch (n.label) {
          case 0:
            return n.trys.push([0, 2, , 3]), [4, s().then(Ft)];
          case 1:
            return [2, n.sent()];
          case 2:
            return r = n.sent(), [2, gt(t(r))];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
}, Ws = function(s, t) {
  return c(s, k(t));
}, Ks = function(s, t) {
  return c(s, Ns(t));
}, k = /* @__PURE__ */ Bs(We), Ke = /* @__PURE__ */ he(3, Vs(We)), Ns = /* @__PURE__ */ Ms(Os), Ne = /* @__PURE__ */ he(2, Ts(Ds)), Qs = q, zs = "TaskEither", Js = {
  URI: zs,
  map: Ws,
  ap: Ks,
  chain: Ne
}, Ys = /* @__PURE__ */ Qs(Pe), Zs = /* @__PURE__ */ Oe(Js), Fe = Zs, K = Ne, ae = Ne;
function ne(s) {
  return [s];
}
class we extends Le(
  "ValidationError",
  (t, r) => ({ input: t, issues: r }),
  "Validation error"
) {
}
class Qe extends W(
  "CSSVarsBoundError",
  "CSS variables are already bound"
) {
}
class Xs extends Le("DeviceStorageMethodError", (t) => ({ error: t }), (t) => [t]) {
}
class er extends Le("SecureStorageMethodError", (t) => ({ error: t }), (t) => [t]) {
}
class tr extends W(
  "NotAvailableError",
  ne
) {
}
class qn extends W(
  "InvalidEnvError",
  ne
) {
}
class sr extends W(
  "FunctionNotAvailableError",
  ne
) {
}
class Q extends W(
  "InvalidArgumentsError",
  (t, r) => [t, { cause: r }]
) {
}
class ze extends W(
  "ConcurrentCallError",
  ne
) {
}
class rr extends W(
  "SetEmojiStatusError",
  (t) => [`Failed to set emoji status: ${t}`]
) {
}
class It extends W(
  "AccessDeniedError",
  ne
) {
}
class nr extends W(
  "FullscreenFailedError",
  ne
) {
}
class or extends W(
  "ShareMessageError",
  ne
) {
}
class ir extends W(
  "UnknownThemeParamsKeyError",
  (t) => [`Unknown theme params key passed: ${t}`]
) {
}
function A(s, t) {
  const r = F(() => U(t.version) || "100"), n = F(() => U(t.isTma)), { requires: i, returns: o } = t, u = i ? typeof i == "object" ? i : { every: [i] } : void 0, a = (_) => {
    if (!t.supports)
      return !0;
    const b = t.supports[_];
    return oe(b.method, b.param, r());
  }, l = () => {
    if (!u)
      return;
    const [_, b] = "every" in u ? ["every", u.every] : ["some", u.some];
    for (let f = 0; f < b.length; f++) {
      const B = b[f], L = typeof B == "function" ? B() : oe(B, r()) ? void 0 : `it is unsupported in Mini Apps version ${r()}`;
      if (L && (_ === "every" || f === b.length - 1))
        return L;
    }
  }, p = (..._) => {
    for (const b in t.supports)
      if (t.supports[b].shouldCheck(..._) && !a(b))
        return `option ${b} is not supported in Mini Apps version ${r()}`;
  }, m = F(() => !l()), d = F(() => r() !== "0.0"), w = F(() => t.isMounted ? t.isMounted() : !0), g = F(
    () => n() && d() && m() && w()
  ), S = (_) => {
    const b = new sr(_);
    return ["task", "promise"].includes(t.returns) ? V(b) : T(b);
  }, v = (..._) => o === "plain" ? ms(() => s(..._), (b) => b) : o === "promise" ? Hs(() => s(..._), (b) => b) : s(..._);
  return Object.assign(
    (..._) => {
      var L;
      const b = "Unable to call function:";
      if (!n())
        return S(`${b} it can't be called outside Mini Apps`);
      if (!d())
        return S(`${b} the SDK was not initialized. Use the SDK init() function`);
      const f = l();
      if (f)
        return S(`${b} ${f}`);
      const B = p(..._);
      if (B)
        return S(`${b} ${B}`);
      if (!w()) {
        const $ = (L = t.isMounting) != null && L.call(t) ? "mounting. Wait for the mount completion" : "unmounted. Use the mount() method";
        return S(`${b} the component is ${$}`);
      }
      return v(..._);
    },
    s,
    {
      isAvailable: g,
      ifAvailable(..._) {
        return g() ? _e(v(..._)) : ie;
      }
    },
    u ? { isSupported: m } : {},
    t.supports ? { supports: a } : {}
  );
}
function I(s) {
  return (t) => A(t, s);
}
class ke {
  constructor({
    isTma: t,
    storage: r,
    onClick: n,
    offClick: i,
    initialState: o,
    isPageReload: u,
    postEvent: a,
    payload: l,
    method: p,
    version: m
  }) {
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Complete button state.
     */
    e(this, "state");
    /**
     * @returns A setter with checks for the specified key.
     * @param key
     */
    e(this, "stateSetters");
    /**
     * @returns Setters with checks to set a specified boolean key.
     * @param key
     */
    e(this, "stateBoolSetters");
    /**
     * Updates the button state.
     */
    e(this, "setStateFp");
    /**
     * @see setStateFp
     */
    e(this, "setState");
    /**
     * Adds a new button listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @returns A function to remove bound listener.
     * @example
     * const off = button.onClick(() => {
     *   console.log('User clicked the button');
     *   off();
     * });
     */
    e(this, "onClickFp");
    /**
     * @see onClickFp
     */
    e(this, "onClick");
    /**
     * Removes the button click listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @example
     * function listener() {
     *   console.log('User clicked the button');
     *   button.offClick(listener);
     * }
     * button.onClick(listener);
     */
    e(this, "offClickFp");
    /**
     * @see offClickFp
     */
    e(this, "offClick");
    /**
     * Mounts the component restoring its state.
     * @since Mini Apps v6.1
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     *
     * Note that this function does not remove listeners added via the `onClick`
     * function, so you have to remove them on your own.
     * @see onClick
     */
    e(this, "unmount");
    const d = new ee({
      initialState: o,
      onChange(_) {
        r.set(_);
      }
    }), w = new fe({
      initialState: o,
      isPageReload: u,
      onMounted: d.setState,
      restoreState: r.get
    }), g = { version: m, requires: p, isTma: t }, S = I({
      ...g,
      returns: "plain"
    }), v = I({
      ...g,
      returns: "either",
      isMounted: w.isMounted
    });
    this.isMounted = w.isMounted, this.isSupported = z(p, m), this.state = d.state, this.setStateFp = v((_) => {
      const b = { ...this.state(), ...Me(_) };
      return d.hasDiff(b) ? c(
        a(p, l(b)),
        D(() => {
          d.setState(b);
        })
      ) : x(void 0);
    }), this.setState = h(this.setStateFp), this.onClickFp = S(n), this.onClick = h(this.onClickFp), this.offClickFp = S(i), this.offClick = h(this.offClickFp), this.mountFp = S(() => {
      const _ = () => {
      };
      return c(w.mount(), de(_, _));
    }), this.mount = h(this.mountFp), this.unmount = w.unmount, this.stateSetters = (_) => {
      const b = v((f) => this.setStateFp({ [_]: f }));
      return [h(b), b];
    }, this.stateBoolSetters = (_) => {
      const [, b] = this.stateSetters(_), f = v(() => b(!1)), B = v(() => b(!0));
      return [
        [h(f), f],
        [h(B), B]
      ];
    };
  }
  /**
   * @returns A computed based on the specified state and its related key.
   * @param key - a key to use.
   */
  stateGetter(t) {
    return F(() => this.state()[t]);
  }
}
class ar {
  constructor(t) {
    /**
     * Signal indicating if the component is currently visible.
     */
    e(this, "isVisible");
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Hides the button.
     * @since Mini Apps v6.1
     */
    e(this, "hideFp");
    /**
     * @see hideFp
     */
    e(this, "hide");
    /**
     * Shows the button.
     * @since Mini Apps v6.1
     */
    e(this, "showFp");
    /**
     * @see showFp
     */
    e(this, "show");
    /**
     * Adds a new button listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @returns A function to remove bound listener.
     * @since Mini Apps v6.1
     * @example
     * const off = button.onClick(() => {
     *   console.log('User clicked the button');
     *   off();
     * });
     */
    e(this, "onClickFp");
    /**
     * @see onClickFp
     */
    e(this, "onClick");
    /**
     * Removes the button click listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @since Mini Apps v6.1
     * @example
     * function listener() {
     *   console.log('User clicked the button');
     *   button.offClick(listener);
     * }
     * button.onClick(listener);
     */
    e(this, "offClickFp");
    /**
     * @see offClickFp
     */
    e(this, "offClick");
    /**
     * Mounts the component restoring its state.
     * @since Mini Apps v6.1
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     *
     * Note that this function does not remove listeners added via the `onClick`
     * function, so you have to remove them on your own.
     * @see onClick
     */
    e(this, "unmount");
    const r = new ke({
      ...t,
      method: "web_app_setup_back_button",
      payload: (n) => ({ is_visible: n.isVisible }),
      initialState: { isVisible: !1 }
    });
    this.isVisible = r.stateGetter("isVisible"), this.isMounted = r.isMounted, this.isSupported = r.isSupported, [[this.hide, this.hideFp], [this.show, this.showFp]] = r.stateBoolSetters("isVisible"), this.onClick = r.onClick, this.onClickFp = r.onClickFp, this.offClick = r.offClick, this.offClickFp = r.offClickFp, this.mount = r.mount, this.mountFp = r.mountFp, this.unmount = r.unmount;
  }
}
function C() {
  return { isTma: F(() => Pt()) };
}
function ue(s) {
  return (t) => ({ ...t, ...U(s) });
}
// @__NO_SIDE_EFFECTS__
function me(s, t) {
  return j(s, t);
}
const Et = /* @__PURE__ */ me(Ot), ce = (...s) => Et()(...s), ur = (...s) => lt(ce(...s)), R = ue({
  postEvent: ce
});
function cr(s) {
  return {
    get: () => Wt(s),
    set(t) {
      Kt(s, t);
    }
  };
}
function pr() {
  return performance.getEntriesByType("navigation")[0];
}
function lr() {
  const s = pr();
  return !!s && s.type === "reload";
}
function te(s) {
  return ue({
    storage: cr(s),
    isPageReload: lr
  });
}
const Te = /* @__PURE__ */ me("0.0"), y = ue({ version: Te });
function Je(s, t) {
  return {
    ...c(
      C(),
      R,
      y,
      te(s)
    ),
    onClick(r, n) {
      return Z(t, r, n);
    },
    offClick(r, n) {
      le(t, r, n);
    }
  };
}
const Bn = new ar(Je("backButton", "back_button_pressed"));
class Ye {
  constructor({
    initialState: t,
    onMounted: r,
    restoreState: n,
    onUnmounted: i,
    isPageReload: o
  }) {
    e(this, "_isMounted", j(!1));
    /**
     * Signal indicating if the component is mounted.
     */
    e(this, "isMounted", F(this._isMounted));
    /**
     * Mounts the component restoring its state and calling required side effects.
     * @param options - additional execution options.
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    this.mount = (u) => {
      if (this._isMounted())
        return q(void 0);
      const a = U(o) ? n() : void 0;
      return c(
        a ? q(a) : t(u),
        k((l) => {
          this._isMounted() || Ce(() => {
            this._isMounted.set(!0), r == null || r(l);
          });
        })
      );
    }, this.unmount = () => {
      this._isMounted() && Ce(() => {
        this._isMounted.set(!1), i == null || i();
      });
    };
  }
}
const pt = new tr("Biometry is not available");
function Ae(s) {
  let t = !1, r = !1, n = "", i = !1, o = "", u = !1;
  return s.available && (t = !0, r = s.token_saved, n = s.device_id, i = s.access_requested, o = s.type, u = s.access_granted), { available: t, tokenSaved: r, deviceId: n, type: o, accessGranted: u, accessRequested: i };
}
class hr {
  constructor({
    version: t,
    request: r,
    postEvent: n,
    storage: i,
    onInfoReceived: o,
    offInfoReceived: u,
    isTma: a,
    isPageReload: l
  }) {
    /**
     * Signal indicating if biometry is available.
     */
    e(this, "isAvailable");
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Signal indicating if the component is mounted.
     */
    e(this, "isMounted");
    /**
     * Complete component state.
     */
    e(this, "state");
    /**
     * Attempts to authenticate a user using biometrics and fetch a previously stored secure token.
     * @param options - method options.
     * @since Mini Apps v7.2
     * @returns Token from the local secure storage saved previously or undefined.
     * @example
     * const { status, token } = await biometry.authenticate({
     *   reason: 'Authenticate to open wallet',
     * });
     */
    e(this, "authenticateFp");
    /**
     * @see authenticateFp
     */
    e(this, "authenticate");
    /**
     * Opens the biometric access settings for bots. Useful when you need to request biometrics
     * access to users who haven't granted it yet.
     *
     * _Note that this method can be called only in response to user interaction with the Mini App
     * interface (e.g. a click inside the Mini App or on the main button)_.
     * @since Mini Apps v7.2
     */
    e(this, "openSettingsFp");
    /**
     * @see openSettingsFp
     */
    e(this, "openSettings");
    /**
     * Requests permission to use biometrics.
     * @since Mini Apps v7.2
     * @returns Promise with true, if access was granted.
     * @example
     * const accessGranted = await biometry.requestAccess({
     *   reason: 'Authenticate to open wallet',
     * });
     */
    e(this, "requestAccessFp");
    /**
     * @see requestAccessFp
     */
    e(this, "requestAccess");
    /**
     * Updates the biometric token in a secure storage on the device.
     * @since Mini Apps v7.2
     * @returns Promise with `true`, if token was updated.
     * @example Setting a new token
     * biometry.updateToken({
     *   token: 'abcdef',
     * })
     * @example Deleting the token
     * biometry.updateToken();
     */
    e(this, "updateTokenFp");
    /**
     * @see updateTokenFp
     */
    e(this, "updateToken");
    /**
     * Mounts the component restoring its state.
     * @since Mini Apps v7.2
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    const p = (_) => {
      m.setState(Ae(_));
    }, m = new ee({
      initialState: {
        available: !1,
        type: "unknown",
        accessGranted: !1,
        accessRequested: !1,
        deviceId: "",
        tokenSaved: !1
      },
      onChange: i.set
    }), d = new Ye({
      initialState(_) {
        return c(
          r("web_app_biometry_get_info", "biometry_info_received", _),
          k(Ae)
        );
      },
      isPageReload: l,
      onMounted(_) {
        m.setState(_), o(p);
      },
      onUnmounted() {
        u(p);
      },
      restoreState: i.get
    }), w = { version: t, requires: "web_app_biometry_request_auth", isTma: a }, g = I({
      ...w,
      returns: "either"
    }), S = I({
      ...w,
      returns: "task"
    }), v = I({
      ...w,
      isMounted: d.isMounted,
      returns: "task"
    });
    this.isAvailable = m.getter("available"), this.isMounted = d.isMounted, this.isSupported = z("web_app_biometry_request_auth", t), this.state = m.state, this.unmount = d.unmount, this.mountFp = S(d.mount), this.authenticateFp = v((_) => this.isAvailable() ? c(
      r("web_app_biometry_request_auth", "biometry_auth_requested", {
        ..._,
        params: { reason: ((_ || {}).reason || "").trim() }
      }),
      k((b) => (m.setState({ token: b.token }), b))
    ) : V(pt)), this.openSettingsFp = g(() => n("web_app_biometry_open_settings")), this.requestAccessFp = v((_) => c(
      r("web_app_biometry_request_access", "biometry_info_received", {
        ..._,
        params: { reason: ((_ || {}).reason || "").trim() }
      }),
      K((b) => {
        const f = Ae(b);
        return f.available ? (m.setState(f), q(f.accessRequested)) : V(pt);
      })
    )), this.updateTokenFp = v((_ = {}) => {
      var b;
      return c(
        r("web_app_biometry_update_token", "biometry_token_updated", {
          ..._,
          params: { token: _.token || "", reason: (b = _.reason) == null ? void 0 : b.trim() }
        }),
        k((f) => f.status)
      );
    }), this.authenticate = h(this.authenticateFp), this.openSettings = h(this.openSettingsFp), this.requestAccess = h(this.requestAccessFp), this.updateToken = h(this.updateTokenFp), this.mount = h(this.mountFp);
  }
}
const dr = (s, t, r) => Dt(s, t, {
  postEvent: ce,
  ...r
}), fr = (s, t, r) => Ut(s, t, {
  postEvent: ce,
  ...r
}), Mn = (...s) => Qt.fn(() => dr(...s)()), P = ue({ request: fr }), Tn = new hr({
  ...c(
    C(),
    R,
    y,
    P,
    te("biometry")
  ),
  offInfoReceived(s) {
    le("biometry_info_received", s);
  },
  onInfoReceived(s) {
    return Z("biometry_info_received", s);
  }
});
class _r {
  constructor({ postEvent: t, storage: r, isTma: n, isPageReload: i }) {
    /**
     * Signal indicating if closing confirmation dialog is currently enabled.
     */
    e(this, "isConfirmationEnabled");
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * Mounts the component restoring its state.
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    /**
     * Disables the closing confirmation dialog.
     */
    e(this, "disableConfirmationFp");
    /**
     * @see disableConfirmationFp
     */
    e(this, "disableConfirmation");
    /**
     * Enables the closing confirmation dialog.
     */
    e(this, "enableConfirmationFp");
    /**
     * @see enableConfirmationFp
     */
    e(this, "enableConfirmation");
    const o = new ee({
      initialState: { isConfirmationEnabled: !1 },
      onChange(d) {
        r.set(d);
      }
    }), u = new fe({
      onMounted: o.setState,
      restoreState: r.get,
      initialState: { isConfirmationEnabled: !1 },
      isPageReload: i
    }), a = { requires: "web_app_setup_closing_behavior", isTma: n }, l = I({
      ...a,
      returns: "plain"
    }), p = I({
      ...a,
      returns: "either",
      isMounted: u.isMounted
    }), m = (d) => d === this.isConfirmationEnabled() ? x(void 0) : (o.setState({ isConfirmationEnabled: d }), t("web_app_setup_closing_behavior", {
      need_confirmation: d
    }));
    this.isConfirmationEnabled = o.getter("isConfirmationEnabled"), this.isMounted = u.isMounted, this.disableConfirmationFp = p(() => m(!1)), this.enableConfirmationFp = p(() => m(!0)), this.mountFp = l(() => {
      const d = () => {
      };
      return c(u.mount(), de(d, d));
    }), this.unmount = u.unmount, this.disableConfirmation = h(this.disableConfirmationFp), this.enableConfirmation = h(this.enableConfirmationFp), this.mount = h(this.mountFp);
  }
}
const Vn = new _r(c(
  C(),
  te("closingBehavior"),
  R
));
class mr {
  constructor({ version: t, isTma: r, invokeCustomMethod: n }) {
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Deletes specified key or keys from the cloud storage.
     * @param keyOrKeys - key or keys to delete.
     * @param options - request execution options.
     * @since Mini Apps v6.9
     */
    e(this, "deleteItemFp");
    e(this, "deleteItem");
    /**
     * Gets a single key value from the cloud storage.
     * @param key - a key to get.
     * @param options - request execution options.
     * @returns A key value as a string.
     * @since Mini Apps v6.9
     */
    e(this, "getItemFp");
    /**
     * @see getItemFp
     */
    e(this, "getItem");
    /**
     * Gets multiple keys' values from the cloud storage.
     * @param keys - keys list.
     * @param options - request execution options.
     * @returns A map, where a key is one of the specified in the `keys` argument,
     * and a value is a corresponding storage value if an array of keys was passed.
     * @since Mini Apps v6.9
     */
    e(this, "getItemsFp");
    /**
     * @see getItemsFp
     */
    e(this, "getItems");
    /**
     * Returns a list of all keys presented in the cloud storage.
     * @param options - request execution options.
     * @since Mini Apps v6.9
     */
    e(this, "getKeysFp");
    /**
     * @see getKeysFp
     */
    e(this, "getKeys");
    /**
     * Saves the specified value by a key.
     * @param key - storage key.
     * @param value - storage value.
     * @param options - request execution options.
     * @since Mini Apps v6.9
     */
    e(this, "setItemFp");
    /**
     * @see setItemFp
     */
    e(this, "setItem");
    /**
     * Clears the cloud storage.
     * @param options - additional options.
     * @since Mini Apps v6.9
     */
    e(this, "clearFp");
    /**
     * @see clearFp
     */
    e(this, "clear");
    const i = I({
      version: t,
      requires: "web_app_invoke_custom_method",
      isTma: r,
      returns: "task"
    });
    this.isSupported = z("web_app_invoke_custom_method", t), this.deleteItemFp = i((o, u) => {
      const a = Array.isArray(o) ? o : [o];
      return c(
        a.length ? n("deleteStorageValues", { keys: a }, u) : q(void 0),
        k(() => {
        })
      );
    }), this.getItemFp = i((o, u) => c(
      this.getItemsFp([o], u),
      k((a) => a[o] || "")
    )), this.getItemsFp = i((o, u) => c(
      o.length ? n("getStorageValues", { keys: o }, u) : q({}),
      k((a) => ({
        // Fulfill the response with probably missing keys.
        ...o.reduce((l, p) => (l[p] = "", l), {}),
        ...it(Zt(Y(), Y()), a)
      }))
    )), this.getKeysFp = i((o) => c(
      n("getStorageKeys", {}, o),
      k((u) => it(Xt(Y()), u))
    )), this.setItemFp = i((o, u, a) => c(
      n("saveStorageValue", { key: o, value: u }, a),
      k(() => {
      })
    )), this.clearFp = i((o) => c(this.getKeysFp(o), K(this.deleteItemFp))), this.deleteItem = h(this.deleteItemFp), this.getItem = h(this.getItemFp), this.getItems = h(this.getItemsFp), this.getKeys = h(this.getKeysFp), this.setItem = h(this.setItemFp), this.clear = h(this.clearFp);
  }
}
const xe = /* @__PURE__ */ me(0);
function Ze() {
  return xe.set(xe() + 1), xe().toString();
}
function br(s, t, r) {
  return Gt(s, t, Ze(), {
    ...r || {},
    postEvent: ce
  });
}
const Xe = ue({
  invokeCustomMethod: br
}), $n = new mr(c(
  C(),
  y,
  Xe
));
class gr {
  constructor({ isTma: t, request: r, version: n, createRequestId: i }) {
    /**
      * Retrieves an item using its key.
      * @since Mini Apps v9.0
      */
    e(this, "getItemFp");
    /**
     * @see getItemFp
     */
    e(this, "getItem");
    /**
      * Sets a new item in the storage.
      * @since Mini Apps v9.0
      */
    e(this, "setItemFp");
    /**
     * @see setItemFp
     */
    e(this, "setItem");
    /**
      * Removes a key from the storage.
      * @since Mini Apps v9.0
      */
    e(this, "deleteItemFp");
    /**
     * @see deleteItemFp
     */
    e(this, "deleteItem");
    /**
      * Removes all keys from the storage.
      * @since Mini Apps v9.0
      */
    e(this, "clearFp");
    /**
     * @see clearFp
     */
    e(this, "clear");
    const o = I({
      version: n,
      requires: "web_app_device_storage_get_key",
      isTma: t,
      returns: "task"
    }), u = (a, l, p) => {
      const m = i();
      return c(
        r(a, ["device_storage_failed", l], {
          params: { ...p, req_id: m },
          capture: (d) => "payload" in d ? d.payload.req_id === m : !0
        }),
        K((d) => d.event === "device_storage_failed" ? V(new Xs(d.payload.error || "UNKNOWN_ERROR")) : q(d.payload))
      );
    };
    this.getItemFp = o((a) => c(
      u("web_app_device_storage_get_key", "device_storage_key_received", { key: a }),
      k((l) => l.value)
    )), this.setItemFp = o((a, l) => c(
      u("web_app_device_storage_save_key", "device_storage_key_saved", { key: a, value: l }),
      k(() => {
      })
    )), this.deleteItemFp = o((a) => this.setItemFp(a, null)), this.clearFp = o(() => c(
      u("web_app_device_storage_clear", "device_storage_cleared", {}),
      k(() => {
      })
    )), this.getItem = h(this.getItemFp), this.setItem = h(this.setItemFp), this.deleteItem = h(this.deleteItemFp), this.clear = h(this.clearFp);
  }
}
const At = ue({ createRequestId: Ze }), Rn = new gr(c(
  C(),
  y,
  P,
  At
));
function Fr({ request: s, ...t }) {
  return A((r) => c(
    s("web_app_request_emoji_status_access", "emoji_status_access_requested", r),
    k((n) => n.status)
  ), { ...t, requires: "web_app_request_emoji_status_access", returns: "task" });
}
const wr = Fr(c(
  C(),
  y,
  P
)), Ln = h(wr);
function Cr({ request: s, ...t }) {
  return A((r, n) => c(
    s("web_app_set_emoji_status", ["emoji_status_set", "emoji_status_failed"], {
      params: {
        custom_emoji_id: r,
        duration: (n || {}).duration
      },
      ...n
    }),
    ae((i) => i.event === "emoji_status_failed" ? V(new rr(i.payload.error)) : q(void 0))
  ), {
    ...t,
    requires: "web_app_set_emoji_status",
    returns: "task"
  });
}
const Sr = Cr(c(
  C(),
  P,
  y
)), Pn = h(Sr);
class vr {
  constructor({ postEvent: t, isTma: r, version: n }) {
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * A method that tells if an impact occurred. The Telegram app may play the
     * appropriate haptics based on style value passed.
     * @param style - impact style.
     * @since Mini Apps v6.1
     */
    e(this, "impactOccurredFp");
    /**
     * @see impactOccurredFp
     */
    e(this, "impactOccurred");
    /**
     * A method tells that a task or action has succeeded, failed, or produced
     * a warning. The Telegram app may play the appropriate haptics based on type
     * value passed.
     * @param type - notification type.
     * @since Mini Apps v6.1
     */
    e(this, "notificationOccurredFp");
    /**
     * @see notificationOccurredFp
     */
    e(this, "notificationOccurred");
    /**
     * A method tells that the user has changed a selection. The Telegram app may
     * play the appropriate haptics.
     *
     * Do not use this feedback when the user makes or confirms a selection; use
     * it only when the selection changes.
     * @since Mini Apps v6.1
     */
    e(this, "selectionChangedFp");
    /**
     * @see selectionChangedFp
     */
    e(this, "selectionChanged");
    const i = "web_app_trigger_haptic_feedback", o = I({
      requires: i,
      isTma: r,
      version: n,
      returns: "plain"
    });
    this.isSupported = z(i, n), this.impactOccurredFp = o((u) => t(i, { type: "impact", impact_style: u })), this.notificationOccurredFp = o((u) => t(i, { type: "notification", notification_type: u })), this.selectionChangedFp = o(() => t(i, { type: "selection_change" })), this.impactOccurred = h(this.impactOccurredFp), this.notificationOccurred = h(this.notificationOccurredFp), this.selectionChanged = h(this.selectionChangedFp);
  }
}
const On = new vr(c(
  C(),
  R,
  y
));
function yr({ postEvent: s, ...t }) {
  return A(() => s("web_app_add_to_home_screen"), { ...t, requires: "web_app_add_to_home_screen", returns: "either" });
}
const kr = yr(c(
  C(),
  y,
  R
)), Dn = h(kr);
function Ir({ request: s, ...t }) {
  return A((r) => c(
    s("web_app_check_home_screen", "home_screen_checked", r),
    k((n) => n.status || "unknown")
  ), { ...t, requires: "web_app_check_home_screen", returns: "task" });
}
const Er = Ir(c(
  C(),
  y,
  P
)), Un = h(Er);
class Ar {
  constructor({ retrieveInitData: t }) {
    e(this, "_state", j());
    e(this, "_raw", j());
    /**
     * Complete component state.
     */
    e(this, "state", F(this._state));
    /**
     * @see InitDataType.auth_date
     */
    e(this, "authDate", this.fromState("auth_date"));
    /**
     * @see InitDataType.can_send_after
     */
    e(this, "canSendAfter", this.fromState("can_send_after"));
    /**
     * Date after which it is allowed to call
     * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.
     */
    e(this, "canSendAfterDate", F(() => {
      const t = this.authDate(), r = this.canSendAfter();
      return r && t ? new Date(t.getTime() + r * 1e3) : void 0;
    }));
    /**
     * @see InitDataType.chat
     */
    e(this, "chat", this.fromState("chat"));
    /**
     * @see InitDataType.chat_type
     */
    e(this, "chatType", this.fromState("chat_type"));
    /**
     * @see InitDataType.chat_instance
     */
    e(this, "chatInstance", this.fromState("chat_instance"));
    /**
     * @see InitDataType.hash
     */
    e(this, "hash", this.fromState("hash"));
    /**
     * @see InitDataType.query_id
     */
    e(this, "queryId", this.fromState("query_id"));
    /**
     * Raw representation of init data.
     */
    e(this, "raw", F(this._raw));
    /**
     * @see InitDataType.receiver
     */
    e(this, "receiver", this.fromState("receiver"));
    /**
     * @see InitDataType.signature
     */
    e(this, "signature", this.fromState("signature"));
    /**
     * @see InitDataType.start_param
     */
    e(this, "startParam", this.fromState("start_param"));
    /**
     * @see InitDataType.user
     */
    e(this, "user", this.fromState("user"));
    /**
     * Restores the component state.
     */
    e(this, "restoreFp");
    /**
     * @see restoreFp
     */
    e(this, "restore");
    this.restoreFp = () => c(
      t(),
      D(St(() => {
      }, ({ raw: r, obj: n }) => {
        this._state.set(n), this._raw.set(r);
      }))
    ), this.restore = ye(this.restoreFp);
  }
  fromState(t) {
    return F(() => {
      const r = this._state();
      return r ? r[t] : void 0;
    });
  }
}
const Gn = new Ar({
  retrieveInitData() {
    return c(
      bs,
      ut("obj", () => c(
        Se(),
        D(({ tgWebAppData: s }) => s ? _e(s) : ie)
      )),
      ut("raw", jt),
      D(({ obj: s, raw: t }) => c(
        As,
        ct("obj", () => s),
        ct("raw", () => t)
      ))
    );
  }
});
class xr {
  constructor({ version: t, request: r, isTma: n }) {
    /**
     * Signal indicating if any invoice is currently opened.
     */
    e(this, "isOpened");
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Opens an invoice using its slug or URL.
     * @param slug - invoice slug.
     * @param options - additional options.
     * @since Mini Apps v6.1
     * @example
     * const status = await invoice.openSlug('kJNFS331');
     */
    e(this, "openSlugFp");
    /**
     * @see openSlugFp
     */
    e(this, "openSlug");
    /**
     * Opens an invoice using its URL.
     * @param url - invoice URL.
     * @param options - additional options.
     * @since Mini Apps v6.1
     * @example
     * const status = await invoice.openUrl('https://t.me/$kJNFS331');
     */
    e(this, "openUrlFp");
    /**
     * @see openUrlFp
     */
    e(this, "openUrl");
    const i = I({
      version: t,
      isTma: n,
      requires: "web_app_open_invoice",
      returns: "task"
    }), o = j(!1), u = () => {
      o.set(!1);
    };
    this.isSupported = z("web_app_open_invoice", t), this.isOpened = F(o), this.openSlugFp = i((a, l) => c(
      this.isOpened() ? V(new ze("Invoice is already opened")) : q(void 0),
      K(() => (o.set(!0), r("web_app_open_invoice", "invoice_closed", {
        ...l,
        params: { slug: a },
        capture: (p) => a === p.slug
      }))),
      Ke((p) => (u(), p), (p) => (u(), p.status))
    )), this.openUrlFp = i((a, l) => {
      const { hostname: p, pathname: m } = new URL(a, window.location.href);
      if (p !== "t.me")
        return V(new Q(`Link has unexpected hostname: ${p}`));
      const d = m.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
      return d ? this.openSlugFp(d[2], l) : V(new Q(
        'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"'
      ));
    }), this.openUrl = h(this.openUrlFp), this.openSlug = h(this.openSlugFp);
  }
}
const jn = new xr(c(C(), P, y));
function qr({ postEvent: s, ...t }) {
  return A((r, n = {}) => {
    if (typeof r == "string")
      try {
        r = new URL(r);
      } catch (i) {
        return T(new Q(`"${r.toString()}" is invalid URL`, i));
      }
    return s("web_app_open_link", {
      url: r.toString(),
      try_browser: n.tryBrowser,
      try_instant_view: n.tryInstantView
    });
  }, { ...t, returns: "either" });
}
const Br = qr(c(
  C(),
  R
)), Hn = h(Br);
function Mr({ postEvent: s, version: t, ...r }) {
  return A((n) => {
    const i = n.toString();
    return i.match(/^https:\/\/t.me\/.+/) ? oe("web_app_open_tg_link", U(t)) ? (n = new URL(n), s("web_app_open_tg_link", { path_full: n.pathname + n.search })) : (window.location.href = i, x(void 0)) : T(new Q(`"${i}" is invalid URL`));
  }, { ...r, returns: "either" });
}
const xt = Mr(c(
  C(),
  R,
  y
)), Wn = h(xt);
function Tr({ openTelegramLink: s, ...t }) {
  return A((r, n) => s(
    "https://t.me/share/url?" + new URLSearchParams({ url: r, text: n || "" }).toString().replace(/\+/g, "%20")
  ), { ...t, returns: "either" });
}
const Vr = Tr({
  ...C(),
  openTelegramLink: xt
}), Kn = h(Vr);
function $r(s) {
  let t = !1, r, n;
  return s.available && (t = !0, r = s.access_requested, n = s.access_granted), {
    available: t,
    accessGranted: n || !1,
    accessRequested: r || !1
  };
}
class Rr {
  constructor({
    version: t,
    request: r,
    postEvent: n,
    storage: i,
    isTma: o,
    isPageReload: u
  }) {
    /**
     * Complete location manager state.
     */
    e(this, "state");
    /**
     * Signal indicating whether the location data tracking is currently available.
     */
    e(this, "isAvailable");
    /**
     * Signal indicating whether the user has granted the app permission to track location data.
     */
    e(this, "isAccessGranted");
    /**
     * Signal indicating whether the app has previously requested permission to track location data.
     */
    e(this, "isAccessRequested");
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Opens the location access settings for bots. Useful when you need to request location access
     * from users who haven't granted it yet.
     *
     * Note that this method can be called only in response to user interaction with the Mini App
     * interface (e.g., a click inside the Mini App or on the main button).
     * @since Mini Apps v8.0
     */
    e(this, "openSettingsFp");
    /**
     * @see openSettingsFp
     */
    e(this, "openSettings");
    /**
     * Requests location data.
     * @since Mini Apps v8.0
     * @returns Promise with location data or null it access was not granted.
     */
    e(this, "requestLocationFp");
    /**
     * @see requestLocationFp
     */
    e(this, "requestLocation");
    /**
     * Mounts the component restoring its state.
     * @since Mini Apps v8.0
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    const a = new ee({
      initialState: {
        available: !1,
        accessGranted: !1,
        accessRequested: !1
      },
      onChange: i.set
    }), l = new Ye({
      isPageReload: u,
      restoreState: i.get,
      onMounted: a.setState,
      initialState(g) {
        return c(
          r("web_app_check_location", "location_checked", g),
          k($r)
        );
      }
    }), p = { version: t, requires: "web_app_check_location", isTma: o }, m = I({
      ...p,
      returns: "either"
    }), d = I({
      ...p,
      returns: "task"
    }), w = I({
      ...p,
      returns: "task",
      isMounted: l.isMounted
    });
    this.isAvailable = a.getter("available"), this.isAccessRequested = a.getter("accessRequested"), this.isAccessGranted = a.getter("accessGranted"), this.isSupported = z("web_app_check_location", t), this.isMounted = l.isMounted, this.state = a.state, this.unmount = l.unmount, this.mountFp = d(l.mount), this.openSettingsFp = m(() => n("web_app_open_location_settings")), this.requestLocationFp = w((g) => c(
      r("web_app_request_location", "location_requested", g),
      k((S) => {
        if (!S.available)
          return a.setState({ available: !1 }), null;
        const { available: v, ..._ } = S;
        return _;
      })
    )), this.mount = h(this.mountFp), this.openSettings = h(this.openSettingsFp), this.requestLocation = h(this.requestLocationFp);
  }
}
const Nn = new Rr(c(
  C(),
  R,
  y,
  P,
  te("locationManager")
));
class Lr {
  constructor({ defaults: t, ...r }) {
    //#region Properties.
    /**
     * The button background color.
     */
    e(this, "bgColor");
    /**
     * True if the button has a shining effect.
     */
    e(this, "hasShineEffect");
    /**
     * True if the button is clickable.
     */
    e(this, "isEnabled");
    /**
     * True if the button loader is visible.
     */
    e(this, "isLoaderVisible");
    /**
     * True if the button is visible.
     */
    e(this, "isVisible");
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * The complete button state.
     */
    e(this, "state");
    /**
     * The button displayed text.
     */
    e(this, "text");
    /**
     * The button text color.
     *
     * Note that this value is computed based on the external defaults. For
     * example, if not explicitly set, this value may be equal to one of theme
     * params colors.
     */
    e(this, "textColor");
    //#endregion
    //#region Methods.
    /**
     * Shows the button.
     */
    e(this, "showFp");
    /**
     * @see showFp
     */
    e(this, "show");
    /**
     * Hides the button.
     */
    e(this, "hideFp");
    /**
     * @see hideFp
     */
    e(this, "hide");
    /**
     * Enables the button.
     */
    e(this, "enableFp");
    /**
     * @see enableFp
     */
    e(this, "enable");
    /**
     * Enables the button.
     */
    e(this, "enableShineEffectFp");
    /**
     * @see enableShineEffectFp
     */
    e(this, "enableShineEffect");
    /**
     * Disables the button.
     */
    e(this, "disableFp");
    /**
     * @see disableFp
     */
    e(this, "disable");
    /**
     * Enables the button.
     */
    e(this, "disableShineEffectFp");
    /**
     * @see disableShineEffectFp
     */
    e(this, "disableShineEffect");
    /**
     * Updates the button background color.
     */
    e(this, "setBgColorFp");
    /**
     * @see setBgColorFp
     */
    e(this, "setBgColor");
    /**
     * Updates the button text color.
     */
    e(this, "setTextColorFp");
    /**
     * @see setTextColorFp
     */
    e(this, "setTextColor");
    /**
     * Updates the button text.
     */
    e(this, "setTextFp");
    /**
     * @see setTextFp
     */
    e(this, "setText");
    /**
     * Shows the button loader.
     */
    e(this, "showLoaderFp");
    /**
     * @see showLoaderFp
     */
    e(this, "showLoader");
    /**
     * Hides the button loader.
     */
    e(this, "hideLoaderFp");
    /**
     * @see hideLoaderFp
     */
    e(this, "hideLoader");
    /**
     * Updates the button state.
     * @param state - updates to apply.
     * @example
     * button.setParams({
     *   text: 'Submit',
     *   isEnabled: true,
     *   hasShineEffect: true,
     * });
     */
    e(this, "setParamsFp");
    e(this, "setParams");
    /**
     * Mounts the component restoring its state.
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    /**
     * Adds a new button listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @returns A function to remove bound listener.
     * @example
     * const off = button.onClick(() => {
     *   console.log('User clicked the button');
     *   off();
     * });
     */
    e(this, "onClickFp");
    /**
     * @see onClickFp
     */
    e(this, "onClick");
    /**
     * Removes the button click listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @example
     * function listener() {
     *   console.log('User clicked the button');
     *   button.offClick(listener);
     * }
     * button.onClick(listener);
     */
    e(this, "offClickFp");
    /**
     * @see offClickFp
     */
    e(this, "offClick");
    const n = new ke({
      ...r,
      version: "100",
      initialState: {
        hasShineEffect: !1,
        isEnabled: !0,
        isLoaderVisible: !1,
        isVisible: !1,
        text: "Continue"
      },
      method: "web_app_setup_main_button",
      payload: (o) => ({
        has_shine_effect: o.hasShineEffect,
        is_visible: o.isVisible,
        is_active: o.isEnabled,
        is_progress_visible: o.isLoaderVisible,
        text: o.text,
        color: o.bgColor,
        text_color: o.textColor
      })
    }), i = (o, u) => {
      const a = n.stateGetter(o);
      return F(() => a() || U(u));
    };
    this.bgColor = i("bgColor", t.bgColor), this.textColor = i("textColor", t.textColor), this.hasShineEffect = n.stateGetter("hasShineEffect"), this.isEnabled = n.stateGetter("isEnabled"), this.isLoaderVisible = n.stateGetter("isLoaderVisible"), this.text = n.stateGetter("text"), this.isVisible = n.stateGetter("isVisible"), this.isMounted = n.isMounted, this.state = n.state, [this.setBgColor, this.setBgColorFp] = n.stateSetters("bgColor"), [this.setTextColor, this.setTextColorFp] = n.stateSetters("textColor"), [
      [this.disableShineEffect, this.disableShineEffectFp],
      [this.enableShineEffect, this.enableShineEffectFp]
    ] = n.stateBoolSetters("hasShineEffect"), [
      [this.disable, this.disableFp],
      [this.enable, this.enableFp]
    ] = n.stateBoolSetters("isEnabled"), [
      [this.hideLoader, this.hideLoaderFp],
      [this.showLoader, this.showLoaderFp]
    ] = n.stateBoolSetters("isLoaderVisible"), [this.setText, this.setTextFp] = n.stateSetters("text"), [[this.hide, this.hideFp], [this.show, this.showFp]] = n.stateBoolSetters("isVisible"), this.setParams = n.setState, this.setParamsFp = n.setStateFp, this.onClick = n.onClick, this.onClickFp = n.onClickFp, this.offClick = n.offClick, this.offClickFp = n.offClickFp, this.mount = n.mount, this.mountFp = n.mountFp, this.unmount = n.unmount;
  }
  //#endregion
}
function et(s, t) {
  document.documentElement.style.setProperty(s, t);
}
function tt(s) {
  document.documentElement.style.removeProperty(s);
}
function Pr(s) {
  return c(
    zt(s),
    D((t) => Math.sqrt(
      [0.299, 0.587, 0.114].reduce((r, n, i) => {
        const o = parseInt(t.slice(1 + i * 2, 1 + (i + 1) * 2), 16);
        return r + o * o * n;
      }, 0)
    ) < 120)
  );
}
const qt = ye(Pr);
class Or {
  constructor({
    initialState: t,
    onChange: r,
    offChange: n,
    isTma: i,
    storage: o,
    isPageReload: u
  }) {
    //#region Colors.
    /**
     * @since v6.10
     */
    e(this, "accentTextColor");
    e(this, "bgColor");
    e(this, "buttonColor");
    e(this, "buttonTextColor");
    /**
     * @since v7.10
     */
    e(this, "bottomBarBgColor");
    e(this, "destructiveTextColor");
    /**
     * @since v6.10
     */
    e(this, "headerBgColor");
    e(this, "hintColor");
    e(this, "linkColor");
    e(this, "secondaryBgColor");
    /**
     * @since v6.10
     */
    e(this, "sectionBgColor");
    /**
     * @since v6.10
     */
    e(this, "sectionHeaderTextColor");
    /**
     * @since v7.6
     */
    e(this, "sectionSeparatorColor");
    /**
     * @since v6.10
     */
    e(this, "subtitleTextColor");
    e(this, "textColor");
    //#endregion
    //#region CSS variables.
    e(this, "_isCssVarsBound", j(!1));
    /**
     * True if CSS variables are currently bound.
     */
    e(this, "isCssVarsBound", F(this._isCssVarsBound));
    /**
     * Creates CSS variables connected with the current theme parameters.
     *
     * By default, created CSS variables names are following the pattern "--tg-theme-{name}", where
     * {name} is a theme parameters key name converted from snake case to kebab case.
     *
     * Default variables:
     * - `--tg-theme-bg-color`
     * - `--tg-theme-secondary-text-color`
     *
     * Variables are being automatically updated if theme parameters were changed.
     *
     * @param getCSSVarName - function, returning complete CSS variable name for the specified
     * theme parameters key.
     * @returns Function to stop updating variables.
     * @throws {CSSVarsBoundError} CSS variables are already bound
     * @example Using custom CSS vars generator
     * themeParams.bindCssVars(key => `--my-prefix-${key}`);
     */
    e(this, "bindCssVarsFp");
    /**
     * @see bindCssVarsFp
     */
    e(this, "bindCssVars");
    //#endregion
    //#region Other public signals.
    /**
     * Complete component state.
     */
    e(this, "state");
    /**
     * @returns True if the current color scheme is recognized as dark.
     * This value is calculated based on the current theme's background color.
     */
    e(this, "isDark", F(() => {
      const t = this.bgColor();
      return !t || qt(t);
    }));
    //#endregion
    //#region Mounting.
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * Mounts the component restoring its state.
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    const a = new ee({
      initialState: {},
      onChange: o.set
    }), l = (g) => {
      a.setState(g.theme_params);
    }, p = new fe({
      initialState: () => x(U(t)),
      isPageReload: u,
      onMounted(g) {
        a.setState(g), r(l);
      },
      onUnmounted() {
        n(l);
      },
      restoreState: o.get
    }), m = { isTma: i, returns: "either" }, d = I(m), w = I({
      ...m,
      isMounted: p.isMounted
    });
    this.accentTextColor = a.getter("accent_text_color"), this.bgColor = a.getter("bg_color"), this.buttonColor = a.getter("button_color"), this.buttonTextColor = a.getter("button_text_color"), this.bottomBarBgColor = a.getter("bottom_bar_bg_color"), this.destructiveTextColor = a.getter("destructive_text_color"), this.headerBgColor = a.getter("header_bg_color"), this.hintColor = a.getter("hint_color"), this.linkColor = a.getter("link_color"), this.secondaryBgColor = a.getter("secondary_bg_color"), this.sectionBgColor = a.getter("section_bg_color"), this.sectionHeaderTextColor = a.getter("section_header_text_color"), this.sectionSeparatorColor = a.getter("section_separator_color"), this.subtitleTextColor = a.getter("subtitle_text_color"), this.textColor = a.getter("text_color"), this.state = a.state, this.isMounted = p.isMounted, this.bindCssVarsFp = w((g) => {
      if (this._isCssVarsBound())
        return T(new Qe());
      g || (g = (_) => `--tg-theme-${Nt(_)}`);
      const S = (_) => {
        Object.entries(a.state()).forEach(([b, f]) => {
          f && _(b, f);
        });
      }, v = () => {
        S((_, b) => {
          et(g(_), b);
        });
      };
      return v(), a.state.sub(v), this._isCssVarsBound.set(!0), x(() => {
        S(tt), a.state.unsub(v), this._isCssVarsBound.set(!1);
      });
    }), this.mountFp = d(p.mount), this.unmount = p.unmount, this.bindCssVars = h(this.bindCssVarsFp), this.mount = h(this.mountFp);
  }
  //#endregion
}
const Ve = /* @__PURE__ */ me({}), ve = new Or({
  ...c(
    C(),
    te("themeParams")
  ),
  offChange(s) {
    le("theme_changed", s);
  },
  onChange(s) {
    Z("theme_changed", s);
  },
  initialState: Ve
});
function Bt(s, t, r) {
  return c(
    Je(s, t),
    (n) => ({ ...n, defaults: r })
  );
}
const Qn = new Lr(
  Bt("mainButton", "main_button_pressed", {
    bgColor: F(() => ve.buttonColor() || "#2481cc"),
    textColor: F(() => ve.buttonTextColor() || "#ffffff")
  })
);
class Dr {
  constructor({
    storage: t,
    isPageReload: r,
    version: n,
    postEvent: i,
    isTma: o,
    theme: u,
    onVisibilityChanged: a,
    offVisibilityChanged: l
  }) {
    //#region Other properties.
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * True if the current Mini App background color is recognized as dark.
     */
    e(this, "isDark", F(() => {
      const t = this.bgColorRgb();
      return t ? qt(t) : !1;
    }));
    /**
     * Signal indicating if the mini app is currently active.
     */
    e(this, "isActive");
    /**
     * Complete component state.
     */
    e(this, "state");
    //#endregion
    //#region CSS variables.
    /**
     * True if the CSS variables are currently bound.
     */
    e(this, "isCssVarsBound");
    /**
     * Creates CSS variables connected with the mini app.
     *
     * Default variables:
     * - `--tg-bg-color`
     * - `--tg-header-color`
     * - `--tg-bottom-bar-color`
     *
     * Variables are being automatically updated if theme parameters were changed.
     *
     * @param getCSSVarName - function, returning complete CSS variable name for the specified
     * mini app key.
     * @returns Function to stop updating variables.
     * @example Using no arguments
     * miniApp.bindCssVars();
     * @example Using custom CSS vars generator
     * miniApp.bindCssVars(key => `--my-prefix-${key}`);
     */
    e(this, "bindCssVarsFp");
    e(this, "bindCssVars");
    //#endregion
    //#region Mounting.
    /**
     * Signal indicating if the component is mounted.
     */
    e(this, "isMounted");
    /**
     * Mounts the component.
     *
     * This function restores the component state and is automatically saving it in the local storage
     * if it changed.
     * @since Mini Apps v6.1
     */
    e(this, "mountFp");
    /**
     * @see mount
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    //#endregion
    //#region Background color.
    /**
     * The Mini App background color.
     *
     * Represents an RGB color, or theme parameters key, like "bg_color", "secondary_bg_color", etc.
     *
     * Note that using a theme parameters key, background color becomes bound to the current
     * theme parameters, making it automatically being updated whenever theme parameters change.
     * In order to remove this bind, use an explicit RGB color.
     */
    e(this, "bgColor");
    /**
     * RGB representation of the background color.
     *
     * This value requires the Theme Params component to be mounted to extract a valid RGB value
     * of the color key.
     */
    e(this, "bgColorRgb");
    /**
     * Updates the mini app background color.
     * @since Mini Apps v6.1
     */
    e(this, "setBgColorFp");
    /**
     * @see setBgColorFp
     */
    e(this, "setBgColor");
    //#endregion
    //#region Header color.
    /**
     * The Mini App header color.
     */
    e(this, "headerColor");
    /**
     * RGB representation of the header color.
     *
     * This value requires the Theme Params component to be mounted to extract a valid RGB value
     * of the color key.
     */
    e(this, "headerColorRgb");
    /**
     * Updates the mini app header color.
     * @since Mini Apps v6.1
     */
    e(this, "setHeaderColorFp");
    /**
     * @see setHeaderColorFp
     */
    e(this, "setHeaderColor");
    //#endregion
    //#region Bottom bar background color.
    /**
     * The Mini App bottom bar background color.
     */
    e(this, "bottomBarColor");
    /**
     * RGB representation of the bottom bar background color.
     *
     * This value requires the Theme Params component to be mounted to extract a valid RGB value
     * of the color key.
     */
    e(this, "bottomBarColorRgb");
    /**
     * Updates the mini app bottom bar bg color.
     * @since Mini Apps v7.10
     */
    e(this, "setBottomBarColorFp");
    /**
     * @see setBottomBarColorFp
     */
    e(this, "setBottomBarColor");
    //#endregion
    //#region Other methods.
    /**
     * Closes the Mini App.
     * @param returnBack - should the client return to the previous activity.
     */
    e(this, "closeFp");
    /**
     * @see closeFp
     */
    e(this, "close");
    /**
     * Informs the Telegram app that the Mini App is ready to be displayed.
     *
     * It is recommended to call this method as early as possible, as soon as all
     * essential interface elements loaded.
     *
     * Once this method is called, the loading placeholder is hidden and the Mini
     * App shown.
     *
     * If the method is not called, the placeholder will be hidden only when the
     * page was fully loaded.
     */
    e(this, "readyFp");
    /**
     * @see readyFp
     */
    e(this, "ready");
    const p = (f) => {
      w.setState({ isActive: f.is_visible });
    }, m = (f) => {
      [
        [this.headerColor, "web_app_set_header_color"],
        [this.bgColor, "web_app_set_background_color"],
        [this.bottomBarColor, "web_app_set_bottom_bar_color"]
      ].forEach(([B, L]) => {
        const $ = B();
        if (!Ie($) && (L !== "web_app_set_header_color" || !["bg_color", "secondary_bg_color"].includes($))) {
          const G = f[$];
          G && i(L, { color: G });
        }
      });
    }, d = new fe({
      initialState() {
        return x({
          bgColor: "bg_color",
          headerColor: "header_bg_color",
          bottomBarColor: "bottom_bar_bg_color",
          isActive: !0
        });
      },
      isPageReload: r,
      onMounted: (f) => {
        a(p), u.sub(m), w.setState(f);
      },
      onUnmounted() {
        l(p), u.unsub(m);
      },
      restoreState: t.get
    });
    this.isMounted = d.isMounted, this.mountFp = A(() => {
      const f = () => {
      };
      return c(d.mount(), de(f, f));
    }, { isTma: o, returns: "plain" }), this.mount = h(this.mountFp), this.unmount = d.unmount;
    const w = new ee({
      initialState: {
        bgColor: "bg_color",
        bottomBarColor: "bottom_bar_bg_color",
        headerColor: "bg_color",
        isActive: !1
      },
      onChange: t.set
    });
    this.state = w.state;
    const g = (f) => Ie(f) ? f : U(u)[f], S = (f) => F(() => g(f()));
    this.isActive = w.getter("isActive"), this.isSupported = F(() => [
      "web_app_set_header_color",
      "web_app_set_background_color",
      "web_app_set_bottom_bar_color"
    ].some((f) => oe(f, U(n))));
    const v = j(!1);
    this.isCssVarsBound = F(v), this.bindCssVarsFp = A((f) => {
      if (v())
        return T(new Qe());
      const [B, L] = Re(() => {
        v.set(!1);
      }), $ = (G, O) => {
        const N = () => {
          et(G, O() || null);
        };
        N(), B(O.sub(N), tt.bind(null, G));
      };
      return f || (f = (G) => `--tg-${ht(G)}`), $(f("bgColor"), this.bgColorRgb), $(f("bottomBarColor"), this.bottomBarColorRgb), $(f("headerColor"), this.headerColorRgb), v.set(!0), x(L);
    }, { isTma: o, returns: "either", isMounted: this.isMounted }), this.bindCssVars = h(this.bindCssVarsFp);
    const _ = (f) => {
      const B = w.getter(f), L = S(B), $ = {
        headerColor: "web_app_set_header_color",
        bgColor: "web_app_set_background_color",
        bottomBarColor: "web_app_set_bottom_bar_color"
      }[f], G = A(
        (O) => {
          if (O === B())
            return x(void 0);
          if ($ === "web_app_set_header_color" && (O === "bg_color" || O === "secondary_bg_color"))
            return c(
              i("web_app_set_header_color", { color_key: O }),
              D(() => {
                w.setState({ [f]: O });
              })
            );
          const N = g(O);
          return c(
            N ? i($, { color: N }) : T(new ir(O)),
            D(() => {
              w.setState({ [f]: O });
            })
          );
        },
        {
          isTma: o,
          version: n,
          requires: $,
          isMounted: this.isMounted,
          returns: "either",
          supports: f === "headerColor" ? {
            rgb: {
              method: "web_app_set_header_color",
              param: "color",
              shouldCheck: Ie
            }
          } : void 0
        }
      );
      return [B, L, h(G), G];
    };
    [
      this.bgColor,
      this.bgColorRgb,
      this.setBgColor,
      this.setBgColorFp
    ] = _("bgColor"), [
      this.headerColor,
      this.headerColorRgb,
      this.setHeaderColor,
      this.setHeaderColorFp
    ] = _("headerColor"), [
      this.bottomBarColor,
      this.bottomBarColorRgb,
      this.setBottomBarColor,
      this.setBottomBarColorFp
    ] = _("bottomBarColor");
    const b = I({ isTma: o, returns: "either" });
    this.closeFp = b((f) => i("web_app_close", { return_back: f })), this.close = h(this.closeFp), this.readyFp = b(() => i("web_app_ready")), this.ready = h(this.readyFp);
  }
  //#endregion
}
const Ur = new Dr({
  ...c(
    C(),
    R,
    y,
    te("miniApp")
  ),
  offVisibilityChanged(s) {
    le("visibility_changed", s);
  },
  onVisibilityChanged(s) {
    Z("visibility_changed", s);
  },
  theme: ve.state
});
function Gr(s) {
  const t = s.message.trim(), r = (s.title || "").trim(), n = s.buttons || [];
  if (r.length > 64)
    return T(new Q(`Invalid title: ${r}`));
  if (!t || t.length > 256)
    return T(new Q(`Invalid message: ${t}`));
  if (n.length > 3)
    return T(new Q(`Invalid buttons count: ${n.length}`));
  const i = [];
  if (!n.length)
    i.push({ type: "close", id: "" });
  else
    for (let o = 0; o < n.length; o++) {
      const u = n[o], a = u.id || "";
      if (a.length > 64)
        return T(new Q(`Button with index ${o} has invalid id: ${a}`));
      if (!u.type || u.type === "default" || u.type === "destructive") {
        const l = u.text.trim();
        if (!l || l.length > 64)
          return T(new Q(`Button with index ${o} has invalid text: ${l}`));
        i.push({ type: u.type, text: l, id: a });
      } else
        i.push({ type: u.type, id: a });
    }
  return x({ title: r, message: t, buttons: i });
}
class jr {
  constructor({ version: t, isTma: r, request: n }) {
    /**
     * Signal indicating if any popup is currently opened.
     */
    e(this, "isOpened");
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * A method that shows a native popup described by the `params` argument.
     * The promise will be resolved when the popup is closed. Resolved value will have
     * an identifier of the pressed button.
     *
     * If a user clicked outside the popup or clicked the top right popup close
     * button, null will be resolved.
     *
     * @param options - popup parameters.
     * @since Mini Apps v6.2
     * @example
     * pipe(
     *   popup.showFp({
     *     title: 'Confirm action',
     *     message: 'Do you really want to buy this burger?',
     *     buttons: [
     *       { id: 'yes', text: 'Yes' },
     *       { id: 'no', type: 'destructive', text: 'No' },
     *     ],
     *   }),
     *   TE.map(buttonId => {
     *     console.log('User clicked a button with ID', buttonId);
     *   }),
     * );
     */
    e(this, "showFp");
    /**
     * @see showFp
     */
    e(this, "show");
    const i = j(!1), o = () => {
      i.set(!1);
    }, u = I({
      version: t,
      isTma: r,
      requires: "web_app_open_popup",
      returns: "task"
    });
    this.isSupported = z("web_app_open_popup", t), this.isOpened = F(i), this.showFp = u((a) => c(
      this.isOpened() ? V(new ze("A popup is already opened")) : q(void 0),
      ae(() => kt(Gr(a))),
      K((l) => (i.set(!0), n("web_app_open_popup", "popup_closed", {
        ...a,
        params: l
      }))),
      Ke(
        (l) => (o(), l),
        (l) => (o(), l.button_id)
      )
    )), this.show = h(this.showFp);
  }
}
const zn = new jr(c(C(), P, y));
function Hr({ request: s, ...t }) {
  return A((r) => c(
    s("web_app_request_phone", "phone_requested", r),
    k((n) => n.status)
  ), { ...t, requires: "web_app_request_phone", returns: "task" });
}
const Mt = Hr(c(
  C(),
  y,
  P
)), Jn = h(Mt);
function Wr({
  invokeCustomMethod: s,
  requestPhoneAccess: t,
  ...r
}) {
  const n = (u) => c(
    s("getRequestedContact", {}, {
      ...u,
      timeout: (u || {}).timeout || 5e3
    }),
    ae((a) => {
      const l = Be(Y(), a);
      if (!l.success)
        return V(new we(a, l.issues));
      if (!l.output)
        return q(void 0);
      const p = Be(
        Jt(
          at({
            contact: Yt(at({
              user_id: mt(),
              phone_number: Y(),
              first_name: Y(),
              last_name: es(Y())
            })),
            auth_date: dt(
              Y(),
              ft((m) => new Date(Number(m) * 1e3)),
              _t()
            ),
            hash: Y()
          })
        ),
        l.output
      );
      return p.success ? q({ raw: l.output, parsed: p.output }) : V(new we(l.output, p.issues));
    })
  ), i = (u) => c(
    n(u),
    js(
      // All other errors except validation ones should be ignored. Receiving validation error
      // means that we have some data, but we are unable to parse it properly. So, there is no
      // need to make some more requests further, the problem is local.
      (a) => we.is(a) ? T(a) : x(void 0),
      (a) => x(a)
    )
  ), o = (u) => qe(
    async (a, l, p) => {
      let m = 50;
      for (; !p.isRejected; ) {
        const d = await i(p)();
        if (d._tag === "Left")
          return l(d.left);
        if (d.right)
          return a(d.right);
        await new Promise((w) => setTimeout(w, m)), m += 50;
      }
    },
    u
  );
  return A((u) => qe.fn((a) => c(
    // Try to get the requested contact. Probably, we already requested it before.
    i(a),
    K((l) => l ? q(l) : c(
      t(a),
      ae((p) => p === "sent" ? o(a) : V(new It("User denied access")))
    ))
  ), u), { ...r, returns: "task", requires: "web_app_request_phone" });
}
function Kr({ requestContact: s, ...t }) {
  return A(
    s,
    { ...t, returns: "task", requires: "web_app_request_phone" }
  );
}
const Tt = Wr({
  ...c(C(), Xe, y),
  requestPhoneAccess: Mt
}), Yn = h(Tt), Nr = Kr({
  ...c(C(), y),
  requestContact(s) {
    return c(
      Tt(s),
      k((t) => t.parsed)
    );
  }
}), Zn = h(Nr);
function Qr({ request: s, ...t }) {
  return A((r) => c(
    s("web_app_request_write_access", "write_access_requested", r),
    k((n) => n.status)
  ), { ...t, requires: "web_app_request_write_access", returns: "task" });
}
const zr = Qr(c(
  C(),
  y,
  P
)), Xn = h(zr);
class Jr {
  constructor({
    version: t,
    onClosed: r,
    onTextReceived: n,
    isTma: i,
    postEvent: o
  }) {
    /**
     * Signal indicating if the scanner is currently opened.
     */
    e(this, "isOpened");
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Opens the scanner and returns a task which will be completed with the QR content if the
     * passed `capture` function returned true.
     *
     * Task may also be completed with undefined if the scanner was closed.
     * @param options - method options.
     * @returns A promise with QR content presented as string or undefined if the scanner was closed.
     * @since Mini Apps v6.4
     * @example
     * pipe(
     *   qrScanner.captureFp({
     *     capture(scannedQr) {
     *       return scannedQr === 'any expected by me qr';
     *     }
     *   }),
     *   TE.match(
     *     error => {
     *       console.error(error);
     *     },
     *     qr => {
     *       console.log('My QR:'), qr;
     *     }
     *   ),
     * );
     */
    e(this, "captureFp");
    /**
     * @see captureFp
     */
    e(this, "capture");
    /**
     * Closes the scanner.
     * @since Mini Apps v6.4
     */
    e(this, "closeFp");
    /**
     * @see close
     */
    e(this, "close");
    /**
     * Opens the scanner and returns a task which will be completed when the scanner was closed.
     * @param options - method options.
     * @since Mini Apps v6.4
     * @example Without `capture` option
     * if (qrScanner.open.isAvailable()) {
     *   const qr = await qrScanner.open({ text: 'Scan any QR' });
     * }
     * @example
     * pipe(
     *   qrScanner.openFp({
     *     onCaptured(scannedQr) {
     *       if (scannedQr === 'any expected by me qr') {
     *         qrScanner.close();
     *       }
     *     }
     *   }),
     *   TE.match(
     *     error => {
     *       console.error(error);
     *     },
     *     () => {
     *       console.log('The scanner was closed');
     *     }
     *   ),
     * );
     */
    e(this, "openFp");
    /**
     * @see openFp
     */
    e(this, "open");
    const u = { version: t, requires: "web_app_open_scan_qr_popup", isTma: i }, a = I({ ...u, returns: "either" }), l = I({ ...u, returns: "task" }), p = j(!1), m = () => {
      p.set(!1);
    };
    this.isSupported = z("web_app_open_scan_qr_popup", t), this.isOpened = F(p), this.captureFp = l((d) => {
      let w;
      return c(
        this.openFp({
          ...d,
          onCaptured: (g) => {
            d.capture(g) && (w = g, this.close());
          }
        }),
        k(() => w)
      );
    }), this.closeFp = a(() => c(o("web_app_close_scan_qr_popup"), D(m))), this.openFp = l((d) => c(
      p() ? V(new ze("The QR Scanner is already opened")) : async () => o("web_app_open_scan_qr_popup", { text: d.text }),
      ae(() => {
        p.set(!0);
        const [w, g] = Re(), S = (v) => (g(), p.set(!1), v);
        return c(
          qe((v) => {
            w(
              // The scanner was closed externally.
              r(v),
              // The scanner was closed internally.
              p.sub((_) => {
                _ || v();
              }),
              n(d.onCaptured)
            );
          }, d),
          Ke(S, S)
        );
      })
    )), this.open = h(this.openFp), this.capture = h(this.captureFp), this.close = h(this.closeFp);
  }
}
const eo = new Jr({
  ...c(C(), R, y),
  onClosed(s) {
    return Z("scan_qr_popup_closed", s);
  },
  onTextReceived(s) {
    return Z("qr_text_received", (t) => {
      s(t.data);
    });
  }
});
class Yr {
  constructor({ defaults: t, ...r }) {
    //#region Properties.
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * The button position relative to the main one.
     */
    e(this, "position");
    /**
     * The button background color.
     */
    e(this, "bgColor");
    /**
     * True if the button has a shining effect.
     */
    e(this, "hasShineEffect");
    /**
     * True if the button is clickable.
     */
    e(this, "isEnabled");
    /**
     * True if the button loader is visible.
     */
    e(this, "isLoaderVisible");
    /**
     * True if the button is visible.
     */
    e(this, "isVisible");
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * The complete button state.
     */
    e(this, "state");
    /**
     * The button displayed text.
     */
    e(this, "text");
    /**
     * The button text color.
     *
     * Note that this value is computed based on the external defaults. For
     * example, if not explicitly set, this value may be equal to one of theme
     * params colors.
     */
    e(this, "textColor");
    //#endregion
    //#region Methods.
    /**
     * Shows the button.
     * @since Mini Apps v7.10
     */
    e(this, "showFp");
    /**
     * @see showFp
     */
    e(this, "show");
    /**
     * Hides the button.
     * @since Mini Apps v7.10
     */
    e(this, "hideFp");
    /**
     * @see hideFp
     */
    e(this, "hide");
    /**
     * Enables the button.
     * @since Mini Apps v7.10
     */
    e(this, "enableFp");
    /**
     * @see enableFp
     */
    e(this, "enable");
    /**
     * Enables the button.
     * @since Mini Apps v7.10
     */
    e(this, "enableShineEffectFp");
    /**
     * @see enableShineEffectFp
     */
    e(this, "enableShineEffect");
    /**
     * Disables the button.
     * @since Mini Apps v7.10
     */
    e(this, "disableFp");
    /**
     * @see disableFp
     */
    e(this, "disable");
    /**
     * Enables the button.
     * @since Mini Apps v7.10
     */
    e(this, "disableShineEffectFp");
    /**
     * @see disableShineEffectFp
     */
    e(this, "disableShineEffect");
    /**
     * Updates the button background color.
     * @since Mini Apps v7.10
     */
    e(this, "setBgColorFp");
    /**
     * @see setBgColorFp
     */
    e(this, "setBgColor");
    /**
     * Updates the button text color.
     * @since Mini Apps v7.10
     */
    e(this, "setTextColorFp");
    /**
     * @see setTextColorFp
     */
    e(this, "setTextColor");
    /**
     * Updates the button text.
     * @since Mini Apps v7.10
     */
    e(this, "setTextFp");
    /**
     * @see setTextFp
     */
    e(this, "setText");
    /**
     * Updates the button position.
     * @since Mini Apps v7.10
     */
    e(this, "setPositionFp");
    /**
     * @see setPositionFp
     */
    e(this, "setPosition");
    /**
     * Shows the button loader.
     * @since Mini Apps v7.10
     */
    e(this, "showLoaderFp");
    /**
     * @see showLoaderFp
     */
    e(this, "showLoader");
    /**
     * Hides the button loader.
     * @since Mini Apps v7.10
     */
    e(this, "hideLoaderFp");
    /**
     * @see hideLoaderFp
     */
    e(this, "hideLoader");
    /**
     * Updates the button state.
     * @param state - updates to apply.
     * @since Mini Apps v7.10
     * @example
     * button.setParams({
     *   text: 'Submit',
     *   isEnabled: true,
     *   hasShineEffect: true,
     * });
     */
    e(this, "setParamsFp");
    /**
     * @see setParamsFp
     */
    e(this, "setParams");
    /**
     * Mounts the component restoring its state.
     * @since Mini Apps v7.10
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    /**
     * Adds a new button listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @returns A function to remove bound listener.
     * @since Mini Apps v7.10
     * @example
     * const off = button.onClick(() => {
     *   console.log('User clicked the button');
     *   off();
     * });
     */
    e(this, "onClickFp");
    /**
     * @see onClick
     */
    e(this, "onClick");
    /**
     * Removes the button click listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @since Mini Apps v7.10
     * @example
     * function listener() {
     *   console.log('User clicked the button');
     *   button.offClick(listener);
     * }
     * button.onClick(listener);
     */
    e(this, "offClickFp");
    /**
     * @see offClick
     */
    e(this, "offClick");
    const n = new ke({
      ...r,
      initialState: {
        hasShineEffect: !1,
        isEnabled: !0,
        isLoaderVisible: !1,
        isVisible: !1,
        text: "Cancel",
        position: "left"
      },
      method: "web_app_setup_secondary_button",
      payload: (o) => ({
        has_shine_effect: o.hasShineEffect,
        is_visible: o.isVisible,
        is_active: o.isEnabled,
        is_progress_visible: o.isLoaderVisible,
        text: o.text,
        color: o.bgColor,
        text_color: o.textColor,
        position: o.position
      })
    }), i = (o, u) => {
      const a = n.stateGetter(o);
      return F(() => a() || U(u));
    };
    this.isSupported = z("web_app_setup_secondary_button", r.version), this.bgColor = i("bgColor", t.bgColor), this.textColor = i("textColor", t.textColor), this.position = n.stateGetter("position"), this.hasShineEffect = n.stateGetter("hasShineEffect"), this.isEnabled = n.stateGetter("isEnabled"), this.isLoaderVisible = n.stateGetter("isLoaderVisible"), this.text = n.stateGetter("text"), this.isVisible = n.stateGetter("isVisible"), this.isMounted = n.isMounted, this.state = n.state, [this.setPosition, this.setPositionFp] = n.stateSetters("position"), [this.setBgColor, this.setBgColorFp] = n.stateSetters("bgColor"), [this.setTextColor, this.setTextColorFp] = n.stateSetters("textColor"), [
      [this.disableShineEffect, this.disableShineEffectFp],
      [this.enableShineEffect, this.enableShineEffectFp]
    ] = n.stateBoolSetters("hasShineEffect"), [
      [this.disable, this.disableFp],
      [this.enable, this.enableFp]
    ] = n.stateBoolSetters("isEnabled"), [
      [this.hideLoader, this.hideLoaderFp],
      [this.showLoader, this.showLoaderFp]
    ] = n.stateBoolSetters("isLoaderVisible"), [this.setText, this.setTextFp] = n.stateSetters("text"), [[this.hide, this.hideFp], [this.show, this.showFp]] = n.stateBoolSetters("isVisible"), this.setParams = n.setState, this.setParamsFp = n.setStateFp, this.onClick = n.onClick, this.onClickFp = n.onClickFp, this.offClick = n.offClick, this.offClickFp = n.offClickFp, this.mount = n.mount, this.mountFp = n.mountFp, this.unmount = n.unmount;
  }
  //#endregion
}
const to = new Yr(
  Bt("secondaryButton", "secondary_button_pressed", {
    bgColor: F(() => Ur.bottomBarColorRgb() || "#000000"),
    textColor: F(() => ve.buttonColor() || "#2481cc")
  })
);
class Zr {
  constructor({ isTma: t, request: r, version: n, createRequestId: i }) {
    /**
      * Retrieves an item using its key.
      * @since Mini Apps v9.0
      */
    e(this, "getItemFp");
    /**
     * @see getItemFp
     */
    e(this, "getItem");
    /**
     * Restores an item from the storage.
     * @since Mini Apps v9.0
     */
    e(this, "restoreItemFp");
    /**
     * @see restoreItemFp
     */
    e(this, "restoreItem");
    /**
      * Sets a new item in the storage.
      * @since Mini Apps v9.0
      */
    e(this, "setItemFp");
    /**
     * @see setItemFp
     */
    e(this, "setItem");
    /**
      * Removes a key from the storage.
      * @since Mini Apps v9.0
      */
    e(this, "deleteItemFp");
    /**
     * @see deleteItemFp
     */
    e(this, "deleteItem");
    /**
      * Removes all keys from the storage.
      * @since Mini Apps v9.0
      */
    e(this, "clearFp");
    /**
     * @see clearFp
     */
    e(this, "clear");
    const o = I({
      version: n,
      requires: "web_app_secure_storage_get_key",
      isTma: t,
      returns: "task"
    }), u = (a, l, p) => {
      const m = i();
      return c(
        r(a, ["secure_storage_failed", l], {
          params: { ...p, req_id: m },
          capture: (d) => "payload" in d ? d.payload.req_id === m : !0
        }),
        K((d) => d.event === "secure_storage_failed" ? V(new er(d.payload.error || "UNKNOWN_ERROR")) : q(d.payload))
      );
    };
    this.getItemFp = o((a) => c(
      u("web_app_secure_storage_get_key", "secure_storage_key_received", { key: a }),
      k((l) => ({
        value: l.value,
        canRestore: !!l.can_restore
      }))
    )), this.setItemFp = o((a, l) => c(
      u("web_app_secure_storage_save_key", "secure_storage_key_saved", { key: a, value: l }),
      k(() => {
      })
    )), this.deleteItemFp = o((a) => this.setItemFp(a, null)), this.clearFp = o(() => c(
      u("web_app_secure_storage_clear", "secure_storage_cleared", {}),
      k(() => {
      })
    )), this.restoreItemFp = o((a) => c(
      u("web_app_secure_storage_restore_key", "secure_storage_key_restored", { key: a }),
      k((l) => l.value)
    )), this.getItem = h(this.getItemFp), this.setItem = h(this.setItemFp), this.deleteItem = h(this.deleteItemFp), this.clear = h(this.clearFp), this.restoreItem = h(this.restoreItemFp);
  }
}
const so = new Zr(c(
  C(),
  y,
  P,
  At
));
class Xr {
  constructor(t) {
    /**
     * Signal indicating if the component is currently visible.
     */
    e(this, "isVisible");
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Hides the button.
     * @since Mini Apps v6.10
     */
    e(this, "hideFp");
    /**
     * @see hideFp
     */
    e(this, "hide");
    /**
     * Shows the button.
     * @since Mini Apps v6.10
     */
    e(this, "showFp");
    /**
     * @see showFp
     */
    e(this, "show");
    /**
     * Adds a new button listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @returns A function to remove bound listener.
     * @since Mini Apps v6.10
     * @example
     * const off = button.onClick(() => {
     *   console.log('User clicked the button');
     *   off();
     * });
     */
    e(this, "onClickFp");
    /**
     * @see onClickFp
     */
    e(this, "onClick");
    /**
     * Removes the button click listener.
     * @param listener - event listener.
     * @param once - should the listener be called only once.
     * @since Mini Apps v6.10
     * @example
     * function listener() {
     *   console.log('User clicked the button');
     *   button.offClick(listener);
     * }
     * button.onClick(listener);
     */
    e(this, "offClickFp");
    /**
     * @see offClickFp
     */
    e(this, "offClick");
    /**
     * Mounts the component restoring its state.
     * @since Mini Apps v6.10
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     *
     * Note that this function does not remove listeners added via the `onClick`
     * function, so you have to remove them on your own.
     * @see onClick
     */
    e(this, "unmount");
    const r = new ke({
      ...t,
      method: "web_app_setup_settings_button",
      payload: (n) => ({ is_visible: n.isVisible }),
      initialState: { isVisible: !1 }
    });
    this.isVisible = r.stateGetter("isVisible"), this.isMounted = r.isMounted, this.isSupported = r.isSupported, [[this.hide, this.hideFp], [this.show, this.showFp]] = r.stateBoolSetters("isVisible"), this.onClick = r.onClick, this.onClickFp = r.onClickFp, this.offClick = r.offClick, this.offClickFp = r.offClickFp, this.mount = r.mount, this.mountFp = r.mountFp, this.unmount = r.unmount;
  }
}
const ro = new Xr(
  Je("settingsButton", "settings_button_pressed")
);
class en {
  constructor({ postEvent: t, storage: r, isTma: n, isPageReload: i, version: o }) {
    /**
     * Signal indicating if the component is supported.
     */
    e(this, "isSupported");
    /**
     * Signal indicating if vertical swipes are enabled.
     */
    e(this, "isVerticalEnabled");
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * Mounts the component restoring its state.
     * @since Mini Apps v7.7
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    /**
     * Unmounts the component.
     */
    e(this, "unmount");
    /**
     * Disables the closing confirmation dialog.
     * @since Mini Apps v7.7
     */
    e(this, "disableVerticalFp");
    /**
     * @see disableVerticalFp
     */
    e(this, "disableVertical");
    /**
     * Enables the closing confirmation dialog.
     * @since Mini Apps v7.7
     */
    e(this, "enableVerticalFp");
    /**
     * @see enableVerticalFp
     */
    e(this, "enableVertical");
    const u = { isVerticalEnabled: !0 }, a = new ee({
      initialState: u,
      onChange(g) {
        r.set(g);
      }
    }), l = new fe({
      initialState: u,
      isPageReload: i,
      onMounted: a.setState,
      restoreState: r.get
    }), p = { requires: "web_app_setup_swipe_behavior", isTma: n, version: o }, m = I({
      ...p,
      returns: "plain"
    }), d = I({
      ...p,
      isMounted: l.isMounted,
      returns: "either"
    }), w = (g) => {
      const S = { isVerticalEnabled: g };
      return a.hasDiff(S) ? c(
        t("web_app_setup_swipe_behavior", { allow_vertical_swipe: g }),
        D(() => {
          a.setState(S);
        })
      ) : x(void 0);
    };
    this.isSupported = z("web_app_setup_swipe_behavior", o), this.isVerticalEnabled = a.getter("isVerticalEnabled"), this.isMounted = l.isMounted, this.disableVerticalFp = d(() => w(!1)), this.enableVerticalFp = d(() => w(!0)), this.mountFp = m(() => {
      const g = () => {
      };
      return c(l.mount(), de(g, g));
    }), this.unmount = l.unmount, this.disableVertical = h(this.disableVerticalFp), this.enableVertical = h(this.enableVerticalFp), this.mount = h(this.mountFp);
  }
}
const no = new en(c(
  C(),
  R,
  y,
  te("swipeBehavior")
));
async function oo(s) {
  try {
    const { clipboard: r } = navigator;
    if (r)
      return await r.writeText(s);
  } catch {
  }
  const t = document.createElement("textarea");
  t.value = s, t.style.top = "0", t.style.left = "0", t.style.position = "fixed", document.body.appendChild(t), t.focus(), t.select();
  try {
    document.execCommand("copy");
  } finally {
    document.body.removeChild(t);
  }
}
function tn({ request: s, ...t }) {
  return A((r, n, i) => c(
    s(
      "web_app_request_file_download",
      "file_download_requested",
      { ...i, params: { url: r, file_name: n } }
    ),
    K((o) => o.status === "downloading" ? q(void 0) : V(new It("User denied the action")))
  ), { ...t, requires: "web_app_request_file_download", returns: "task" });
}
const sn = tn(c(
  C(),
  P,
  y
)), io = h(sn);
function rn({ invokeCustomMethod: s, ...t }) {
  return A((r) => c(
    s("getCurrentTime", {}, r),
    K((n) => {
      const i = Be(
        dt(mt(), ts(), ft((o) => new Date(o * 1e3)), _t()),
        n
      );
      return i.success ? q(i.output) : V(new we(n, i.issues));
    })
  ), { ...t, requires: "web_app_invoke_custom_method", returns: "task" });
}
const nn = rn(c(
  C(),
  Xe,
  y
)), ao = h(nn);
function on({ postEvent: s, ...t }) {
  return A(() => s("web_app_hide_keyboard"), { ...t, returns: "either", requires: "web_app_hide_keyboard" });
}
const an = on(c(
  C(),
  R,
  y
)), uo = h(an);
function un({ request: s, createRequestId: t, ...r }) {
  return A((n) => {
    const i = t();
    return c(
      s("web_app_read_text_from_clipboard", "clipboard_text_received", {
        ...n,
        params: { req_id: i },
        capture: Ht(i)
      }),
      k(({ data: o = null }) => o)
    );
  }, { ...r, requires: "web_app_read_text_from_clipboard", returns: "task" });
}
const cn = un({
  ...c(
    C(),
    y,
    P
  ),
  createRequestId: Ze
}), co = h(cn);
function pn(s) {
  const t = {}, r = s.match(/Telegram-Android(?:\/([^ ]+))?(?: (\([^)]+\))?|$)/);
  if (r) {
    const [, n, i] = r;
    n && (t.appVersion = n), i && i.slice(1, i.length - 1).split(";").forEach((o) => {
      const [u, a] = o.trim().split(" ");
      if (u === "Android")
        t.androidVersion = a;
      else if (u === "SDK") {
        const l = parseInt(a, 10);
        l && (t.sdkVersion = l);
      } else a ? (t.manufacturer = u, t.model = a) : t.performanceClass = u;
    });
  }
  return t;
}
function po() {
  return pn(navigator.userAgent);
}
function ln({ postEvent: s, ...t }) {
  return A((r) => {
    const { size: n } = new Blob([r]);
    return !n || n > 4096 ? T(
      new Q(n ? "Maximum size of data to send is 4096 bytes" : "Attempted to send empty data")
    ) : s("web_app_data_send", { data: r });
  }, { ...t, returns: "either" });
}
const hn = ln(c(C(), R)), lo = h(hn);
function dn({ request: s, ...t }) {
  return A((r, n) => c(
    s(
      "web_app_send_prepared_message",
      ["prepared_message_failed", "prepared_message_sent"],
      {
        ...n,
        params: { id: r }
      }
    ),
    K((i) => i.event === "prepared_message_failed" ? V(new or(i.payload.error)) : q(void 0))
  ), { ...t, requires: "web_app_send_prepared_message", returns: "task" });
}
const fn = dn(c(
  C(),
  P,
  y
)), ho = h(fn);
function _n({ postEvent: s, ...t }) {
  return A((r, n = {}) => s("web_app_share_to_story", {
    text: n.text,
    media_url: r,
    widget_link: n.widgetLink
  }), { ...t, requires: "web_app_share_to_story", returns: "either" });
}
const mn = _n(c(
  C(),
  R,
  y
)), fo = h(mn), $e = /* @__PURE__ */ me(!1);
function bn({ isInlineMode: s, postEvent: t, ...r }) {
  return A((n, i) => t("web_app_switch_inline_query", {
    query: n,
    chat_types: i || []
  }), {
    ...r,
    requires: {
      every: ["web_app_switch_inline_query", () => U(s) ? void 0 : "The application must be launched in the inline mode"]
    },
    returns: "either"
  });
}
const gn = bn({
  ...c(
    C(),
    R,
    y
  ),
  isInlineMode: $e
}), _o = h(gn);
class Fn {
  constructor({
    storage: t,
    isPageReload: r,
    onContentSafeAreaInsetsChanged: n,
    onSafeAreaInsetsChanged: i,
    onViewportChanged: o,
    onFullscreenChanged: u,
    offContentSafeAreaInsetsChanged: a,
    offFullscreenChanged: l,
    offSafeAreaInsetsChanged: p,
    offViewportChanged: m,
    request: d,
    isViewportStable: w,
    isFullscreen: g,
    isTma: S,
    version: v,
    postEvent: _
  }) {
    //#region Other properties.
    /**
     * Complete component state.
     */
    e(this, "state");
    /**
     * Signal containing the current height of the **visible area** of the Mini App.
     *
     * The application can display just the top part of the Mini App, with its
     * lower part remaining outside the screen area. From this position, the user
     * can "pull" the Mini App to its maximum height, while the bot can do the same
     * by calling `expand` method. As the position of the Mini App changes, the
     * current height value of the visible area will be updated  in real time.
     *
     * Please note that the refresh rate of this value is not sufficient to
     * smoothly follow the lower border of the window. It should not be used to pin
     * interface elements to the bottom of the visible area. It's more appropriate
     * to use the value of the `stableHeight` field for this purpose.
     *
     * @see stableHeight
     */
    e(this, "height");
    /**
     * Signal containing the height of the visible area of the Mini App in its last stable state.
     *
     * The application can display just the top part of the Mini App, with its
     * lower part remaining outside the screen area. From this position, the user
     * can "pull" the Mini App to its maximum height, while the application can do
     * the same by calling `expand` method.
     *
     * Unlike the value of `height`, the value of `stableHeight` does not change as
     * the position of the Mini App changes with user gestures or during
     * animations. The value of `stableHeight` will be updated after all gestures
     * and animations are completed and the Mini App reaches its final size.
     *
     * @see height
     */
    e(this, "stableHeight");
    /**
     * Signal containing the currently visible area width.
     */
    e(this, "width");
    /**
     * Signal indicating if the Mini App is expanded to the maximum available height. Otherwise,
     * if the Mini App occupies part of the screen and can be expanded to the full
     * height using the `expand` method.
     */
    e(this, "isExpanded");
    /**
     * Signal indicating if the current viewport height is stable and is not going to change in
     * the next moment.
     */
    e(this, "isStable", F(() => this.height() === this.stableHeight()));
    //#endregion
    //#region Content safe area insets.
    /**
     * Signal containing content safe area insets.
     */
    e(this, "contentSafeAreaInsets");
    /**
     * Signal containing top content safe area inset.
     */
    e(this, "contentSafeAreaInsetTop");
    /**
     * Signal containing left content safe area inset.
     */
    e(this, "contentSafeAreaInsetLeft");
    /**
     * Signal containing right content safe area inset.
     */
    e(this, "contentSafeAreaInsetRight");
    /**
     * Signal containing bottom content safe area inset.
     */
    e(this, "contentSafeAreaInsetBottom");
    //#endregion
    //#region Safe area insets.
    /**
     * Signal containing safe area insets.
     */
    e(this, "safeAreaInsets");
    /**
     * Signal containing top safe area inset.
     */
    e(this, "safeAreaInsetTop");
    /**
     * Signal containing left safe area inset.
     */
    e(this, "safeAreaInsetLeft");
    /**
     * Signal containing right safe area inset.
     */
    e(this, "safeAreaInsetRight");
    /**
     * Signal containing bottom safe area inset.
     */
    e(this, "safeAreaInsetBottom");
    //#endregion
    //#region Fullscreen.
    /**
     * Signal indicating if the viewport is currently in fullscreen mode.
     */
    e(this, "isFullscreen");
    /**
     * Requests fullscreen mode for the mini application.
     * @since Mini Apps v8.0
     */
    e(this, "requestFullscreenFp");
    /**
     * @see requestFullscreenFp
     */
    e(this, "requestFullscreen");
    /**
     * Exits mini application from the fullscreen mode.
     * @since Mini Apps v8.0
     */
    e(this, "exitFullscreenFp");
    /**
     * @see exitFullscreenFp
     */
    e(this, "exitFullscreen");
    //#endregion
    //#region CSS Vars.
    /**
     * Signal indicating if CSS variables are bound.
     */
    e(this, "isCssVarsBound");
    /**
     * Creates CSS variables connected with the current viewport.
     *
     * By default, created CSS variables names are following the pattern "--tg-theme-{name}", where
     * {name} is a viewport property name converted from camel case to kebab case.
     *
     * Default variables:
     * - `--tg-viewport-height`
     * - `--tg-viewport-width`
     * - `--tg-viewport-stable-height`
     * - `--tg-viewport-content-safe-area-inset-top`
     * - `--tg-viewport-content-safe-area-inset-bottom`
     * - `--tg-viewport-content-safe-area-inset-left`
     * - `--tg-viewport-content-safe-area-inset-right`
     * - `--tg-viewport-safe-area-inset-top`
     * - `--tg-viewport-safe-area-inset-bottom`
     * - `--tg-viewport-safe-area-inset-left`
     * - `--tg-viewport-safe-area-inset-right`
     *
     * Variables are being automatically updated if the viewport was changed.
     *
     * @param getCSSVarName - function, returning computed complete CSS variable name. The CSS
     * variable will only be defined if the function returned non-empty string value.
     * @returns Function to stop updating variables.
     * @example Using no arguments
     * bindCssVarsFp();
     * @example Using custom CSS vars generator
     * bindCssVarsFp(key => `--my-prefix-${key}`);
     */
    e(this, "bindCssVarsFp");
    /**
     * @see bindCssVarsFp
     */
    e(this, "bindCssVars");
    //#endregion
    //#region Mount.
    /**
     * Signal indicating if the component is currently mounted.
     */
    e(this, "isMounted");
    /**
     * Mounts the component.
     */
    e(this, "mountFp");
    /**
     * @see mountFp
     */
    e(this, "mount");
    //#endregion
    //#region Other methods.
    /**
     * A method that expands the Mini App to the maximum available height. To find
     * out if the Mini App is expanded to the maximum height, refer to the value of
     * the `isExpanded`.
     */
    e(this, "expandFp");
    /**
     * @see expandFp
     */
    e(this, "expand");
    const b = { top: 0, right: 0, left: 0, bottom: 0 }, f = new ee({
      initialState: {
        contentSafeAreaInsets: b,
        height: 0,
        isExpanded: !1,
        isFullscreen: !1,
        safeAreaInsets: b,
        stableHeight: 0,
        width: 0
      },
      onChange: t.set
    }), B = (E) => {
      f.setState({
        isExpanded: E.is_expanded,
        height: E.height,
        width: E.width,
        stableHeight: E.is_state_stable ? E.height : void 0
      });
    }, L = (E) => {
      f.setState({ isFullscreen: E.is_fullscreen });
    }, $ = (E) => {
      f.setState({ safeAreaInsets: E });
    }, G = (E) => {
      f.setState({ contentSafeAreaInsets: E });
    }, O = new Ye({
      initialState(E) {
        const se = (J) => () => {
          const [X, H] = J === "safe-area" ? ["web_app_request_safe_area", "safe_area_changed"] : ["web_app_request_content_safe_area", "content_safe_area_changed"];
          return oe(X, U(v)) ? d(X, H, E) : q({ top: 0, left: 0, right: 0, bottom: 0 });
        }, M = (J) => () => typeof J == "boolean" ? q(J) : kt(J());
        return c(
          Ys,
          Fe("safeAreaInsets", se("safe-area")),
          Fe("contentSafeAreaInsets", se("content-safe-area")),
          Fe("isFullscreen", M(g)),
          Fe("isViewportStable", M(w)),
          ae(({ isViewportStable: J, ...X }) => J ? q({
            ...X,
            height: window.innerHeight,
            isExpanded: !0,
            stableHeight: window.innerHeight,
            width: window.innerWidth
          }) : c(
            d("web_app_request_viewport", "viewport_changed", E),
            k((H) => ({
              ...X,
              height: H.height,
              isExpanded: H.is_expanded,
              stableHeight: H.is_state_stable ? H.height : 0,
              width: H.width
            }))
          ))
        );
      },
      isPageReload: r,
      onMounted(E) {
        o(B), u(L), i($), n(G), f.setState(E);
      },
      onUnmounted() {
        m(B), l(L), p($), a(G);
      },
      restoreState: t.get
    }), N = (E) => F(() => this.safeAreaInsets()[E]), be = (E) => F(() => this.contentSafeAreaInsets()[E]);
    this.state = f.state, this.height = f.getter("height"), this.stableHeight = f.getter("stableHeight"), this.width = f.getter("width"), this.isExpanded = f.getter("isExpanded"), this.safeAreaInsets = f.getter("safeAreaInsets"), this.safeAreaInsetTop = N("top"), this.safeAreaInsetBottom = N("bottom"), this.safeAreaInsetLeft = N("left"), this.safeAreaInsetRight = N("right"), this.contentSafeAreaInsets = f.getter("contentSafeAreaInsets"), this.contentSafeAreaInsetTop = be("top"), this.contentSafeAreaInsetBottom = be("bottom"), this.contentSafeAreaInsetLeft = be("left"), this.contentSafeAreaInsetRight = be("right");
    const Vt = I({ isTma: S, returns: "task" }), st = I({
      isTma: S,
      returns: "either"
    }), $t = I({
      isTma: S,
      requires: "web_app_request_fullscreen",
      version: v,
      returns: "task"
    }), rt = (E) => $t((se) => c(
      d(
        E ? "web_app_request_fullscreen" : "web_app_exit_fullscreen",
        ["fullscreen_changed", "fullscreen_failed"],
        se
      ),
      K((M) => M.event === "fullscreen_failed" && M.payload.error !== "ALREADY_FULLSCREEN" ? V(new nr(M.payload.error)) : (f.setState({
        isFullscreen: "is_fullscreen" in M.payload ? M.payload.is_fullscreen : !0
      }), q(void 0)))
    ));
    this.isMounted = O.isMounted, this.mountFp = Vt(O.mount), this.mount = h(this.mountFp), this.isFullscreen = f.getter("isFullscreen"), this.requestFullscreenFp = rt(!0), this.requestFullscreen = h(this.requestFullscreenFp), this.exitFullscreenFp = rt(!1), this.exitFullscreen = h(this.exitFullscreenFp);
    const ge = j(!1);
    this.isCssVarsBound = F(ge), this.bindCssVarsFp = st(
      (E) => {
        if (ge())
          return T(new Qe());
        E || (E = (M) => `--tg-viewport-${ht(M)}`);
        const se = [
          ["height", this.height],
          ["stableHeight", this.stableHeight],
          ["width", this.width],
          ["safeAreaInsetTop", this.safeAreaInsetTop],
          ["safeAreaInsetBottom", this.safeAreaInsetBottom],
          ["safeAreaInsetLeft", this.safeAreaInsetLeft],
          ["safeAreaInsetRight", this.safeAreaInsetRight],
          ["contentSafeAreaInsetTop", this.contentSafeAreaInsetTop],
          ["contentSafeAreaInsetBottom", this.contentSafeAreaInsetBottom],
          ["contentSafeAreaInsetLeft", this.contentSafeAreaInsetLeft],
          ["contentSafeAreaInsetRight", this.contentSafeAreaInsetRight]
        ].reduce((M, [J, X]) => {
          const H = E(J);
          if (H) {
            const nt = () => {
              et(H, `${X()}px`);
            };
            M.push({ update: nt, removeListener: X.sub(nt), cssVar: H });
          }
          return M;
        }, []);
        return se.forEach((M) => {
          M.update();
        }), ge.set(!0), x(() => {
          se.forEach((M) => {
            M.removeListener(), tt(M.cssVar);
          }), ge.set(!1);
        });
      }
    ), this.bindCssVars = h(this.bindCssVarsFp), this.expandFp = st(() => _("web_app_expand")), this.expand = h(this.expandFp);
  }
  //#endregion
}
function wn() {
  const s = (o) => ({
    on: (u) => {
      Z(o, u);
    },
    off: (u) => {
      le(o, u);
    }
  }), t = s("viewport_changed"), r = s("fullscreen_changed"), n = s("safe_area_changed"), i = s("content_safe_area_changed");
  return new Fn({
    ...c(
      C(),
      te("viewport"),
      y,
      R,
      P
    ),
    isFullscreen() {
      return c(Se(), D((o) => !!o.tgWebAppFullscreen));
    },
    isViewportStable() {
      return c(Se(), D((o) => ["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(o.tgWebAppPlatform)));
    },
    offContentSafeAreaInsetsChanged: i.off,
    offFullscreenChanged: r.off,
    offSafeAreaInsetsChanged: n.off,
    offViewportChanged: t.off,
    onContentSafeAreaInsetsChanged: i.on,
    onFullscreenChanged: r.on,
    onSafeAreaInsetsChanged: n.on,
    onViewportChanged: t.on
  });
}
const mo = wn();
function Cn(s = {}) {
  const {
    version: t,
    isInlineMode: r,
    themeParams: n
  } = s;
  if (t && typeof r == "boolean" && n)
    Te.set(t), $e.set(r), Ve.set(n);
  else {
    const a = c(Se(), Ct(
      (l) => l,
      (l) => {
        Te.set(t || l.tgWebAppVersion), $e.set(typeof r == "boolean" ? r : !!l.tgWebAppBotInline), Ve.set(n || l.tgWebAppThemeParams);
      }
    ));
    if (a)
      return T(a);
  }
  s.postEvent && Et.set(s.postEvent);
  const [i, o] = Re(
    Z("reload_iframe", () => {
      ot().log("Received a request to reload the page"), ur("iframe_will_reload"), window.location.reload();
    })
  ), { acceptCustomStyles: u = !0 } = s;
  if (u) {
    const a = document.createElement("style");
    a.id = "telegram-custom-styles", document.head.appendChild(a), i(
      Z("set_custom_style", (l) => {
        a.innerHTML = l;
      }),
      () => {
        document.head.removeChild(a);
      }
    );
  }
  return c(
    ce("iframe_ready", { reload_supported: !0 }),
    D(() => (ot().log("The package was initialized"), o))
  );
}
const bo = ye(Cn);
export {
  It as AccessDeniedError,
  ar as BackButton,
  hr as Biometry,
  Qe as CSSVarsBoundError,
  wo as CancelledError,
  _r as ClosingBehavior,
  mr as CloudStorage,
  ze as ConcurrentCallError,
  gr as DeviceStorage,
  Xs as DeviceStorageMethodError,
  nr as FullscreenFailedError,
  sr as FunctionUnavailableError,
  vr as HapticFeedback,
  Ar as InitData,
  Q as InvalidArgumentsError,
  qn as InvalidEnvError,
  Co as InvalidLaunchParamsError,
  xr as Invoice,
  So as InvokeCustomMethodFailedError,
  vo as LaunchParamsRetrieveError,
  Rr as LocationManager,
  Lr as MainButton,
  yo as MethodParameterUnsupportedError,
  ko as MethodUnsupportedError,
  Dr as MiniApp,
  tr as NotAvailableError,
  jr as Popup,
  Jr as QrScanner,
  Yr as SecondaryButton,
  Zr as SecureStorage,
  er as SecureStorageMethodError,
  rr as SetEmojiStatusError,
  Xr as SettingsButton,
  or as ShareMessageError,
  en as SwipeBehavior,
  Or as ThemeParams,
  Io as TimeoutError,
  Eo as UnknownEnvError,
  ir as UnknownThemeParamsKeyError,
  we as ValidationError,
  Fn as Viewport,
  Dn as addToHomeScreen,
  kr as addToHomeScreenFp,
  Ao as applyPolyfills,
  Bn as backButton,
  Tn as biometry,
  Un as checkHomeScreenStatus,
  Er as checkHomeScreenStatusFp,
  Vn as closingBehavior,
  $n as cloudStorage,
  oo as copyTextToClipboard,
  xo as createLogger,
  qo as createPostEvent,
  Ze as createRequestId,
  Bo as createStartParam,
  Mo as createStartParamFp,
  To as debug,
  Vo as decodeBase64Url,
  $o as decodeBase64UrlFp,
  Ro as decodeStartParam,
  Lo as decodeStartParamFp,
  Po as deepSnakeToCamelObjKeys,
  Rn as deviceStorage,
  io as downloadFile,
  sn as downloadFileFp,
  Oo as emitEvent,
  Do as encodeBase64Url,
  ao as getCurrentTime,
  nn as getCurrentTimeFp,
  Uo as getReleaseVersion,
  On as hapticFeedback,
  uo as hideKeyboard,
  an as hideKeyboardFp,
  bo as init,
  Gn as initData,
  Cn as initFp,
  jn as invoice,
  br as invokeCustomMethod,
  ai as isAnyRGB,
  qt as isColorDark,
  Pr as isColorDarkFp,
  ui as isRGB,
  ci as isRGBA,
  pi as isRGBAShort,
  li as isRGBShort,
  Go as isSafeToCreateStartParam,
  jo as isTMA,
  Ho as isTMAFp,
  Nn as locationManager,
  Wo as logger,
  Qn as mainButton,
  Ur as miniApp,
  Ko as mockTelegramEnv,
  No as off,
  Qo as offAll,
  zo as on,
  Hn as openLink,
  Br as openLinkFp,
  Wn as openTelegramLink,
  xt as openTelegramLinkFp,
  hi as parseInitDataQuery,
  di as parseInitDataQueryFp,
  fi as parseLaunchParamsQuery,
  _i as parseLaunchParamsQueryFp,
  zn as popup,
  ur as postEvent,
  ce as postEventFp,
  eo as qrScanner,
  co as readTextFromClipboard,
  cn as readTextFromClipboardFp,
  Mn as request,
  Zn as requestContact,
  Yn as requestContactComplete,
  Tt as requestContactCompleteFp,
  Nr as requestContactFp,
  Ln as requestEmojiStatusAccess,
  wr as requestEmojiStatusAccessFp,
  dr as requestFp,
  Jn as requestPhoneAccess,
  Mt as requestPhoneAccessFp,
  Xn as requestWriteAccess,
  zr as requestWriteAccessFp,
  po as retrieveAndroidDeviceData,
  pn as retrieveAndroidDeviceDataFrom,
  Jo as retrieveLaunchParams,
  Yo as retrieveLaunchParamsFp,
  Zo as retrieveRawInitData,
  Xo as retrieveRawInitDataFp,
  ei as retrieveRawLaunchParams,
  ti as retrieveRawLaunchParamsFp,
  to as secondaryButton,
  so as secureStorage,
  lo as sendData,
  hn as sendDataFp,
  mi as serializeInitDataQuery,
  bi as serializeLaunchParamsQuery,
  si as setDebug,
  Pn as setEmojiStatus,
  Sr as setEmojiStatusFp,
  ri as setTargetOrigin,
  ro as settingsButton,
  ho as shareMessage,
  fn as shareMessageFp,
  fo as shareStory,
  mn as shareStoryFp,
  Kn as shareURL,
  Vr as shareURLFp,
  ni as supports,
  no as swipeBehavior,
  _o as switchInlineQuery,
  gn as switchInlineQueryFp,
  oi as targetOrigin,
  ve as themeParams,
  gi as toRGB,
  Fi as toRGBFp,
  wi as toRGBFull,
  Ci as toRGBFullFp,
  mo as viewport
};
//# sourceMappingURL=index.js.map

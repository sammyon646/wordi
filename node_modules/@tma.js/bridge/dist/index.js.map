{"version":3,"file":"index.js","sources":["../src/env/hasWebviewProxy.ts","../src/env/isIframe.ts","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/function.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/internal.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Either.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Option.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/EitherT.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Task.js","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/TaskEither.js","../src/errors.ts","../src/launch-params.ts","../src/events/createEmitter.ts","../src/events/emitEvent.ts","../src/globals.ts","../src/obj-prop-helpers.ts","../src/events/emitter.ts","../src/methods/postMessage.ts","../src/methods/postEvent.ts","../src/utils/request2.ts","../src/env/isTMA.ts","../src/env/mockTelegramEnv.ts","../src/methods/captureSameReq.ts","../src/methods/getReleaseVersion.ts","../src/utils/compareVersions.ts","../src/methods/supports.ts","../src/methods/createPostEvent.ts","../src/utils/invokeCustomMethod.ts","../src/utils/request.ts","../src/applyPolyfills.ts","../src/base64-url.ts","../../../node_modules/.pnpm/fp-ts@2.16.11/node_modules/fp-ts/es6/Json.js","../src/start-param.ts"],"sourcesContent":["import { looseObject, function as fn, is } from 'valibot';\n\n/**\n * Returns true in case, passed value contains path `TelegramWebviewProxy.postEvent` property and\n * `postEvent` is a function.\n * @param value - value to check.\n */\nexport function hasWebviewProxy<T>(value: T): value is T & {\n  TelegramWebviewProxy: {\n    postEvent: (...args: unknown[]) => unknown;\n  };\n} {\n  return is(\n    looseObject({ TelegramWebviewProxy: looseObject({ postEvent: fn() }) }),\n    value,\n  );\n}\n","/**\n * @see https://stackoverflow.com/a/326076\n * @returns True, if current environment is iframe.\n */\nexport function isIframe(): boolean {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return true;\n  }\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    try {\n        return e instanceof Error ? e : new Error(String(e));\n    }\n    catch (error) {\n        return new Error();\n    }\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, tapEither as tapEither_ } from './FromEither';\nimport { constNull, constUndefined, dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { not } from './Predicate';\nimport { first, last } from './Semigroup';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = _.some;\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getLeft = function (ma) { return (ma._tag === 'Right' ? none : some(ma.left)); };\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getRight = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (S) { return ({\n    show: function (ma) { return (isNone(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n}); };\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = function (O) { return ({\n    equals: getEq(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : isSome(y) ? -1 : 0); }\n}); };\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function (S) { return ({\n    concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n    empty: none\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isNone(ma) ? none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var orElse = dual(2, function (self, that) { return (isNone(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var altW = orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var alt = orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ flatMap(identity);\nvar defaultSeparated = /*#__PURE__*/ separated(none, none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    return isNone(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return separated(_filter(fa, not(predicate)), _filter(fa, predicate));\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n        };\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onNone, onSome) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : onSome(ma.value);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : ma.value;\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainEitherK = \n/*#__PURE__*/ chainEitherK_(FromEither, Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (a) { return (a == null ? none : some(a)); };\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); });\n    };\n};\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function (f) { return flow(f, fromNullable); };\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function (f) {\n    return function (ma) {\n        return isNone(ma) ? none : fromNullable(f(ma.value));\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toNullable = /*#__PURE__*/ match(constNull, identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toUndefined = /*#__PURE__*/ match(constUndefined, identity);\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isNone(ma) ? false : E.equals(a, ma.value);\n    };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isNone(ma) ? false : predicate(ma.value);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if (isNone(o)) {\n            return none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if (isNone(o_1)) {\n                return none;\n            }\n            out.push(o_1.value);\n        }\n        return some(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var option = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: _alt,\n    extend: _extend,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = /*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = /*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstMonoid = function () { return getMonoid(first()); };\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastMonoid = function () { return getMonoid(last()); };\n","import { ap as ap_ } from './Apply';\nimport * as E from './Either';\nimport { flow, pipe } from './function';\nimport { map as map_ } from './Functor';\nexport function right(F) {\n    return flow(E.right, F.of);\n}\nexport function left(F) {\n    return flow(E.left, F.of);\n}\nexport function rightF(F) {\n    return function (fa) { return F.map(fa, E.right); };\n}\nexport function leftF(F) {\n    return function (fe) { return F.map(fe, E.left); };\n}\nexport function fromNullable(F) {\n    return function (e) { return flow(E.fromNullable(e), F.of); };\n}\nexport function fromNullableK(F) {\n    var fromNullableF = fromNullable(F);\n    return function (e) {\n        var fromNullableFE = fromNullableF(e);\n        return function (f) { return flow(f, fromNullableFE); };\n    };\n}\nexport function chainNullableK(M) {\n    var chainM = chain(M);\n    var fromNullableKM = fromNullableK(M);\n    return function (e) {\n        var fromNullableKMe = fromNullableKM(e);\n        return function (f) { return chainM(fromNullableKMe(f)); };\n    };\n}\nexport function map(F) {\n    return map_(F, E.Functor);\n}\nexport function ap(F) {\n    return ap_(F, E.Apply);\n}\nexport function chain(M) {\n    var flatMapM = flatMap(M);\n    return function (f) { return function (ma) { return flatMapM(ma, f); }; };\n}\n/** @internal */\nexport function flatMap(M) {\n    return function (ma, f) { return M.chain(ma, function (e) { return (E.isLeft(e) ? M.of(e) : f(e.right)); }); };\n}\nexport function alt(M) {\n    return function (second) { return function (first) { return M.chain(first, function (e) { return (E.isLeft(e) ? second() : M.of(e)); }); }; };\n}\nexport function bimap(F) {\n    var mapBothF = mapBoth(F);\n    return function (f, g) { return function (self) { return mapBothF(self, f, g); }; };\n}\n/** @internal */\nexport function mapBoth(F) {\n    return function (self, f, g) { return F.map(self, E.bimap(f, g)); };\n}\nexport function mapLeft(F) {\n    var mapErrorF = mapError(F);\n    return function (f) { return function (self) { return mapErrorF(self, f); }; };\n}\n/** @internal */\nexport function mapError(F) {\n    return function (self, f) { return F.map(self, E.mapLeft(f)); };\n}\nexport function altValidation(M, S) {\n    return function (second) { return function (first) {\n        return M.chain(first, E.match(function (e1) {\n            return M.map(second(), E.mapLeft(function (e2) { return S.concat(e1, e2); }));\n        }, right(M)));\n    }; };\n}\nexport function match(F) {\n    return function (onLeft, onRight) { return function (ma) { return F.map(ma, E.match(onLeft, onRight)); }; };\n}\nexport function matchE(M) {\n    return function (onLeft, onRight) { return function (ma) { return M.chain(ma, E.match(onLeft, onRight)); }; };\n}\nexport function getOrElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, E.match(onLeft, M.of)); }; };\n}\nexport function orElse(M) {\n    return function (onLeft) { return function (ma) { return M.chain(ma, function (e) { return (E.isLeft(e) ? onLeft(e.left) : M.of(e)); }); }; };\n}\nexport function orElseFirst(M) {\n    var tapErrorM = tapError(M);\n    return function (onLeft) { return function (ma) { return tapErrorM(ma, onLeft); }; };\n}\n/** @internal */\nexport function tapError(M) {\n    var orElseM = orElse(M);\n    return function (ma, onLeft) {\n        return pipe(ma, orElseM(function (e) { return M.map(onLeft(e), function (eb) { return (E.isLeft(eb) ? eb : E.left(e)); }); }));\n    };\n}\nexport function orLeft(M) {\n    return function (onLeft) { return function (ma) {\n        return M.chain(ma, E.match(function (e) { return M.map(onLeft(e), E.left); }, function (a) { return M.of(E.right(a)); }));\n    }; };\n}\nexport function swap(F) {\n    return function (ma) { return F.map(ma, E.swap); };\n}\nexport function toUnion(F) {\n    return function (fa) { return F.map(fa, E.toUnion); };\n}\n/** @deprecated  */\n/* istanbul ignore next */\nexport function getEitherM(M) {\n    var _ap = ap(M);\n    var _map = map(M);\n    var _chain = chain(M);\n    var _alt = alt(M);\n    var _bimap = bimap(M);\n    var _mapLeft = mapLeft(M);\n    var _fold = matchE(M);\n    var _getOrElse = getOrElse(M);\n    var _orElse = orElse(M);\n    return {\n        map: function (fa, f) { return pipe(fa, _map(f)); },\n        ap: function (fab, fa) { return pipe(fab, _ap(fa)); },\n        of: right(M),\n        chain: function (ma, f) { return pipe(ma, _chain(f)); },\n        alt: function (fa, that) { return pipe(fa, _alt(that)); },\n        bimap: function (fea, f, g) { return pipe(fea, _bimap(f, g)); },\n        mapLeft: function (fea, f) { return pipe(fea, _mapLeft(f)); },\n        fold: function (fa, onLeft, onRight) { return pipe(fa, _fold(onLeft, onRight)); },\n        getOrElse: function (fa, onLeft) { return pipe(fa, _getOrElse(onLeft)); },\n        orElse: function (fa, f) { return pipe(fa, _orElse(f)); },\n        swap: swap(M),\n        rightM: rightF(M),\n        leftM: leftF(M),\n        left: left(M)\n    };\n}\n","/**\n * ```ts\n * interface Task<A> {\n *   (): Promise<A>\n * }\n * ```\n *\n * `Task<A>` represents an asynchronous computation that yields a value of type `A` and **never fails**.\n * If you want to represent an asynchronous computation that may fail, please see `TaskEither`.\n *\n * @since 2.0.0\n */\nimport { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { dual, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIO = function (ma) { return function () { return Promise.resolve().then(ma); }; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Creates a task that will complete after a time delay\n *\n * @example\n * import { sequenceT } from 'fp-ts/Apply'\n * import * as T from 'fp-ts/Task'\n * import { takeRight } from 'fp-ts/Array'\n *\n * async function test() {\n *   const log: Array<string> = []\n *   const append = (message: string): T.Task<void> =>\n *     T.fromIO(() => {\n *       log.push(message)\n *     })\n *   const fa = append('a')\n *   const fb = T.delay(20)(append('b'))\n *   const fc = T.delay(10)(append('c'))\n *   const fd = append('d')\n *   await sequenceT(T.ApplyPar)(fa, fb, fc, fd)()\n *   assert.deepStrictEqual(takeRight(2)(log), ['c', 'b'])\n * }\n *\n * test()\n *\n * @since 2.0.0\n */\nexport function delay(millis) {\n    return function (ma) { return function () {\n        return new Promise(function (resolve) {\n            setTimeout(function () {\n                Promise.resolve().then(ma).then(resolve);\n            }, millis);\n        });\n    }; };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return function () {\n    return Promise.resolve().then(fa).then(f);\n}; }; };\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) { return function () {\n    return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa)]).then(function (_a) {\n        var f = _a[0], a = _a[1];\n        return f(a);\n    });\n}; }; };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return function () { return Promise.resolve(a); }; };\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return function () {\n        return Promise.resolve()\n            .then(ma)\n            .then(function (a) { return f(a)(); });\n    };\n});\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Task';\n/**\n * Monoid returning the first completed task.\n *\n * Note: uses `Promise.race` internally.\n *\n * @example\n * import * as T from 'fp-ts/Task'\n *\n * async function test() {\n *   const S = T.getRaceMonoid<string>()\n *   const fa = T.delay(20)(T.of('a'))\n *   const fb = T.delay(10)(T.of('b'))\n *   assert.deepStrictEqual(await S.concat(fa, fb)(), 'b')\n * }\n *\n * test()\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getRaceMonoid() {\n    return {\n        concat: function (x, y) { return function () { return Promise.race([Promise.resolve().then(x), Promise.resolve().then(y)]); }; },\n        empty: never\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the value to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the value to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO\n};\n/**\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var fromTask = identity;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIO = _.flatMapIO(_FromIO, _FlatMap);\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as T from 'fp-ts/Task'\n * import * as Console from 'fp-ts/Console'\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effect = pipe(\n *   T.of('fp-ts'),\n *   T.tapIO((value) => Console.log(`Hello, ${value}`)),\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), 'fp-ts')\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOK = \n/*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * A `Task` that never completes.\n *\n * @since 2.0.0\n */\nexport var never = function () { return new Promise(function (_) { return undefined; }); };\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        return function () {\n            return Promise.all(as.map(function (a, i) { return Promise.resolve().then(function () { return f(i, a)(); }); }));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (bs) {\n                    return Promise.resolve()\n                        .then(f(i + 1, a))\n                        .then(function (b) {\n                        bs.push(b);\n                        return bs;\n                    });\n                });\n            }, Promise.resolve()\n                .then(f(0, _.head(as)))\n                .then(_.singleton));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) {\n    return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.task`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var task = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.taskSeq`\n * (where `T` is from `import T from 'fp-ts/Task'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskSeq = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = /*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * Lift a monoid into 'Task', the inner values are concatenated using the provided `Monoid`.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMonoid = /*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { getApplicativeMonoid } from './Applicative';\nimport { ap as ap_, apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { compact as compact_, separate as separate_ } from './Compactable';\nimport * as E from './Either';\nimport * as ET from './EitherT';\nimport { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, tapEither as tapEither_ } from './FromEither';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { fromTaskK as fromTaskK_, tapTask as tapTask_ } from './FromTask';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as T from './Task';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var left = /*#__PURE__*/ ET.left(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var right = /*#__PURE__*/ ET.right(T.Pointed);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightTask = /*#__PURE__*/ ET.rightF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftTask = /*#__PURE__*/ ET.leftF(T.Functor);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var rightIO = /*#__PURE__*/ flow(T.fromIO, rightTask);\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var leftIO = /*#__PURE__*/ flow(T.fromIO, leftTask);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromIO = rightIO;\n/**\n * @category conversions\n * @since 2.7.0\n */\nexport var fromTask = rightTask;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = T.of;\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromIOEither = T.fromIO;\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromTaskOption = function (onNone) {\n    return T.map(E.fromOption(onNone));\n};\n/**\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = \n/*#__PURE__*/ ET.match(T.Functor);\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = match;\n/**\n * The `E` suffix (short for **E**ffect) means that the handlers return an effect (`Task`).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchE = /*#__PURE__*/ ET.matchE(T.Monad);\n/**\n * Alias of [`matchE`](#matche).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = matchE;\n/**\n * Less strict version of [`matchE`](#matche).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchEW = matchE;\n/**\n * Alias of [`matchEW`](#matchew).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchEW;\n/**\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = \n/*#__PURE__*/ ET.getOrElse(T.Monad);\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = getOrElse;\n/**\n * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { left, right } from 'fp-ts/Either'\n * import { tryCatch } from 'fp-ts/TaskEither'\n *\n * tryCatch(() => Promise.resolve(1), String)().then(result => {\n *   assert.deepStrictEqual(result, right(1))\n * })\n * tryCatch(() => Promise.reject('error'), String)().then(result => {\n *   assert.deepStrictEqual(result, left('error'))\n * })\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onRejected) {\n    return function () { return __awaiter(void 0, void 0, void 0, function () {\n        var reason_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, f().then(_.right)];\n                case 1: return [2 /*return*/, _a.sent()];\n                case 2:\n                    reason_1 = _a.sent();\n                    return [2 /*return*/, _.left(onRejected(reason_1))];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\n/**\n * Converts a function returning a `Promise` to one returning a `TaskEither`.\n *\n * @category interop\n * @since 2.5.0\n */\nexport var tryCatchK = function (f, onRejected) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onRejected);\n    };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ ET.toUnion(T.Functor);\n/**\n * @category conversions\n * @since 2.12.0\n */\nexport var fromNullable = /*#__PURE__*/ ET.fromNullable(T.Pointed);\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var fromNullableK = /*#__PURE__*/ ET.fromNullableK(T.Pointed);\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainNullableK = \n/*#__PURE__*/ ET.chainNullableK(T.Monad);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.\n *\n * See also [alt](#alt).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   const errorHandler = TE.orElse((error: string) => TE.right(`recovering from ${error}...`))\n *   assert.deepStrictEqual(await pipe(TE.right('ok'), errorHandler)(), E.right('ok'))\n *   assert.deepStrictEqual(await pipe(TE.left('ko'), errorHandler)(), E.right('recovering from ko...'))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = \n/*#__PURE__*/ ET.orElse(T.Monad);\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = orElse;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @category error handling\n * @since 2.15.0\n */\nexport var tapError = /*#__PURE__*/ dual(2, ET.tapError(T.Monad));\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstIOK = function (onLeft) { return tapError(fromIOK(onLeft)); };\n/**\n * @category error handling\n * @since 2.12.0\n */\nexport var orElseFirstTaskK = function (onLeft) { return tapError(fromTaskK(onLeft)); };\n/**\n * @category error handling\n * @since 2.11.0\n */\nexport var orLeft = \n/*#__PURE__*/ ET.orLeft(T.Monad);\n/**\n * @since 2.0.0\n */\nexport var swap = /*#__PURE__*/ ET.swap(T.Functor);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromTaskOptionK = function (onNone) {\n    var from = fromTaskOption(onNone);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.3\n */\nexport var chainTaskOptionKW = function (onNone) {\n    return function (f) {\n        return function (ma) {\n            return flatMap(ma, fromTaskOptionK(onNone)(f));\n        };\n    };\n};\n/**\n * Use `flatMapTaskOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainTaskOptionK = chainTaskOptionKW;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromIOEitherK = function (f) { return flow(f, fromIOEither); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _apPar = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = /*#__PURE__*/ ET.map(T.Functor);\n/**\n * Returns a `TaskEither` whose failure and success channels have been mapped by the specified pair of functions, `f` and `g`.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n * const g = (n: number) => n * 2\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.right(1), f, g)(), Either.right(2))\n *   assert.deepStrictEqual(await TaskEither.mapBoth(TaskEither.left('err'), f, g)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapBoth = /*#__PURE__*/ dual(3, ET.mapBoth(T.Functor));\n/**\n * Alias of `mapBoth`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var bimap = mapBoth;\n/**\n * Returns a `TaskEither` with its error channel mapped using the specified function.\n *\n * @example\n * import * as TaskEither from 'fp-ts/TaskEither'\n * import * as Either from 'fp-ts/Either'\n *\n * const f = (s: string) => new Error(s)\n *\n * async function test() {\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.right(1), f)(), Either.right(1))\n *   assert.deepStrictEqual(await TaskEither.mapError(TaskEither.left('err'), f)(), Either.left(new Error('err')))\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var mapError = /*#__PURE__*/ dual(2, ET.mapError(T.Functor));\n/**\n * Alias of `mapError`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var mapLeft = mapError;\n/**\n * @since 2.0.0\n */\nexport var ap = \n/*#__PURE__*/ ET.ap(T.ApplyPar);\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = ap;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, ET.flatMap(T.Monad));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `TaskEither` returns `fa` if is a `Right` or the value returned by `that` otherwise.\n *\n * See also [orElse](#orelse).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.right(1),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(1)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.right(2))\n *     )(),\n *     E.right(2)\n *   )\n *   assert.deepStrictEqual(\n *     await pipe(\n *       TE.left('a'),\n *       TE.alt(() => TE.left('b'))\n *     )(),\n *     E.left('b')\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = \n/*#__PURE__*/ ET.alt(T.Monad);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = alt;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = right;\n/**\n * @since 2.7.0\n */\nexport var throwError = left;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'TaskEither';\n/**\n * The default [`ApplicativePar`](#applicativepar) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n * import * as T from 'fp-ts/Task'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * interface User {\n *   readonly id: string\n *   readonly name: string\n * }\n *\n * const remoteDatabase: ReadonlyArray<User> = [\n *   { id: 'id1', name: 'John' },\n *   { id: 'id2', name: 'Mary' },\n *   { id: 'id3', name: 'Joey' }\n * ]\n *\n * const fetchUser = (id: string): TE.TaskEither<string, User> =>\n *   pipe(\n *     remoteDatabase,\n *     RA.findFirst((user) => user.id === id),\n *     TE.fromOption(() => `${id} not found`)\n *   )\n *\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(TE.ApplicativePar)(fetchUser))(),\n *     E.left('id4 not found') // <= first error\n *   )\n *\n *   const Applicative = TE.getApplicativeTaskValidation(\n *     T.ApplyPar,\n *     pipe(string.Semigroup, S.intercalate(', '))\n *   )\n *\n *   assert.deepStrictEqual(\n *     await pipe(['id4', 'id5'], RA.traverse(Applicative)(fetchUser))(),\n *     E.left('id4 not found, id5 not found') // <= all errors\n *   )\n * }\n *\n * test()\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getApplicativeTaskValidation(A, S) {\n    var ap = ap_(A, E.getApplicativeValidation(S));\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: function (fab, fa) { return pipe(fab, ap(fa)); },\n        of: of\n    };\n}\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * See [`getAltValidation`](./Either.ts.html#getaltvalidation).\n *\n * @category error handling\n * @since 2.7.0\n */\nexport function getAltTaskValidation(S) {\n    var alt = ET.altValidation(T.Monad, S);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        alt: function (fa, that) { return pipe(fa, alt(that)); }\n    };\n}\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var C = E.getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: compact_(T.Functor, C),\n        separate: separate_(T.Functor, C, E.Functor)\n    };\n};\n/**\n * @category filtering\n * @since 2.1.0\n */\nexport function getFilterable(M) {\n    var F = E.getFilterable(M);\n    var C = getCompactable(M);\n    var filter = filter_(T.Functor, F);\n    var filterMap = filterMap_(T.Functor, F);\n    var partition = partition_(T.Functor, F);\n    var partitionMap = partitionMap_(T.Functor, F);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: C.compact,\n        separate: C.separate,\n        filter: function (fa, predicate) { return pipe(fa, filter(predicate)); },\n        filterMap: function (fa, f) { return pipe(fa, filterMap(f)); },\n        partition: function (fa, predicate) { return pipe(fa, partition(predicate)); },\n        partitionMap: function (fa, f) { return pipe(fa, partitionMap(f)); }\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `TaskEither` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `TaskEither` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Less strict version of [`apFirst`](#apfirst).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Less strict version of [`apSecond`](#apsecond).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    of: of\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.7.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _apPar,\n    chain: flatMap,\n    of: of,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n *\n * const checkString = (value: string) => pipe(\n *   TE.of(value),\n *   TE.tapEither(() => value.length > 0 ? E.right('ok') : E.left('error'))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await checkString('')(), E.left('error'))\n *   assert.deepStrictEqual(await checkString('fp-ts')(), E.right('fp-ts'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as TE from 'fp-ts/TaskEither'\n * import * as E from 'fp-ts/Either'\n * import * as Console from 'fp-ts/Console'\n *\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effectA = TE.tapIO(\n *   TE.of(1),\n *   (value) => Console.log(`Hello, ${value}`)\n * )\n *\n * // No output to the stdout\n * const effectB = pipe(\n *   TE.left('error'),\n *   TE.tapIO((value) => Console.log(`Hello, ${value}`))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effectA(), E.of(1))\n *   assert.deepStrictEqual(await effectB(), E.left('error'))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as TE from 'fp-ts/TaskEither'\n * import * as T from 'fp-ts/Task'\n * import * as E from 'fp-ts/Either'\n *\n *\n * const effect = TE.tapIO(\n *   TE.of(1),\n *   (value) => T.of(value + 1)\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), E.of(1))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapTask = /*#__PURE__*/ dual(2, tapTask_(FromTask, Chain));\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/** @internal */\nvar _FromIO = {\n    fromIO: FromIO.fromIO\n};\n/** @internal */\nvar _FromTask = {\n    fromTask: fromTask\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapEither = /*#__PURE__*/ _.flatMapEither(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapIO = /*#__PURE__*/ _.flatMapIO(_FromIO, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTask = /*#__PURE__*/ _.flatMapTask(_FromTask, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIOEither = /*#__PURE__*/ dual(2, function (self, f) {\n    return flatMap(self, fromIOEitherK(f));\n});\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTaskOption = /*#__PURE__*/ dual(3, function (self, f, onNone) {\n    return flatMap(self, function (a) { return fromTaskOption(function () { return onNone(a); })(f(a)); });\n});\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainEitherK = flatMapEither;\n/**\n * Alias of `flatMapEither`.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainEitherKW = flatMapEither;\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Alias of `tapEither`.\n *\n * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherKW = tapEither;\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * @category lifting\n * @since 2.4.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromIOK = /*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromTaskK = /*#__PURE__*/ fromTaskK_(FromTask);\n/**\n * Alias of `flatMapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainTaskK = flatMapTask;\n/**\n * Alias of `tapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstTaskK = tapTask;\n/**\n * Alias of `flatMapIOEither`.\n *\n * Less strict version of [`chainIOEitherK`](#chainioeitherk).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category legacy\n * @since 2.6.1\n */\nexport var chainIOEitherKW = flatMapIOEither;\n/**\n * Alias of `flatMapIOEither`.\n *\n * @category legacy\n * @since 2.4.0\n */\nexport var chainIOEitherK = flatMapIOEither;\nexport function taskify(f) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        return function () {\n            return new Promise(function (resolve) {\n                var cbResolver = function (e, r) { return (e != null ? resolve(_.left(e)) : resolve(_.right(r))); };\n                f.apply(null, args.concat(cbResolver));\n            });\n        };\n    };\n}\n/**\n * Make sure that a resource is cleaned up in the event of an exception (\\*). The release action is called regardless of\n * whether the body action throws (\\*) or returns.\n *\n * (\\*) i.e. returns a `Left`\n *\n * @since 2.0.0\n */\nexport var bracket = function (acquire, use, release) { return bracketW(acquire, use, release); };\n/**\n * Less strict version of [`bracket`](#bracket).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var bracketW = function (acquire, use, release) {\n    return flatMap(acquire, function (a) { return T.flatMap(use(a), function (e) { return flatMap(release(a, e), function () { return T.of(e); }); }); });\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return flow(T.traverseReadonlyNonEmptyArrayWithIndex(f), T.map(E.traverseReadonlyNonEmptyArrayWithIndex(SK)));\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (ebs) {\n                    return _.isLeft(ebs)\n                        ? acc\n                        : f(i + 1, a)().then(function (eb) {\n                            if (_.isLeft(eb)) {\n                                return eb;\n                            }\n                            ebs.right.push(eb.right);\n                            return ebs;\n                        });\n                });\n            }, f(0, _.head(as))().then(E.map(_.singleton)));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseSeqArray = function (f) { return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirst = tapError;\n/**\n * Alias of `tapError`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var orElseFirstW = tapError;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEither`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEither = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apPar,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `TE.Functor` instead of `TE.taskEitherSeq`\n * (where `TE` is from `import TE from 'fp-ts/TaskEither'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var taskEitherSeq = {\n    URI: URI,\n    bimap: mapBoth,\n    mapLeft: mapError,\n    map: _map,\n    of: of,\n    ap: _apSeq,\n    chain: flatMap,\n    alt: _alt,\n    fromIO: fromIO,\n    fromTask: fromTask,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(ApplySeq);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(ApplicativeSeq);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getSemigroup = function (S) {\n    return getApplySemigroup_(T.ApplySeq)(E.getSemigroup(S));\n};\n/**\n * Use [`getApplicativeTaskValidation`](#getapplicativetaskvalidation) and [`getAltTaskValidation`](#getalttaskvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getTaskValidation(SE) {\n    var applicativeTaskValidation = getApplicativeTaskValidation(T.ApplicativePar, SE);\n    var altTaskValidation = getAltTaskValidation(SE);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        ap: applicativeTaskValidation.ap,\n        of: of,\n        chain: flatMap,\n        bimap: mapBoth,\n        mapLeft: mapError,\n        alt: altTaskValidation.alt,\n        fromIO: fromIO,\n        fromTask: fromTask,\n        throwError: throwError\n    };\n}\n","import type { Version } from '@tma.js/types';\nimport { errorClass, errorClassWithData } from 'error-kid';\n\nexport class MethodUnsupportedError extends errorClass<\n  [method: string, version: Version]\n>('MethodUnsupportedError', (method, version) => [\n  `Method \"${method}\" is unsupported in Mini Apps version ${version}`,\n]) {\n}\n\nexport class MethodParameterUnsupportedError extends errorClass<\n  [method: string, param: string, version: Version]\n>('MethodParameterUnsupportedError', (method, param, version) => [\n  `Parameter \"${param}\" of \"${method}\" method is unsupported in Mini Apps version ${version}`,\n]) {\n}\n\nexport class LaunchParamsRetrieveError extends errorClassWithData<\n  { errors: { source: string; error: unknown }[] },\n  [{ source: string; error: unknown }[]]\n>(\n  'LaunchParamsRetrieveError',\n  errors => ({ errors }),\n  errors => [\n    [\n      'Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?',\n      ' Refer to docs for more information:',\n      'https://docs.telegram-mini-apps.com/packages/tma-js-bridge/environment',\n      '',\n      'Collected errors:',\n      ...errors.map(({ source, error }) => {\n        return `Source: ${source} / ${error instanceof Error ? error.message : String(error)}`;\n      }),\n    ].join('\\n'),\n  ],\n) {\n}\n\nexport class InvalidLaunchParamsError extends errorClass<\n  [launchParams: string, cause: unknown]\n>('InvalidLaunchParamsError', (launchParams, cause) => [\n  `Invalid value for launch params: ${launchParams}`,\n  { cause },\n]) {\n}\n\nexport class UnknownEnvError extends errorClass('UnknownEnvError') {\n}\n\nexport class InvokeCustomMethodFailedError extends errorClass<[error: string]>(\n  'InvokeCustomMethodError',\n  error => [`Server returned error: ${error}`],\n) {\n}\n","import { throwifyFpFn, getStorageValue, setStorageValue } from '@tma.js/toolkit';\nimport {\n  parseLaunchParamsQueryFp,\n  type LaunchParamsGenType,\n  type ParseLaunchParamsQueryError,\n} from '@tma.js/transformers';\nimport * as E from 'fp-ts/Either';\nimport * as O from 'fp-ts/Option';\nimport { flow, pipe } from 'fp-ts/function';\n\nimport { LaunchParamsRetrieveError } from '@/errors.js';\n\nconst SESSION_STORAGE_KEY = 'launchParams';\n\nexport type RetrieveRawInitDataError = RetrieveRawLaunchParamsError;\nexport type RetrieveRawLaunchParamsError = LaunchParamsRetrieveError;\nexport type RetrieveLaunchParamsError = RetrieveRawLaunchParamsError | ParseLaunchParamsQueryError;\nexport type RetrieveLaunchParamsResult = LaunchParamsGenType;\n\n/**\n * @param urlString - URL to extract launch parameters from.\n * @returns Launch parameters from the specified URL.\n * @throws Error if function was unable to extract launch parameters from the\n *   passed URL.\n */\nfunction retrieveLpFromUrl(urlString: string): string {\n  return urlString\n    // Replace everything before this first hashtag or question sign.\n    .replace(/^[^?#]*[?#]/, '')\n    // Replace all hashtags and question signs to make it look like some search\n    // params.\n    .replace(/[?#]/g, '&');\n}\n\n/**\n * @returns Launch parameters from any known source.\n */\nexport const retrieveLaunchParamsFp: () => E.Either<\n  RetrieveLaunchParamsError,\n  RetrieveLaunchParamsResult\n> = flow(retrieveRawLaunchParamsFp, E.chainW(parseLaunchParamsQueryFp));\n\n/**\n * @see retrieveLaunchParamsFp\n */\nexport const retrieveLaunchParams: () => RetrieveLaunchParamsResult =\n  throwifyFpFn(retrieveLaunchParamsFp);\n\n/**\n * @returns Raw init data from any known source.\n */\nexport const retrieveRawInitDataFp: () => E.Either<RetrieveRawInitDataError, O.Option<string>> =\n  flow(retrieveRawLaunchParamsFp, E.map(raw => {\n    const v = new URLSearchParams(raw).get('tgWebAppData');\n    return v ? O.some(v) : O.none;\n  }));\n\n/**\n * @see retrieveRawInitDataFp\n */\nexport const retrieveRawInitData: () => string | undefined = flow(\n  retrieveRawInitDataFp,\n  E.fold(err => {\n    throw err;\n  }, v => v),\n  O.match(() => undefined, v => v),\n);\n\n/**\n * @returns Launch parameters in a raw format from any known source.\n */\nexport function retrieveRawLaunchParamsFp(): E.Either<RetrieveRawLaunchParamsError, string> {\n  const errors: { source: string; error: unknown }[] = [];\n\n  for (const [retrieve, source] of [\n    // Try to retrieve launch parameters from the current location. This method\n    // can return nothing in case, location was changed, and then the page was\n    // reloaded.\n    [() => retrieveLpFromUrl(window.location.href), 'window.location.href'],\n    // Then, try using the lower level API - window.performance.\n    [() => {\n      const navigationEntry = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined;\n      return navigationEntry && retrieveLpFromUrl(navigationEntry.name);\n    }, 'performance navigation entries'],\n    // Finally, try using the session storage.\n    [() => getStorageValue<string>(SESSION_STORAGE_KEY), 'local storage'],\n  ] as const) {\n    const v = retrieve();\n    if (!v) {\n      errors.push({ source, error: new Error('Source is empty') });\n      continue;\n    }\n    const maybeError = pipe(\n      parseLaunchParamsQueryFp(v),\n      E.foldW(err => err, () => true as const),\n    );\n    if (typeof maybeError !== 'boolean') {\n      errors.push({ source, error: maybeError });\n      continue;\n    }\n    setStorageValue(SESSION_STORAGE_KEY, v);\n    return E.right(v);\n  }\n  return E.left(new LaunchParamsRetrieveError(errors));\n}\n\n/**\n * @see retrieveRawLaunchParamsFp\n */\nexport const retrieveRawLaunchParams = throwifyFpFn(retrieveRawLaunchParamsFp);\n","import type { If, IsNever, IsUndefined, Or } from '@tma.js/toolkit';\nimport mitt, {\n  type Emitter,\n  type EventHandlerMap,\n  type EventType,\n  type Handler,\n} from 'mitt';\n\nexport type WildcardHandler<E> = Handler<{\n  [K in keyof E]: {\n    name: K;\n    payload: If<Or<IsNever<E[K]>, IsUndefined<E[K]>>, never, E[K]>;\n  };\n}[keyof E]>;\n\nexport interface OnFn<E> {\n  /**\n   * Adds a new listener for the specified event.\n   * @param type - event name.\n   * @param handler - event listener.\n   * @param once - should this listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  <K extends keyof E>(type: K, handler: Handler<E[K]>, once?: boolean): VoidFunction;\n  /**\n   * Adds a listener to the wildcard event.\n   * @param type - event name.\n   * @param handler - event listener.\n   * @param once - should this listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  (type: '*', handler: WildcardHandler<E>, once?: boolean): VoidFunction;\n}\n\nexport interface OffFn<E> {\n  /**\n   * Removes a listener from the specified event.\n   * @param type - event to listen.\n   * @param handler - event listener to remove.\n   * @param once - had this listener to be called only once.\n   */\n  <K extends keyof E>(type: K, handler: Handler<E[K]>, once?: boolean): void;\n  /**\n   * Removes a listener from the wildcard event.\n   * @param type - event to stop listening.\n   * @param handler - event listener to remove.\n   * @param once - should this listener be called only once.\n   */\n  (type: '*', handler: WildcardHandler<E>, once?: boolean): void;\n}\n\nexport interface EmitFn<E> {\n  <K extends keyof E>(type: K, event: E[K]): void;\n  <K extends keyof E>(type: undefined extends E[K] ? K : never): void;\n}\n\n/**\n * Creates a new enhanced event emitter.\n * @param onFirst - a function to call every time when the events map appeared to be empty during\n * the event listener creation.\n * @param onEmpty - a function to call every tume when the events map became empty.\n */\nexport function createEmitter<E extends object>(\n  onFirst: VoidFunction,\n  onEmpty: VoidFunction,\n): {\n  on: OnFn<E>;\n  off: OffFn<E>;\n  emit: EmitFn<E>;\n  clear: VoidFunction;\n} {\n  // To understand the event handlers concept here, let's tell the underlying idea.\n  //\n  // We use a Map, where key is an event name, and the value is a Map we call HandlersMap.\n  //\n  // The HandlersMap is a Map, where the key is an event handler, added by the developer.\n  // The corresponding value is a list of tuples, with an internally generated function and a\n  // boolean value responsible for determining if the handler must be called only once. So, you\n  // can imagine the following map as:\n  //\n  // HandlersMap {\n  //   { developer_handler }: Array<[ internally_created_handler, once ]>;\n  // }\n  //\n  // The value for the key represents an array of tuples, as long as a single handler may be added\n  // many times, and for each addition we add a new tuple entry.\n  //\n  // The handler may also be added to be called only once. Trying to remove such kind of handler\n  // using a different value of the \"once\" argument will lead to nothing. The developer must\n  // specify the same argument value to avoid confusions.\n  //\n  // Here is the final EventToHandlersMap definition:\n  //\n  // EventToHandlersMap {\n  //   { event_name }: HandlersMap {\n  //     { developer_handler }: Array<[ internally_created_handler, once ]>;\n  //   }\n  // }\n  type HandlersMap = Map<\n    (...args: any) => void,\n    [handler: (...args: any) => void, once: boolean][]\n  >;\n\n  const eventToHandlersMap = new Map<keyof E | '*', HandlersMap>();\n\n  const emitter = (mitt as any as {\n    <E extends Record<EventType, unknown>>(all?: EventHandlerMap<E>): Emitter<E>;\n  })<E & Record<string | symbol, unknown>>();\n\n  const off: OffFn<E> = (\n    event: keyof E | '*',\n    handler: (...args: any) => void,\n    once = false,\n  ) => {\n    const handlersMap: HandlersMap = eventToHandlersMap.get(event) || new Map();\n    eventToHandlersMap.set(event, handlersMap);\n\n    const handlers = handlersMap.get(handler) || [];\n    handlersMap.set(handler, handlers);\n\n    const index = handlers.findIndex(item => item[1] === once);\n    if (index >= 0) {\n      // Remove the related handler.\n      emitter.off(event, handlers[index][0]);\n\n      // Remove the handler from the cache array.\n      handlers.splice(index, 1);\n\n      // If after removal, there are no handlers left, we should remove the entry from the cache.\n      if (!handlers.length) {\n        handlersMap.delete(handler);\n        if (!handlersMap.size) {\n          const prevSize = eventToHandlersMap.size;\n          eventToHandlersMap.delete(event);\n          prevSize && !eventToHandlersMap.size && onEmpty();\n        }\n      }\n    }\n  };\n\n  return {\n    on(event: keyof E | '*', handler: (...args: any[]) => any, once?: boolean) {\n      // The events' map became non-empty. Call the onFirst callback.\n      !eventToHandlersMap.size && onFirst();\n\n      const cleanup = () => {\n        off(event as any, handler, once);\n      };\n\n      const internalHandler = (...args: any[]) => {\n        once && cleanup();\n        if (event === '*') {\n          handler({ name: args[0], payload: args[1] });\n        } else {\n          handler(...args);\n        }\n      };\n\n      emitter.on(event, internalHandler);\n\n      // Add this handler to the cache, so we could remove it using the passed listener.\n      const handlersMap: HandlersMap = eventToHandlersMap.get(event) || new Map();\n      eventToHandlersMap.set(event, handlersMap);\n\n      const handlers = handlersMap.get(handler) || [];\n      handlersMap.set(handler, handlers);\n      handlers.push([internalHandler, once || false]);\n\n      return cleanup;\n    },\n    off,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    emit: emitter.emit,\n    clear() {\n      const prevSize = eventToHandlersMap.size;\n      emitter.all.clear();\n      eventToHandlersMap.clear();\n      prevSize && onEmpty();\n    },\n  };\n}\n","import type { EventPayload, EventWithoutPayload, EventWithPayload } from '@/events/types/index.js';\n\n/**\n * Emits an event without payload sent from the Telegram native application like it was sent in\n * a default web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n */\nexport function emitEvent<E extends EventWithoutPayload>(eventType: E): void;\n\n/**\n * Emits an event with payload sent from the Telegram native application like it was sent in\n * a default web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent<E extends EventWithPayload>(\n  eventType: E,\n  eventData: EventPayload<E>,\n): void;\n\n/**\n * Emits an unknown event sent from the Telegram native application like it was sent in a default\n * web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent<E extends string>(\n  eventType: E,\n  eventData: E extends EventWithoutPayload\n    ? never\n    : E extends EventWithPayload\n      ? EventPayload<E>\n      : unknown,\n): void;\n\n/**\n * Emits an event sent from the Telegram native application like it was sent in a default web\n * environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent(eventType: string, eventData?: unknown): void {\n  window.dispatchEvent(new MessageEvent('message', {\n    data: JSON.stringify({ eventType, eventData }),\n    // We specify this kind of source here in order to allow the package's \"on\" function to\n    // capture it. The reason is this function always checks the event source and relies on\n    // it to be the parent window.\n    source: window.parent,\n  }));\n}\n","import { signal, computed } from '@tma.js/signals';\nimport { createLogger, type Logger } from '@tma.js/toolkit';\n\nimport { off, offAll, on } from '@/events/emitter.js';\nimport type { SubscribeListener } from '@/events/types/index.js';\nimport type { PostMessage } from '@/methods/postMessage.js';\n\n/**\n * @internal\n */\nconst _debug = signal(false);\n/**\n * @internal\n */\nconst _targetOrigin = signal('https://web.telegram.org');\n\nconst onEventReceived: SubscribeListener = event => {\n  logger().log('Event received:', event);\n};\n\n/**\n * The current debug mode state.\n *\n * To update the value, use the `setDebug` function.\n * @see setDebug\n */\nexport const debug = computed(_debug);\n\n/**\n * Sets the package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  if (value !== _debug()) {\n    _debug.set(value);\n    (value ? on : off)('*', onEventReceived);\n  }\n}\n\n/**\n * The current target origin used by the `postEvent` method.\n *\n * You don't need to override this value until you know what you are doing.\n * To update the value, use the `setTargetOrigin` function.\n * @default 'https://web.telegram.org'\n * @see setTargetOrigin\n */\nexport const targetOrigin = computed(_targetOrigin);\n\n/**\n * Sets a new target origin that is being used when calling the `postEvent` function in Telegram\n * web versions.\n *\n * You don't need to override this value until you know what you are doing.\n * @param origin - allowed target origin value.\n * @see _targetOrigin\n */\nexport function setTargetOrigin(origin: string) {\n  _targetOrigin.set(origin);\n  logger().log('New target origin set', origin);\n}\n\n/**\n * Signal containing a custom implementation of the method to post a message to the parent\n * window. We usually use it to send a message in web versions of Telegram.\n *\n * @default A function behaving like the `window.parent.postMessage` method.\n */\nexport const postMessageImpl = signal<PostMessage>((...args) => {\n  window.parent.postMessage(...args as unknown as Parameters<PostMessage>);\n});\n\n/**\n * The package logger. You can override this value in order to use your own implementation.\n */\nexport const logger = signal<Logger>(createLogger('Bridge', {\n  bgColor: '#9147ff',\n  textColor: 'white',\n  shouldLog: debug,\n}));\n\n/**\n * Resets the package global values. Normally, you don't use this function in your application.\n * We are using it only for test purposes.\n */\nexport function resetGlobals() {\n  offAll();\n  [postMessageImpl, _targetOrigin, targetOrigin, _debug, debug, logger].forEach(s => {\n    s.unsubAll();\n    'reset' in s && s.reset();\n  });\n}\n","/**\n * Defines a property, that is a functions compose. Trying to set a value in this property\n * will lead to adding it to a function's pool. The property value will always be equal to a\n * function, calling all collected functions in the pool.\n *\n * Returned function performs a cleanup. It does one of the following:\n * 1. Removes the property if no functions were to the pool added other than the initial one.\n * 2. Sets the value equal to the first added function to the pool after the initial one if\n * the only one additional function was added at all. In other words, if the pool length is equal\n * to 2, the second item will be selected as the property value.\n * 3. Leaves the value equal to a function calling all pool functions, but removes the initially\n * added one.\n * @param obj - object.\n * @param propertyName - object property.\n * @param initialFn - an initial function to set.\n */\nexport function defineFnComposer(\n  obj: any,\n  propertyName: string,\n  initialFn: (...args: any) => any,\n): void {\n  const assignedFunctions: any[] = [initialFn];\n\n  const property = obj[propertyName];\n  if (typeof property === 'function') {\n    assignedFunctions.push(property);\n  }\n\n  const callAssignedFunctions = (...args: any) => {\n    assignedFunctions.forEach(fn => fn(...args));\n  };\n\n  // Wrap the callPool function and add \"unwrap\" method to it.\n  const unwrappableCallAssignedFunctions = Object.assign((...args: any) => {\n    callAssignedFunctions(...args);\n  }, {\n    // Unwraps the composer.\n    unwrap() {\n      const { length: poolSize } = assignedFunctions;\n      if (poolSize === 1) {\n        // Only the initial handler is in the pool. In this case we just remove the property.\n        delete obj[propertyName];\n        return;\n      }\n      if (poolSize === 2) {\n        // Only one additional handler was added. We set it as a value for the property.\n        defineStaticProperty(obj, propertyName, assignedFunctions[1]);\n        return;\n      }\n      // Many additional handlers were added. In this case we remove the initially added function\n      // from the pool and leave the property value almost as is - only \"unwrap\" method will be\n      // removed.\n      assignedFunctions.unshift(1);\n      defineStaticProperty(obj, propertyName, callAssignedFunctions);\n    },\n  });\n\n  // This property should now always return our special function. Trying to set it to another\n  // function should lead to just adding it to the pool of called functions.\n  defineProxiedProperty(\n    obj,\n    propertyName,\n    () => unwrappableCallAssignedFunctions,\n    value => assignedFunctions.push(value),\n  );\n}\n\n/**\n * Wires the specified property in the object preventing it from being overwritten. Instead, it\n * enhances the previous value by merging the current one with the passed one.\n * @param obj - object.\n * @param prop - object property to rewire.\n */\nexport function defineMergeableProperty(obj: any, prop: string): void {\n  const value = obj[prop];\n  defineProxiedProperty(obj, prop, () => value, v => {\n    Object.entries(v).forEach(([objKey, objValue]) => {\n      value[objKey] = objValue;\n    });\n  });\n}\n\n/**\n * Defines an enumerable and configurable property with a getter and setter.\n * @param obj - object.\n * @param prop - object property name.\n * @param get - getter to use.\n * @param set - setter to use.\n */\nexport function defineProxiedProperty(\n  obj: any,\n  prop: string,\n  get: () => unknown,\n  set: (v: any) => void,\n) {\n  Object.defineProperty(obj, prop, {\n    enumerable: true,\n    configurable: true,\n    get,\n    set,\n  });\n}\n\n/**\n * Defines an enumerable, configurable and writable property with the initial value.\n * @param obj - object.\n * @param prop - object property name.\n * @param value - value to set.\n */\nexport function defineStaticProperty(obj: any, prop: string, value: any): void {\n  Object.defineProperty(obj, prop, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value,\n  });\n}\n","import { miniAppsMessage, pipeJsonToSchema, themeParams } from '@tma.js/transformers';\nimport {\n  boolean,\n  looseObject,\n  nullish,\n  number,\n  optional,\n  parse,\n  string,\n  unknown,\n  type BaseSchema,\n} from 'valibot';\n\nimport { createEmitter } from '@/events/createEmitter.js';\nimport { emitEvent } from '@/events/emitEvent.js';\nimport type { EventName, EventPayload, Events } from '@/events/types/index.js';\nimport { logger } from '@/globals.js';\nimport { defineFnComposer, defineMergeableProperty } from '@/obj-prop-helpers.js';\n\n/**\n * Transformers for problematic Mini Apps events.\n */\nconst transformers = {\n  clipboard_text_received: looseObject({\n    req_id: string(),\n    data: nullish(string()),\n  }),\n  custom_method_invoked: looseObject({\n    req_id: string(),\n    result: optional(unknown()),\n    error: optional(string()),\n  }),\n  popup_closed: nullish(\n    looseObject({ button_id: nullish(string(), () => undefined) }),\n    {},\n  ),\n  viewport_changed: nullish(\n    looseObject({\n      height: number(),\n      width: nullish(number(), () => window.innerWidth),\n      is_state_stable: boolean(),\n      is_expanded: boolean(),\n    }),\n    // TODO: At the moment, macOS has a bug with the invalid event payload - it is always equal to\n    //  null. Leaving this default value until the bug is fixed.\n    () => ({\n      height: window.innerHeight,\n      is_state_stable: true,\n      is_expanded: true,\n    }),\n  ),\n  theme_changed: looseObject({\n    theme_params: themeParams(),\n  }),\n} as const satisfies { [E in EventName]?: BaseSchema<unknown, EventPayload<E>, any> };\n\nfunction windowMessageListener(event: MessageEvent): void {\n  // Ignore non-parent window messages.\n  if (event.source !== window.parent) {\n    return;\n  }\n\n  // Parse incoming event data.\n  let message: { eventType: string; eventData?: unknown };\n  try {\n    message = parse(pipeJsonToSchema(miniAppsMessage()), event.data);\n  } catch {\n    // We ignore incorrect messages as they could be generated by any other code.\n    return;\n  }\n\n  const { eventType, eventData } = message;\n  const schema = transformers[eventType as keyof typeof transformers];\n\n  let data: unknown;\n  try {\n    data = schema ? parse(schema, eventData) : eventData;\n  } catch (cause) {\n    return logger().forceError(\n      [\n        `An error occurred processing the \"${eventType}\" event from the Telegram application.`,\n        'Please, file an issue here:',\n        'https://github.com/Telegram-Mini-Apps/tma.js/issues/new/choose',\n      ].join('\\n'),\n      message,\n      cause,\n    );\n  }\n  emit(eventType as any, data);\n}\n\nexport const {\n  on,\n  off,\n  emit,\n  clear: offAll,\n} = createEmitter<Events>(\n  () => {\n    const wnd = window as any;\n\n    // Define all functions responsible for receiving an event from the Telegram client.\n    // All these \"ports\" should narrow the communication way to a single specific one - the way\n    // accepted by the web version of Telegram between iframes.\n    //\n    // Here we consider 2 cases:\n    // 1. When the Telegram SDK is already connected. In this case the Telegram SDK already\n    // installed its own ports, and we should rewire them. The cleanup function should also work\n    // properly in this context, removing @tma.js/bridge handler only, not\n    // the Telegram SDK one.\n    // 2. When the Telegram SDK is not connected, but probably will be. We know, that\n    // the Telegram SDK is going to overwrite our own handlers. Due to this reason, we should\n    // protect them from being overwritten, but still support handlers defined by the Telegram SDK.\n\n    // TelegramGameProxy.receiveEvent\n    !wnd.TelegramGameProxy && (wnd.TelegramGameProxy = {});\n    defineFnComposer(wnd.TelegramGameProxy, 'receiveEvent', emitEvent);\n    defineMergeableProperty(wnd, 'TelegramGameProxy');\n\n    // Telegram.WebView.receiveEvent\n    !wnd.Telegram && (wnd.Telegram = {});\n    !wnd.Telegram.WebView && (wnd.Telegram.WebView = {});\n    defineFnComposer(wnd.Telegram.WebView, 'receiveEvent', emitEvent);\n    defineMergeableProperty(wnd.Telegram, 'WebView');\n\n    // TelegramGameProxy_receiveEvent\n    defineFnComposer(wnd, 'TelegramGameProxy_receiveEvent', emitEvent);\n\n    // Add a listener handling events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    // This handler should emit a new event using the library event emitter.\n    window.addEventListener('message', windowMessageListener);\n  },\n  () => {\n    [\n      ['TelegramGameProxy_receiveEvent'],\n      ['TelegramGameProxy', 'receiveEvent'],\n      ['Telegram', 'WebView', 'receiveEvent'],\n    ].forEach(path => {\n      const wnd = window as any;\n\n      // A tuple, where the first value is the receiveEvent function owner, and the second\n      // value is the receiveEvent itself.\n      let cursor: [obj: any, receieveEvent: any] = [undefined, wnd];\n      for (const item of path) {\n        cursor = [cursor[1], cursor[1][item]];\n        if (!cursor[1]) {\n          return;\n        }\n      }\n      const [receiveEventOwner, receiveEvent] = cursor;\n      if ('unwrap' in receiveEvent) {\n        receiveEvent.unwrap();\n        if (\n          receiveEventOwner\n          && receiveEventOwner !== wnd\n          && !Object.keys(receiveEventOwner).length\n        ) {\n          delete wnd[path[0]];\n        }\n      }\n    });\n    window.removeEventListener('message', windowMessageListener);\n  },\n);\n","import { postMessageImpl } from '@/globals.js';\n\nexport type PostMessage = typeof window.parent.postMessage;\n\n/**\n * Posts a message to the parent window. We usually use it to send a message in web versions of\n * Telegram.\n * @param args - `window.parent.postMessage` arguments.\n */\nexport const postMessage: PostMessage = (...args) => {\n  return postMessageImpl()(...args as unknown as Parameters<PostMessage>);\n};\n","import * as E from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\nimport { function as fn, is, looseObject } from 'valibot';\n\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { isIframe } from '@/env/isIframe.js';\nimport { UnknownEnvError } from '@/errors.js';\nimport { logger, targetOrigin } from '@/globals.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\nimport { postMessage } from './postMessage.js';\n\nexport type PostEventError = UnknownEnvError;\nexport type PostEventFn = typeof postEvent;\nexport type PostEventFpFn = typeof postEventFp;\n\n/**\n * @see postEventFp\n */\nexport function postEvent<Method extends MethodNameWithRequiredParams>(\n  method: Method,\n  params: MethodParams<Method>,\n): void;\n/**\n * @see postEventFp\n */\nexport function postEvent(method: MethodNameWithoutParams): void;\n/**\n * @see postEventFp\n */\nexport function postEvent<Method extends MethodNameWithOptionalParams>(\n  method: Method,\n  params?: MethodParams<Method>,\n): void;\n\nexport function postEvent(\n  eventType: MethodName,\n  eventData?: MethodParams<MethodName>,\n): void {\n  pipe(\n    postEventFp(\n      // @ts-expect-error It's ok, TS can't determine a specific override.\n      eventType,\n      eventData,\n    ),\n    E.mapLeft(err => {\n      throw err;\n    }),\n  );\n}\n\n/**\n * Calls Mini Apps methods requiring parameters.\n * @param method - method name.\n * @param params - options along with params.\n */\nexport function postEventFp<Method extends MethodNameWithRequiredParams>(\n  method: Method,\n  params: MethodParams<Method>,\n): E.Either<PostEventError, void>;\n\n/**\n * Calls Mini Apps methods accepting no parameters at all.\n * @param method - method name.\n */\nexport function postEventFp(method: MethodNameWithoutParams): E.Either<PostEventError, void>;\n\n/**\n * Calls Mini Apps methods accepting optional parameters.\n * @param method - method name.\n * @param params - options along with params.\n */\nexport function postEventFp<Method extends MethodNameWithOptionalParams>(\n  method: Method,\n  params?: MethodParams<Method>,\n): E.Either<PostEventError, void>;\n\nexport function postEventFp(\n  eventType: MethodName,\n  eventData?: MethodParams<MethodName>,\n): E.Either<PostEventError, void> {\n  logger().log('Posting event:', eventData ? { eventType, eventData } : { eventType });\n\n  const w = window;\n  const message = JSON.stringify({ eventType, eventData });\n\n  // Telegram Web.\n  if (isIframe()) {\n    postMessage(message, targetOrigin());\n    return E.right(undefined);\n  }\n\n  // Telegram for iOS, macOS, Android and Telegram Desktop.\n  if (hasWebviewProxy(w)) {\n    w.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));\n    return E.right(undefined);\n  }\n\n  // Telegram for Windows Phone or Android.\n  if (is(looseObject({ external: looseObject({ notify: fn() }) }), w)) {\n    w.external.notify(message);\n    return E.right(undefined);\n  }\n\n  // Otherwise, the current environment is unknown, and we are not able to send event.\n  return E.left(new UnknownEnvError());\n}\n","import { signal } from '@tma.js/signals';\nimport {\n  BetterTaskEither,\n  type If,\n  type IsNever,\n  createCbCollector,\n  throwifyAnyEither,\n} from '@tma.js/toolkit';\nimport { BetterPromise } from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { on } from '@/events/emitter.js';\nimport type { EventName, EventPayload } from '@/events/types/index.js';\nimport { postEventFp } from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithRequiredParams,\n  MethodNameWithoutParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\nimport type {\n  RequestCaptureEventFn,\n  RequestCaptureEventsFn,\n  RequestCaptureFn,\n  RequestError,\n  RequestFpOptions,\n  RequestOptions,\n  RequestCaptureFnEventsPayload,\n} from './request.js';\n\ntype AnyEventName = EventName | EventName[];\n\nexport type Request2Error = RequestError;\nexport type Request2CaptureEventsFn<E extends EventName[]> = RequestCaptureEventsFn<E>;\nexport type Request2CaptureEventFn<E extends EventName> = RequestCaptureEventFn<E>;\nexport type Request2CaptureFn<E extends AnyEventName> = RequestCaptureFn<E>;\nexport type Request2Options<E extends AnyEventName> = RequestOptions<E>;\nexport type Request2FpOptions<E extends AnyEventName> = RequestFpOptions<E>;\nexport type Request2CaptureFnEventsPayload<E extends EventName[]> =\n  RequestCaptureFnEventsPayload<E>;\nexport type Request2Result<E extends AnyEventName> =\n  E extends (infer U extends EventName)[]\n    ? U extends infer K extends EventName\n      ? { event: K; payload: If<IsNever<EventPayload<K>>, undefined, EventPayload<K>> }\n      : never\n    : E extends EventName\n      ? If<IsNever<EventPayload<E>>, undefined, EventPayload<E>>\n      : never;\n\nexport type Request2Fn = typeof request2;\nexport type Request2FpFn = typeof request2Fp;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request2Fp<\n  M extends MethodNameWithRequiredParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options: Request2FpOptions<E> & { params: MethodParams<M> },\n): TE.TaskEither<Request2Error | AbortError, Request2Result<E>>;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request2Fp<\n  M extends MethodNameWithOptionalParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2FpOptions<E> & { params?: MethodParams<M> },\n): TE.TaskEither<Request2Error | AbortError, Request2Result<E>>;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request2Fp<\n  M extends MethodNameWithoutParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2FpOptions<E>,\n): TE.TaskEither<Request2Error | AbortError, Request2Result<E>>;\n\nexport function request2Fp<\n  M extends MethodName,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options: Request2FpOptions<E> & { params?: MethodParams<M> } = {},\n): TE.TaskEither<Request2Error | AbortError, Request2Result<E>> {\n  const {\n    // If no capture function was passed, we capture the first compatible event.\n    capture = () => true,\n    postEvent = postEventFp,\n  } = options;\n\n  // TODO: Maybe we want to rewrite it using a simple BetterPromise.\n\n  const result = signal<undefined | [Request2Result<E>]>();\n  const [addCleanup, cleanup] = createCbCollector();\n  // Iterate over all the tracked events and add a listener, checking if the event should be\n  // captured.\n  (Array.isArray(eventOrEvents) ? eventOrEvents : [eventOrEvents]).forEach(event => {\n    // Each event listener waits for the event to occur.\n    // Then, if the capture function was passed, we should check if the event should\n    // be captured. If the function is omitted, we instantly capture the event.\n    addCleanup(\n      on(event, payload => {\n        const isEventsArray = Array.isArray(eventOrEvents);\n        if (\n          isEventsArray\n            ? (capture as Request2CaptureEventsFn<EventName[]>)({ event, payload })\n            : (capture as Request2CaptureEventFn<EventName>)(payload)\n        ) {\n          result.set([\n            (isEventsArray ? { event, payload } : payload) as Request2Result<E>,\n          ]);\n        }\n      }),\n    );\n  });\n  const withCleanup = <T>(value: T): T => {\n    cleanup();\n    return value;\n  };\n\n  return pipe(\n    async () => postEvent(method as any, (options as any).params),\n    TE.chainW(() => {\n      return BetterTaskEither<AbortError, Request2Result<E>>((resolve, _, context) => {\n        // When creating this BetterTaskEither, we could already have a value stored in\n        // the result signal. For example, when tracked events were generated via emitEvent in\n        // mockTelegramEnv.onEvent.\n        const data = result();\n        if (data) {\n          return resolve(data[0]);\n        }\n\n        const listener = (data: [Request2Result<E>] | undefined) => {\n          if (data) {\n            resolve(data[0]);\n          }\n        };\n        const unsub = () => {\n          result.unsub(listener);\n        };\n        result.sub(listener);\n        context.on('finalized', unsub);\n      }, options);\n    }),\n    TE.mapBoth(withCleanup, withCleanup),\n  );\n}\n\n/**\n * @see request2Fp\n */\nexport function request2<M extends MethodNameWithRequiredParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options: Request2Options<E> & { params: MethodParams<M> },\n): BetterPromise<Request2Result<E>>;\n\n/**\n * @see request2Fp\n */\nexport function request2<M extends MethodNameWithOptionalParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2Options<E> & { params?: MethodParams<M> },\n): BetterPromise<Request2Result<E>>;\n\n/**\n * @see request2Fp\n */\nexport function request2<M extends MethodNameWithoutParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2Options<E>,\n): BetterPromise<Request2Result<E>>;\n\nexport function request2<M extends MethodName, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: Request2Options<E> & { params?: MethodParams<M> },\n): BetterPromise<Request2Result<E>> {\n  const { postEvent } = options || {};\n\n  return throwifyAnyEither(\n    // @ts-expect-error TypeScript will not be able to handle our overrides here.\n    request2Fp(method, eventOrEvents, {\n      ...options,\n      postEvent: postEvent\n        ? (...args: any[]) => {\n          try {\n            // @ts-expect-error TypeScript will not be able to handle our overrides here.\n            postEvent(...args);\n            return E.right(undefined);\n          } catch (e) {\n            return E.left(e);\n          }\n        }\n        : postEventFp,\n    }),\n  );\n}\n","import { throwifyAnyEither } from '@tma.js/toolkit';\nimport {\n  BetterPromise,\n  type BetterPromiseOptions,\n  TimeoutError,\n} from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { UnknownEnvError } from '@/errors.js';\nimport { retrieveRawLaunchParamsFp } from '@/launch-params.js';\nimport { type Request2Error, request2Fp } from '@/utils/request2.js';\n\nexport type isTMAError = Exclude<Request2Error, TimeoutError>;\n\n/**\n * @see isTMAFp\n */\nexport function isTMA(): boolean;\n/**\n * @see isTMAFp\n */\nexport function isTMA(type: 'complete', options?: BetterPromiseOptions): BetterPromise<boolean>;\nexport function isTMA(\n  type?: 'complete',\n  options?: BetterPromiseOptions,\n): boolean | BetterPromise<boolean> {\n  const monad = isTMAFp(\n    // @ts-expect-error TS doesn't get what override we are going to use.\n    type,\n    options,\n  ) as boolean | TE.TaskEither<isTMAError, boolean>;\n  return typeof monad === 'function'\n    ? BetterPromise.fn(() => throwifyAnyEither(monad))\n    : monad;\n}\n\n/**\n * Returns true if the current environment is Telegram Mini Apps.\n *\n * It uses the `retrieveLaunchParams` function to determine if the environment\n * contains launch parameters. In case it does, true will be returned.\n *\n * In case you need stricter checks, use async override of this function.\n */\nexport function isTMAFp(): boolean;\n/**\n * Returns promise with true if the current environment is Telegram Mini Apps.\n *\n * First of all, it checks if the current environment contains traits specific\n * to the Mini Apps environment. Then, it attempts to call a Mini Apps method\n * and waits for a response to be received.\n *\n * In case you need less strict checks, use sync override of this function.\n */\nexport function isTMAFp(\n  type: 'complete',\n  options?: BetterPromiseOptions,\n): TE.TaskEither<isTMAError, boolean>;\nexport function isTMAFp(\n  type?: 'complete',\n  options?: BetterPromiseOptions,\n): boolean | TE.TaskEither<isTMAError, boolean> {\n  const hasProxy = hasWebviewProxy(window);\n  if (!type) {\n    return hasProxy || pipe(retrieveRawLaunchParamsFp(), E.match(() => false, () => true));\n  }\n  if (hasProxy) {\n    return TE.right(true);\n  }\n  const { timeout = 100 } = options || {};\n\n  return pipe(\n    request2Fp('web_app_request_theme', 'theme_changed', { ...options, timeout }),\n    TE.match(\n      error => (\n        TimeoutError.is(error) || UnknownEnvError.is(error)\n          ? E.right(false)\n          : E.left(error)\n      ),\n      () => E.right(true),\n    ),\n  );\n}\n","import { setStorageValue } from '@tma.js/toolkit';\nimport {\n  miniAppsMessage,\n  parseLaunchParamsQuery,\n  pipeJsonToSchema,\n  serializeLaunchParamsQuery,\n  type LaunchParamsLike,\n} from '@tma.js/transformers';\nimport { parse } from 'valibot';\n\nimport { isIframe } from '@/env/isIframe.js';\nimport { InvalidLaunchParamsError } from '@/errors.js';\nimport { logger, postMessageImpl } from '@/globals.js';\nimport type { MethodName, MethodParams } from '@/methods/types/index.js';\n\n/**\n * Mocks the environment and imitates Telegram Mini Apps behavior.\n *\n * We usually use this function in the following cases:\n * 1. We are developing an application outside the Telegram environment and would like to imitate\n * the Telegram client in order to re-create the same communication behavior.\n * 2. We would like to intercept some Telegram Mini Apps methods' calls in order to enhance them\n * or write a custom behavior. It is extremely useful in some Telegram clients improperly handling\n * Mini Apps methods' calls and not even responding.\n *\n * Note that calling this function in Telegram web clients, the `postMessageImplementation` signal\n * value will be updated with a new one, enhancing previously set signal value to allow wrapping\n * the original `window.parent.postMessage` function. In other words, calling `mockTelegramEnv`\n * function N times, you will effectively wrap previously set implementation N times, so be\n * careful calling this function several times during a single lifecycle of the app. In case you\n * would like to avoid such kind of behavior, use the `resetPostMessage` option.\n */\nexport function mockTelegramEnv({ launchParams, onEvent, resetPostMessage }: {\n  /**\n   * Launch parameters to mock. They will be saved in the storage, so the SDK functions could\n   * retrieve them.\n   *\n   * Note that this value must have `tgWebAppData` presented in a raw format as long as you will\n   * need it when retrieving init data in this format. Otherwise, init data may be broken.\n   */\n  launchParams?:\n    | (Omit<LaunchParamsLike, 'tgWebAppData'> & { tgWebAppData?: string | URLSearchParams })\n    | string\n    | URLSearchParams;\n  /**\n   * Function that will be called if a Mini Apps method call was requested by the mini app.\n   *\n   * It receives a Mini Apps method name along with the passed payload.\n   *\n   * Note that using the `next` function, in non-web environments it uses the\n   * `window.TelegramWebviewProxy.postEvent` method.\n   *\n   * Talking about the web versions of Telegram, the value of `next` is a bit more complex - it\n   * will be equal to the value stored in the `postMessageImpl` signal set previously. By default,\n   * this value contains a function utilizing the `window.parent.postMessage` method.\n   * @param event - event information.\n   * @param next - function to call the original method used to call a Mini Apps method.\n   */\n  onEvent?: (\n    event:\n      | { [M in MethodName]: { name: M; params: MethodParams<M> } }[MethodName]\n      | { name: string; params: unknown },\n    next: () => void,\n  ) => void;\n  /**\n   * Removes all previously set enhancements of the `window.parent.postMessage` function set\n   * by other `mockTelegramEnv` calls.\n   * @default false\n   */\n  resetPostMessage?: boolean;\n} = {}): void {\n  if (launchParams) {\n    // If launch parameters were passed, save them in the session storage, so\n    // the retrieveLaunchParams function would return them.\n    const launchParamsQuery =\n      typeof launchParams === 'string' || launchParams instanceof URLSearchParams\n        ? launchParams.toString()\n        : (\n          // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n          // value. We are doing it because we are working with tgWebAppData presented as a\n          // string, not an object as serializeLaunchParamsQuery requires.\n          serializeLaunchParamsQuery({ ...launchParams, tgWebAppData: undefined })\n          // Then, we just append init data.\n          + (launchParams.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(launchParams.tgWebAppData.toString())}` : '')\n        );\n\n    // Remember to check if launch params are valid.\n    try {\n      parseLaunchParamsQuery(launchParamsQuery);\n    } catch (e) {\n      throw new InvalidLaunchParamsError(launchParamsQuery, e);\n    }\n    setStorageValue('launchParams', launchParamsQuery);\n  }\n\n  // Original postEvent firstly checks if the current environment is iframe.\n  // That's why we have a separate branch for this environment here too.\n  if (isIframe()) {\n    if (!onEvent) {\n      return;\n    }\n    // As long as the postEvent function uses the postMessage method, we should rewire it.\n    if (resetPostMessage) {\n      postMessageImpl.reset();\n    }\n\n    const original = postMessageImpl();\n    postMessageImpl.set((...args) => {\n      const [message] = args;\n      const next = () => {\n        (original as any)(...args);\n      };\n\n      // Pass only Telegram Mini Apps events to the handler. All other calls should be passed\n      // to the original handler (window.parent.postMessage likely).\n      try {\n        const data = parse(pipeJsonToSchema(miniAppsMessage()), message);\n        onEvent({ name: data.eventType, params: data.eventData }, next);\n      } catch {\n        next();\n      }\n    });\n    return;\n  }\n\n  // In all other environments, it is enough to define window.TelegramWebviewProxy.postEvent.\n  const proxy = (window as any).TelegramWebviewProxy || {};\n  const postEventDefaulted = proxy.postEvent || (() => undefined);\n  (window as any).TelegramWebviewProxy = {\n    ...proxy,\n    postEvent(eventType: string, eventData: string) {\n      const next = () => {\n        postEventDefaulted(eventType, eventData);\n      };\n      onEvent\n        ? onEvent({\n          name: eventType,\n          params: eventData ? JSON.parse(eventData) : undefined,\n        }, next)\n        : next();\n    },\n  };\n\n  logger().log('Environment was mocked by the mockTelegramEnv function');\n}\n","type CaptureSameReqFn = (payload: { req_id: string }) => boolean;\n\n/**\n * Returns a function which can be used in `request` function `capture` property to capture\n * the event with the same request identifier.\n * @param reqId - request identifier.\n */\nexport function captureSameReq(reqId: string): CaptureSameReqFn {\n  return ({ req_id }) => req_id === reqId;\n}\n","import { Version } from '@tma.js/types';\n\nimport {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\n\nconst releases = {\n  '6.0': [\n    'iframe_ready',\n    'iframe_will_reload',\n    'web_app_close',\n    'web_app_data_send',\n    'web_app_expand',\n    'web_app_open_link',\n    'web_app_ready',\n    'web_app_request_theme',\n    'web_app_request_viewport',\n    'web_app_setup_main_button',\n    'web_app_setup_closing_behavior',\n  ],\n  6.1: [\n    'web_app_open_tg_link',\n    'web_app_open_invoice',\n    'web_app_setup_back_button',\n    'web_app_set_background_color',\n    'web_app_set_header_color',\n    'web_app_trigger_haptic_feedback',\n  ],\n  6.2: ['web_app_open_popup'],\n  6.4: [\n    'web_app_close_scan_qr_popup',\n    'web_app_open_scan_qr_popup',\n    'web_app_read_text_from_clipboard',\n    { method: 'web_app_open_link', param: 'try_instant_view' },\n  ],\n  6.7: ['web_app_switch_inline_query'],\n  6.9: [\n    'web_app_invoke_custom_method',\n    'web_app_request_write_access',\n    'web_app_request_phone',\n    { method: 'web_app_set_header_color', param: 'color' },\n  ],\n  '6.10': ['web_app_setup_settings_button'],\n  7.2: [\n    'web_app_biometry_get_info',\n    'web_app_biometry_open_settings',\n    'web_app_biometry_request_access',\n    'web_app_biometry_request_auth',\n    'web_app_biometry_update_token',\n  ],\n  7.6: [\n    { method: 'web_app_open_link', param: 'try_browser' },\n    { method: 'web_app_close', param: 'return_back' },\n  ],\n  7.7: ['web_app_setup_swipe_behavior'],\n  7.8: ['web_app_share_to_story'],\n  '7.10': [\n    'web_app_setup_secondary_button',\n    'web_app_set_bottom_bar_color',\n    { method: 'web_app_setup_main_button', param: 'has_shine_effect' },\n  ],\n  '8.0': [\n    'web_app_request_safe_area',\n    'web_app_request_content_safe_area',\n    'web_app_request_fullscreen',\n    'web_app_exit_fullscreen',\n    'web_app_set_emoji_status',\n    'web_app_add_to_home_screen',\n    'web_app_check_home_screen',\n    'web_app_request_emoji_status_access',\n    'web_app_check_location',\n    'web_app_open_location_settings',\n    'web_app_request_file_download',\n    'web_app_request_location',\n    'web_app_send_prepared_message',\n    'web_app_start_accelerometer',\n    'web_app_start_device_orientation',\n    'web_app_start_gyroscope',\n    'web_app_stop_accelerometer',\n    'web_app_stop_device_orientation',\n    'web_app_stop_gyroscope',\n    'web_app_toggle_orientation_lock',\n  ],\n  '9.0': [\n    'web_app_device_storage_clear',\n    'web_app_device_storage_get_key',\n    'web_app_device_storage_save_key',\n    'web_app_secure_storage_clear',\n    'web_app_secure_storage_get_key',\n    'web_app_secure_storage_restore_key',\n    'web_app_secure_storage_save_key',\n  ],\n  9.1: ['web_app_hide_keyboard'],\n};\n\n/**\n * @returns Version of the specified method parameter release. Returns `null`\n * if passed method or parameter are unknown.\n * @param method - method name\n * @param param - method parameter\n */\nexport function getReleaseVersion<M extends MethodNameWithVersionedParams>(\n  method: M,\n  param: MethodVersionedParams<M>,\n): Version | null;\n\n/**\n * @returns Version of the specified method release. Returns `null`\n * if passed method is unknown.\n * @param method - method name.\n */\nexport function getReleaseVersion(method: MethodName): Version | null;\nexport function getReleaseVersion(method: MethodName, param?: string): Version | null {\n  const versions = Object.keys(releases) as (`${keyof typeof releases}`)[];\n  return versions.find(version => {\n    return releases[version].some(item => {\n      if (param) {\n        return typeof item === 'object'\n          && item.method === method\n          && item.param === param;\n      }\n      return item === method;\n    });\n  }) || null;\n}\n","import type { Version } from '@tma.js/types';\n\nfunction parts(a: Version): number[] {\n  return a.split('.').map(Number);\n}\n\n/**\n * @param a - first version.\n * @param b - second version.\n * @returns\n * - `1` if the version \"a\" is greater than \"b\".\n * - `0` the version \"a\" is equal to \"b\".\n * - `-1` the version \"a\" is lower than \"b\".\n */\nexport function compareVersions(a: Version, b: Version): number {\n  const aParts = parts(a);\n  const bParts = parts(b);\n  const len = Math.max(aParts.length, bParts.length);\n\n  // Iterate over each part of versions and compare them. In case, part is\n  // missing, assume its value is equal to 0.\n  for (let i = 0; i < len; i += 1) {\n    const aVal = aParts[i] || 0;\n    const bVal = bParts[i] || 0;\n\n    if (aVal === bVal) {\n      continue;\n    }\n    return aVal > bVal ? 1 : -1;\n  }\n  return 0;\n}\n","import type { Version } from '@tma.js/types';\n\nimport { getReleaseVersion } from '@/methods/getReleaseVersion.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\nimport { compareVersions } from '@/utils/compareVersions.js';\n\n/**\n * Returns true in case, passed parameter in specified method is supported.\n * @param method - method name\n * @param param - method parameter\n * @param inVersion - platform version.\n */\nexport function supports<M extends MethodNameWithVersionedParams>(\n  method: M,\n  param: MethodVersionedParams<M>,\n  inVersion: Version,\n): boolean;\n\n/**\n * Returns true in case, specified method is supported in a passed version.\n * @param method - method name.\n * @param inVersion - platform version.\n */\nexport function supports(method: MethodName, inVersion: Version): boolean;\n\nexport function supports(\n  method: MethodName,\n  paramOrVersion: Version | string,\n  inVersion?: string,\n): boolean {\n  const version = inVersion\n    ? getReleaseVersion(\n      method as MethodNameWithVersionedParams,\n      paramOrVersion as MethodVersionedParams<MethodNameWithVersionedParams>,\n    )\n    : getReleaseVersion(method);\n  return version\n    ? compareVersions(version, inVersion || paramOrVersion) <= 0\n    : false;\n}\n","import type { Version } from '@tma.js/types';\nimport { any, is, looseObject } from 'valibot';\n\nimport { MethodParameterUnsupportedError, MethodUnsupportedError } from '@/errors.js';\nimport { logger } from '@/globals.js';\nimport { type PostEventFn, postEvent } from '@/methods/postEvent.js';\nimport { supports } from '@/methods/supports.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\n\nexport type OnUnsupportedFn = (\n  data: { version: Version } & (\n    | { method: MethodName }\n    | {\n      [M in MethodNameWithVersionedParams]: {\n        method: M;\n        param: MethodVersionedParams<M>;\n      };\n    }[MethodNameWithVersionedParams]),\n) => void;\n\nexport type CreatePostEventMode = 'strict' | 'non-strict';\n\n/**\n * Creates a function that checks if the specified method and parameters are supported.\n *\n * If the method or parameters are unsupported, the `onUnsupported` function will be called.\n *\n * If `strict` or `non-strict` value was passed as the second argument, the function\n * will create its own `onUnsupported` function with behavior depending on the value passed.\n *\n * - Passing `strict` will make the function to throw a `MethodParameterUnsupportedError`\n * or a `MethodUnsupportedError` error.\n * - Passing `non-strict` will just warn you about something being unsupported.\n *\n * @param version - Telegram Mini Apps version.\n * @param onUnsupportedOrMode - function or strict mode. Default: `strict`\n */\nexport function createPostEvent(\n  version: Version,\n  onUnsupportedOrMode: OnUnsupportedFn | CreatePostEventMode = 'strict',\n): PostEventFn {\n  const onUnsupported: OnUnsupportedFn = typeof onUnsupportedOrMode === 'function'\n    ? onUnsupportedOrMode\n    : data => {\n      const { method, version } = data;\n      const error = 'param' in data\n        ? new MethodParameterUnsupportedError(method, data.param, version)\n        : new MethodUnsupportedError(method, version);\n\n      if (onUnsupportedOrMode === 'strict') {\n        throw error;\n      }\n      return logger().forceWarn(error.message);\n    };\n\n  return ((method: any, params: any) => {\n    // Firstly, check if the method is supported.\n    if (!supports(method, version)) {\n      return onUnsupported({ version, method });\n    }\n\n    // Method could use parameters, which are supported only in specific versions of Mini Apps.\n    // We are validating only those parameters, which are not backward compatible.\n    if (\n      method === 'web_app_set_header_color'\n      && is(looseObject({ color: any() }), params)\n      && !supports(method, 'color', version)\n    ) {\n      return onUnsupported({ version, method, param: 'color' });\n    }\n\n    return postEvent(method, params);\n  }) as PostEventFn;\n}\n","import { BetterPromise } from 'better-promises';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { InvokeCustomMethodFailedError } from '@/errors.js';\nimport { captureSameReq } from '@/methods/captureSameReq.js';\nimport type { CustomMethodName, CustomMethodParams } from '@/methods/types/index.js';\n\nimport {\n  request2Fp,\n  type Request2Error,\n  type Request2FpOptions,\n  type Request2Options,\n} from './request2.js';\n\nexport type InvokeCustomMethodError = Request2Error | InvokeCustomMethodFailedError;\n\nexport type InvokeCustomMethodOptions = Omit<Request2Options<'custom_method_invoked'>, 'capture'>;\nexport type InvokeCustomMethodFn = typeof invokeCustomMethod;\n\nexport type InvokeCustomMethodFpOptions = Omit<Request2FpOptions<'custom_method_invoked'>, 'capture'>;\nexport type InvokeCustomMethodFpFn = typeof invokeCustomMethodFp;\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n */\nexport function invokeCustomMethodFp<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  requestId: string,\n  options?: InvokeCustomMethodFpOptions,\n): TE.TaskEither<InvokeCustomMethodError, unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n */\nexport function invokeCustomMethodFp(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodFpOptions,\n): TE.TaskEither<Request2Error, unknown>;\n\nexport function invokeCustomMethodFp(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodFpOptions,\n): TE.TaskEither<InvokeCustomMethodError, unknown> {\n  return pipe(\n    request2Fp('web_app_invoke_custom_method', 'custom_method_invoked', {\n      ...options || {},\n      params: { method, params, req_id: requestId },\n      capture: captureSameReq(requestId),\n    }),\n    TE.chain(({ result, error }) => {\n      return error\n        ? TE.left(new InvokeCustomMethodFailedError(error))\n        : TE.right(result);\n    }),\n  );\n}\n\n/**\n * @see invokeCustomMethodFp\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): BetterPromise<unknown>;\n\n/**\n * @see invokeCustomMethodFp\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): BetterPromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): BetterPromise<unknown> {\n  return BetterPromise.fn(() => {\n    return pipe(\n      // @ts-expect-error TypeScript is unable to determine required override.\n      invokeCustomMethodFp(method, params, requestId, options),\n      TE.match(\n        error => {\n          throw error;\n        },\n        result => result,\n      ),\n    )();\n  });\n}\n","import { signal } from '@tma.js/signals';\nimport {\n  createCbCollector,\n  throwifyAnyEither,\n  type If,\n  type IsNever,\n  BetterTaskEither,\n} from '@tma.js/toolkit';\nimport {\n  BetterPromise,\n  type BetterPromiseOptions,\n  type TimeoutError,\n} from 'better-promises';\nimport * as E from 'fp-ts/Either';\nimport * as TE from 'fp-ts/TaskEither';\nimport { pipe } from 'fp-ts/function';\n\nimport { on } from '@/events/emitter.js';\nimport type { EventName, EventPayload } from '@/events/types/index.js';\nimport {\n  postEventFp,\n  type PostEventError,\n  type PostEventFn,\n  type PostEventFpFn,\n} from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\ntype AnyEventName = EventName | EventName[];\n\nexport type RequestError = PostEventError | TimeoutError;\n\n/**\n * @example\n * { event: 'scan_qr_closed' }\n * @example\n * {\n *   event: 'popup_closed',\n *   payload: { button_id: 'ok' }\n * }\n */\nexport type RequestCaptureFnEventsPayload<E extends EventName[]> =\n  E extends (infer U extends EventName)[]\n    ? {\n      [K in U]: If<\n        IsNever<EventPayload<K>>,\n        { event: K },\n        { event: K; payload: EventPayload<K> }\n      >\n    }[U]\n    : never;\n\nexport type RequestCaptureEventsFn<E extends EventName[]> = (\n  payload: RequestCaptureFnEventsPayload<E>,\n) => boolean;\n\nexport type RequestCaptureEventFn<E extends EventName> = If<\n  IsNever<EventPayload<E>>,\n  () => boolean,\n  (payload: EventPayload<E>) => boolean\n>;\n\nexport type RequestCaptureFn<E extends AnyEventName> = E extends EventName[]\n  ? RequestCaptureEventsFn<E>\n  : E extends EventName\n    ? RequestCaptureEventFn<E>\n    : never;\n\nexport interface RequestOptions<E extends AnyEventName> extends Omit<RequestFpOptions<E>, 'postEvent'> {\n  /**\n   * Custom function to call mini apps methods.\n   */\n  postEvent?: PostEventFn;\n}\n\nexport type RequestResult<E extends AnyEventName> =\n  E extends (infer U extends EventName)[]\n    ? U extends infer K extends EventName\n      ? If<IsNever<EventPayload<K>>, undefined, EventPayload<K>>\n      : never\n    : E extends EventName\n      ? If<IsNever<EventPayload<E>>, undefined, EventPayload<E>>\n      : never;\n\nexport interface RequestFpOptions<E extends AnyEventName> extends Pick<\n  BetterPromiseOptions,\n  'abortSignal' | 'timeout'\n> {\n  /**\n   * A function that should return true if the event should be captured.\n   * The first compatible request will be captured if this property is omitted.\n   */\n  capture?: RequestCaptureFn<E>;\n  /**\n   * A custom function to call mini apps methods.\n   */\n  postEvent?: PostEventFpFn;\n}\n\nexport type RequestFn = typeof request;\nexport type RequestFpFn = typeof requestFp;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n * @deprecated To be removed in the next major update. Use `request2fp` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function requestFp<\n  M extends MethodNameWithRequiredParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestFpOptions<E> & { params: MethodParams<M> },\n): TE.TaskEither<RequestError | AbortError, RequestResult<E>>;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n * @deprecated To be removed in the next major update. Use `request2fp` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function requestFp<\n  M extends MethodNameWithOptionalParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestFpOptions<E> & { params?: MethodParams<M> },\n): TE.TaskEither<RequestError | AbortError, RequestResult<E>>;\n\n/**\n * Calls a method waiting for the specified event(-s) to occur.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n * @deprecated To be removed in the next major update. Use `request2fp` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function requestFp<\n  M extends MethodNameWithoutParams,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestFpOptions<E>,\n): TE.TaskEither<RequestError | AbortError, RequestResult<E>>;\n\nexport function requestFp<\n  M extends MethodName,\n  E extends AnyEventName,\n  AbortError = never,\n>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestFpOptions<E> & { params?: MethodParams<M> } = {},\n): TE.TaskEither<RequestError | AbortError, RequestResult<E>> {\n  const {\n    // If no capture function was passed, we capture the first compatible event.\n    capture = () => true,\n    postEvent = postEventFp,\n  } = options;\n\n  const result = signal<undefined | [RequestResult<E>]>();\n  const [addCleanup, cleanup] = createCbCollector();\n  // Iterate over all the tracked events and add a listener, checking if the event should be\n  // captured.\n  (Array.isArray(eventOrEvents) ? eventOrEvents : [eventOrEvents]).forEach(event => {\n    // Each event listener waits for the event to occur.\n    // Then, if the capture function was passed, we should check if the event should\n    // be captured. If the function is omitted, we instantly capture the event.\n    addCleanup(\n      on(event, payload => {\n        if (\n          Array.isArray(eventOrEvents)\n            ? (capture as RequestCaptureEventsFn<EventName[]>)({ event, payload })\n            : (capture as RequestCaptureEventFn<EventName>)(payload)\n        ) {\n          result.set([payload as RequestResult<E>]);\n        }\n      }),\n    );\n  });\n  const withCleanup = <T>(value: T): T => {\n    cleanup();\n    return value;\n  };\n\n  return pipe(\n    async () => postEvent(method as any, (options as any).params),\n    TE.chainW(() => {\n      return BetterTaskEither<AbortError, RequestResult<E>>((resolve, _, context) => {\n        // When creating this BetterTaskEither, we could already have a value stored in\n        // the result signal. For example, when tracked events were generated via emitEvent in\n        // mockTelegramEnv.onEvent.\n        const data = result();\n        if (data) {\n          return resolve(data[0]);\n        }\n\n        const listener = (data: [RequestResult<E>] | undefined) => {\n          if (data) {\n            resolve(data[0]);\n          }\n        };\n        const unsub = () => {\n          result.unsub(listener);\n        };\n        result.sub(listener);\n        context.on('finalized', unsub);\n      }, options);\n    }),\n    TE.mapBoth(withCleanup, withCleanup),\n  );\n}\n\n/**\n * @see requestFp\n * @deprecated To be removed in the next major update. Use `request2` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function request<M extends MethodNameWithRequiredParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestOptions<E> & { params: MethodParams<M> },\n): BetterPromise<RequestResult<E>>;\n\n/**\n * @see requestFp\n * @deprecated To be removed in the next major update. Use `request2` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function request<M extends MethodNameWithOptionalParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E> & { params?: MethodParams<M> },\n): BetterPromise<RequestResult<E>>;\n\n/**\n * @see requestFp\n * @deprecated To be removed in the next major update. Use `request2` instead, it provides\n * a proper way of handling multiple events.\n */\nexport function request<M extends MethodNameWithoutParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E>,\n): BetterPromise<RequestResult<E>>;\n\nexport function request<M extends MethodName, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E> & { params?: MethodParams<M> },\n): BetterPromise<RequestResult<E>> {\n  const { postEvent } = options || {};\n\n  return throwifyAnyEither(\n    // @ts-expect-error TypeScript will not be able to handle our overrides here.\n    requestFp(method, eventOrEvents, {\n      ...options,\n      postEvent: postEvent\n        ? (...args: any[]) => {\n          try {\n            // @ts-expect-error TypeScript will not be able to handle our overrides here.\n            postEvent(...args);\n            return E.right(undefined);\n          } catch (e) {\n            return E.left(e);\n          }\n        }\n        : postEventFp,\n    }),\n  );\n}\n","/**\n * Applies polyfills required for stable work of the package:\n * - `Object.hasOwn` - used by `valibot`\n */\nexport function applyPolyfills(): void {\n  if (!Object.hasOwn) {\n    Object.hasOwn = function(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n  }\n}\n","import { throwifyFpFn } from '@tma.js/toolkit';\nimport * as E from 'fp-ts/Either';\n\nexport type DecodeBase64UrlError = DOMException;\n\n/**\n * Decodes a base-64-url ASCII string.\n * @param value - the value to decode.\n * @see Learn more about base64url:\n * https://herongyang.com/Encoding/Base64URL-Encoding-Algorithm.html\n * @see Source:\n * https://developer.mozilla.org/ru/docs/Glossary/Base64#solution_1__escaping_the_string_before_encoding_it\n */\nexport function decodeBase64UrlFp(value: string): E.Either<DecodeBase64UrlError, string> {\n  return E.tryCatch(() => {\n    return decodeURIComponent(\n      atob(\n        value\n          .replace(/-/g, '+')\n          .replace(/_/g, '/'),\n      )\n        .split('')\n        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n        .join(''),\n    );\n  }, e => e as DOMException);\n}\n\n/**\n * @see decodeBase64UrlFp\n */\nexport const decodeBase64Url = throwifyFpFn(decodeBase64UrlFp);\n\n/**\n * Creates a base-64-url encoded ASCII string from the passed value.\n * @param value - the value to encode.\n * @see Learn more about base64url:\n * https://herongyang.com/Encoding/Base64URL-Encoding-Algorithm.html\n * @see Source:\n * https://developer.mozilla.org/ru/docs/Glossary/Base64#solution_1__escaping_the_string_before_encoding_it\n */\nexport function encodeBase64Url(value: string): string {\n  // first we use encodeURIComponent to get percent-encoded UTF-8,\n  // then we convert the percent encodings into raw bytes which\n  // can be fed into btoa.\n  return btoa(\n    encodeURIComponent(value).replace(/%([0-9A-F]{2})/g, (_, p1) => {\n      return String.fromCharCode(parseInt(`0x${p1}`));\n    }),\n  )\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n","/**\n * @since 2.10.0\n */\nimport { tryCatch } from './Either';\nimport { identity } from './function';\n/**\n * Converts a JavaScript Object Notation (JSON) string into a `Json` type.\n *\n * @example\n * import * as J from 'fp-ts/Json'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('{\"a\":1}', J.parse), E.right({ a: 1 }))\n * assert.deepStrictEqual(pipe('{\"a\":}', J.parse), E.left(new SyntaxError(`Unexpected token '}', \"{\"a\":}\" is not valid JSON`)))\n *\n * @since 2.10.0\n */\nexport var parse = function (s) { return tryCatch(function () { return JSON.parse(s); }, identity); };\n/**\n * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import * as J from 'fp-ts/Json'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(J.stringify({ a: 1 }), E.right('{\"a\":1}'))\n * const circular: any = { ref: null }\n * circular.ref = circular\n * assert.deepStrictEqual(\n *   pipe(\n *     J.stringify(circular),\n *     E.mapLeft(e => e instanceof Error && e.message.includes('Converting circular structure to JSON'))\n *   ),\n *   E.left(true)\n * )\n *\n *  @since 2.10.0\n */\nexport var stringify = function (a) {\n    return tryCatch(function () {\n        var s = JSON.stringify(a);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, identity);\n};\n","import { throwifyFpFn, throwifyAnyEither } from '@tma.js/toolkit';\nimport * as E from 'fp-ts/Either';\nimport * as J from 'fp-ts/Json';\nimport { pipe } from 'fp-ts/function';\n\nimport { encodeBase64Url, type DecodeBase64UrlError, decodeBase64UrlFp } from '@/base64-url.js';\n\n/**\n * Creates a safe start parameter value. If the value is not a string, the\n * function applies JSON.stringify to it, so make sure you are not passing an\n * object with circular references.\n *\n * @param value - value to create start parameter from.\n * @see Learn more about start parameter:\n * https://docs.telegram-mini-apps.com/platform/start-parameter\n */\nexport function createStartParamFp(value: unknown): E.Either<Error, string> {\n  const b64 = encodeBase64Url(typeof value === 'string' ? value : JSON.stringify(value));\n  return b64.length > 512\n    ? E.left(new Error('Value is too long for start parameter'))\n    : E.right(b64);\n}\n\n/**\n * @see createStartParamFp\n */\nexport const createStartParam = throwifyFpFn(createStartParamFp);\n\n/**\n * @see decodeStartParamFp\n */\nexport function decodeStartParam<T>(value: string, parse: (value: string) => T): T;\n/**\n * @see decodeStartParamFp\n */\nexport function decodeStartParam(value: string, as: 'json'): J.Json;\n/**\n * @see decodeStartParamFp\n */\nexport function decodeStartParam(value: string): string;\nexport function decodeStartParam<T>(\n  value: string,\n  arg2?: 'json' | ((value: string) => T),\n): string | unknown | T {\n  return throwifyAnyEither(\n    decodeStartParamFp(\n      value,\n      // @ts-expect-error TypeScript is unable to detect a correct override.\n      typeof arg2 === 'function'\n        ? (value: string) => E.tryCatch(() => arg2(value), e => e)\n        : arg2,\n    ),\n  );\n}\n\n/**\n * Decodes a start parameter using a custom parser.\n * @param value - a start parameter value.\n * @param parse - a custom value parser.\n */\nexport function decodeStartParamFp<L, R>(\n  value: string,\n  parse: (value: string) => E.Either<L, R>,\n): E.Either<L | DecodeBase64UrlError, R>;\n/**\n * Decodes a start parameter assuming that the result is a JSON value.\n * @param value - a start parameter value.\n * @param as - result kind.\n */\nexport function decodeStartParamFp(\n  value: string,\n  as: 'json',\n): E.Either<SyntaxError | DecodeBase64UrlError, J.Json>;\n/**\n * Decodes a start parameter and returns its decoded representation.\n * @param value - a value to decode.\n */\nexport function decodeStartParamFp(value: string): E.Either<DecodeBase64UrlError, string>;\nexport function decodeStartParamFp<L, R>(\n  value: string,\n  arg2?: 'json' | ((value: string) => E.Either<L, R>),\n): E.Either<DecodeBase64UrlError | SyntaxError | L, R | string | J.Json> {\n  return pipe(\n    decodeBase64UrlFp(value),\n    E.chain<DecodeBase64UrlError | SyntaxError | L, string, R | string | J.Json>(decoded => {\n      if (!arg2) {\n        return E.right(decoded);\n      }\n      if (typeof arg2 === 'function') {\n        return arg2(decoded);\n      }\n      return J.parse(decoded) as E.Either<SyntaxError, J.Json>;\n    }),\n  );\n}\n\n/**\n * @returns True if the passed value is safe to be used to create a start parameter value from it.\n * If true is returned, the value can be safely passed to the `createStartParam` function.\n * @param value - value to check.\n * @see createStartParam\n */\nexport function isSafeToCreateStartParam(value: string): boolean {\n  return encodeBase64Url(value).length <= 512;\n}\n"],"names":["hasWebviewProxy","value","is","looseObject","fn","isIframe","__spreadArray","to","from","pack","i","l","ar","identity","a","flow","ab","bc","cd","de","ef","fg","gh","hi","ij","pipe","ret","dual","arity","body","isDataFirst","args","self","none","some","isLeft","ma","left","right","_.left","_.right","flatMap","f","map","fa","bimap","g","mapLeft","_.isLeft","matchW","onLeft","onRight","foldW","match","fold","tryCatch","onThrow","e","chainW","chain","_.none","_.some","isNone","onNone","onSome","F","E.right","E.left","M","E.isLeft","mapBoth","E.bimap","E.match","_map","_apPar","fab","ap","_a","of","URI","Functor","Pointed","Monad","ET.left","T.Pointed","ET.right","ET.match","T.Functor","ET.mapBoth","ET.flatMap","T.Monad","MethodUnsupportedError","errorClass","method","version","MethodParameterUnsupportedError","param","LaunchParamsRetrieveError","errorClassWithData","errors","source","error","InvalidLaunchParamsError","launchParams","cause","UnknownEnvError","InvokeCustomMethodFailedError","SESSION_STORAGE_KEY","retrieveLpFromUrl","urlString","retrieveLaunchParamsFp","retrieveRawLaunchParamsFp","E.chainW","parseLaunchParamsQueryFp","retrieveLaunchParams","throwifyFpFn","retrieveRawInitDataFp","E.map","raw","v","O.some","O.none","retrieveRawInitData","E.fold","err","O.match","retrieve","navigationEntry","getStorageValue","maybeError","E.foldW","setStorageValue","retrieveRawLaunchParams","createEmitter","onFirst","onEmpty","eventToHandlersMap","emitter","mitt","off","event","handler","once","handlersMap","handlers","index","item","prevSize","cleanup","internalHandler","emitEvent","eventType","eventData","_debug","signal","_targetOrigin","onEventReceived","logger","debug","computed","setDebug","on","targetOrigin","setTargetOrigin","origin","postMessageImpl","createLogger","resetGlobals","offAll","s","defineFnComposer","obj","propertyName","initialFn","assignedFunctions","property","callAssignedFunctions","unwrappableCallAssignedFunctions","poolSize","defineStaticProperty","defineProxiedProperty","defineMergeableProperty","prop","objKey","objValue","get","set","transformers","string","nullish","optional","unknown","number","boolean","themeParams","windowMessageListener","message","parse","pipeJsonToSchema","miniAppsMessage","schema","data","emit","wnd","path","cursor","receiveEventOwner","receiveEvent","postMessage","postEvent","postEventFp","E.mapLeft","w","request2Fp","eventOrEvents","options","capture","result","addCleanup","createCbCollector","payload","isEventsArray","withCleanup","TE.chainW","BetterTaskEither","resolve","_","context","listener","unsub","TE.mapBoth","request2","throwifyAnyEither","isTMA","type","monad","isTMAFp","BetterPromise","hasProxy","TE.right","timeout","TE.match","TimeoutError","mockTelegramEnv","onEvent","resetPostMessage","launchParamsQuery","serializeLaunchParamsQuery","parseLaunchParamsQuery","original","next","proxy","postEventDefaulted","captureSameReq","reqId","req_id","releases","getReleaseVersion","parts","compareVersions","b","aParts","bParts","len","aVal","bVal","supports","paramOrVersion","inVersion","createPostEvent","onUnsupportedOrMode","onUnsupported","params","any","invokeCustomMethodFp","requestId","TE.chain","TE.left","invokeCustomMethod","requestFp","request","applyPolyfills","decodeBase64UrlFp","E.tryCatch","c","decodeBase64Url","encodeBase64Url","p1","createStartParamFp","b64","createStartParam","decodeStartParam","arg2","decodeStartParamFp","E.chain","decoded","J.parse","isSafeToCreateStartParam"],"mappings":";;;;;;;;;AAOO,SAASA,GAAmBC,GAIjC;AACO,SAAAC;AAAA,IACLC,EAAY,EAAE,sBAAsBA,EAAY,EAAE,WAAWC,GAAG,EAAG,CAAA,GAAG;AAAA,IACtEH;AAAA,EACF;AACF;ACZO,SAASI,KAAoB;AAC9B,MAAA;AACK,WAAA,OAAO,SAAS,OAAO;AAAA,EAAA,QACxB;AACC,WAAA;AAAA,EAAA;AAEX;ACVA,IAAIC,KAAgD,SAAUC,GAAIC,GAAMC,GAAM;AAC1E,MAAIA,KAAQ,UAAU,WAAW,EAAG,UAASC,IAAI,GAAGC,IAAIH,EAAK,QAAQI,GAAIF,IAAIC,GAAGD;AAC5E,KAAIE,KAAM,EAAEF,KAAKF,QACRI,MAAIA,IAAK,MAAM,UAAU,MAAM,KAAKJ,GAAM,GAAGE,CAAC,IACnDE,EAAGF,CAAC,IAAIF,EAAKE,CAAC;AAGtB,SAAOH,EAAG,OAAOK,KAAM,MAAM,UAAU,MAAM,KAAKJ,CAAI,CAAC;AAC3D;AAmHO,SAASK,GAASC,GAAG;AACxB,SAAOA;AACX;AAqDO,SAASC,EAAKC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAI;AACrD,UAAQ,UAAU,QAAM;AAAA,IACpB,KAAK;AACD,aAAOR;AAAA,IACX,KAAK;AACD,aAAO,WAAY;AACf,eAAOC,EAAGD,EAAG,MAAM,MAAM,SAAS,CAAC;AAAA,MACtC;AAAA,IACL,KAAK;AACD,aAAO,WAAY;AACf,eAAOE,EAAGD,EAAGD,EAAG,MAAM,MAAM,SAAS,CAAC,CAAC;AAAA,MAC1C;AAAA,IACL,KAAK;AACD,aAAO,WAAY;AACf,eAAOG,EAAGD,EAAGD,EAAGD,EAAG,MAAM,MAAM,SAAS,CAAC,CAAC,CAAC;AAAA,MAC9C;AAAA,IACL,KAAK;AACD,aAAO,WAAY;AACf,eAAOI,EAAGD,EAAGD,EAAGD,EAAGD,EAAG,MAAM,MAAM,SAAS,CAAC,CAAC,CAAC,CAAC;AAAA,MAClD;AAAA,IACL,KAAK;AACD,aAAO,WAAY;AACf,eAAOK,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAG,MAAM,MAAM,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,MACtD;AAAA,IACL,KAAK;AACD,aAAO,WAAY;AACf,eAAOM,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAG,MAAM,MAAM,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,MAC1D;AAAA,IACL,KAAK;AACD,aAAO,WAAY;AACf,eAAOO,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAG,MAAM,MAAM,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,MAC9D;AAAA,IACL,KAAK;AACD,aAAO,WAAY;AACf,eAAOQ,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAG,MAAM,MAAM,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,MAClE;AAAA,EACb;AAEA;AA0DO,SAASS,EAAKX,GAAGE,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAIC,GAAI;AACpD,UAAQ,UAAU,QAAM;AAAA,IACpB,KAAK;AACD,aAAOT;AAAA,IACX,KAAK;AACD,aAAOE,EAAGF,CAAC;AAAA,IACf,KAAK;AACD,aAAOG,EAAGD,EAAGF,CAAC,CAAC;AAAA,IACnB,KAAK;AACD,aAAOI,EAAGD,EAAGD,EAAGF,CAAC,CAAC,CAAC;AAAA,IACvB,KAAK;AACD,aAAOK,EAAGD,EAAGD,EAAGD,EAAGF,CAAC,CAAC,CAAC,CAAC;AAAA,IAC3B,KAAK;AACD,aAAOM,EAAGD,EAAGD,EAAGD,EAAGD,EAAGF,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,IAC/B,KAAK;AACD,aAAOO,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,IACnC,KAAK;AACD,aAAOQ,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,IACvC,KAAK;AACD,aAAOS,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGD,EAAGF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,IAC3C,SAAS;AAEL,eADIY,IAAM,UAAU,CAAC,GACZhB,IAAI,GAAGA,IAAI,UAAU,QAAQA;AAClC,QAAAgB,IAAM,UAAUhB,CAAC,EAAEgB,CAAG;AAE1B,aAAOA;AAAA,IACnB;AAAA,EACA;AACA;AAiCO,IAAIC,IAAO,SAAUC,GAAOC,GAAM;AACrC,MAAIC,IAAc,OAAOF,KAAU,WAAW,SAAUG,GAAM;AAAE,WAAOA,EAAK,UAAUH;AAAA,EAAQ,IAAGA;AACjG,SAAO,WAAY;AACf,QAAIG,IAAO,MAAM,KAAK,SAAS;AAC/B,WAAID,EAAY,SAAS,IACdD,EAAK,MAAM,MAAME,CAAI,IAEzB,SAAUC,GAAM;AAAE,aAAOH,EAAK,MAAM,QAAQvB,GAAc,CAAC0B,CAAI,GAAGD,GAAM,EAAK,CAAC;AAAA,IAAI;AAAA,EAC5F;AACL,GCtUWE,KAAO,EAAE,MAAM,OAAQ,GAEvBC,KAAO,SAAUpB,GAAG;AAAE,SAAQ,EAAE,MAAM,QAAQ,OAAOA,EAAC;AAAM,GAK5DqB,KAAS,SAAUC,GAAI;AAAE,SAAOA,EAAG,SAAS;AAAS,GAIrDC,KAAO,SAAU,GAAG;AAAE,SAAQ,EAAE,MAAM,QAAQ,MAAM,EAAC;AAAM,GAE3DC,KAAQ,SAAUxB,GAAG;AAAE,SAAQ,EAAE,MAAM,SAAS,OAAOA,EAAC;AAAM,GCX9DuB,IAAOE,IAQPD,IAAQE,IAKRC,KAAwB,gBAAAd,EAAK,GAAG,SAAUS,GAAIM,GAAG;AAAE,SAAQP,EAAOC,CAAE,IAAIA,IAAKM,EAAEN,EAAG,KAAK;AAAG,CAAE,GAsR5FO,KAAM,SAAUD,GAAG;AAAE,SAAO,SAAUE,GAAI;AACjD,WAAOT,EAAOS,CAAE,IAAIA,IAAKN,EAAMI,EAAEE,EAAG,KAAK,CAAC;AAAA,EAC9C;AAAI,GA4POC,KAAQ,SAAUH,GAAGI,GAAG;AAAE,SAAO,SAAUF,GAAI;AACtD,WAAOT,EAAOS,CAAE,IAAIP,EAAKK,EAAEE,EAAG,IAAI,CAAC,IAAIN,EAAMQ,EAAEF,EAAG,KAAK,CAAC;AAAA,EAC5D;AAAI,GAOOG,KAAU,SAAUL,GAAG;AAAE,SAAO,SAAUE,GAAI;AACrD,WAAOT,EAAOS,CAAE,IAAIP,EAAKK,EAAEE,EAAG,IAAI,CAAC,IAAIA;AAAA,EAC3C;AAAI,GAsMOT,IAASa,IAgBTC,KAAS,SAAUC,GAAQC,GAAS;AAC3C,SAAO,SAAUf,GAAI;AACjB,WAAOD,EAAOC,CAAE,IAAIc,EAAOd,EAAG,IAAI,IAAIe,EAAQf,EAAG,KAAK;AAAA,EACzD;AACL,GAOWgB,KAAQH,IAmCRI,IAAQJ,IAORK,KAAOD,GA0RPE,IAAW,SAAUb,GAAGc,GAAS;AACxC,MAAI;AACA,WAAOlB,EAAMI,GAAG;AAAA,EACxB,SACWe,GAAG;AACN,WAAOpB,EAAKmB,EAAQC,CAAC,CAAC;AAAA,EAC9B;AACA,GA0MWC,KAASjB,IAOTkB,KAAQlB,ICxyCRR,KAAO2B,IAOP1B,KAAO2B,IAyiBPC,KAAS,SAAUlB,GAAI;AAAE,SAAOA,EAAG,SAAS;AAAS,GASrDK,KAAS,SAAUc,GAAQC,GAAQ;AAC1C,SAAO,SAAU5B,GAAI;AACjB,WAAO0B,GAAO1B,CAAE,IAAI2B,EAAQ,IAAGC,EAAO5B,EAAG,KAAK;AAAA,EACjD;AACL,GAmCWiB,KAAQJ;ACjnBZ,SAASX,GAAM2B,GAAG;AACrB,SAAOlD,EAAKmD,GAASD,EAAE,EAAE;AAC7B;AACO,SAAS5B,GAAK4B,GAAG;AACpB,SAAOlD,EAAKoD,GAAQF,EAAE,EAAE;AAC5B;AAoCO,SAASxB,GAAQ2B,GAAG;AACvB,SAAO,SAAUhC,GAAIM,GAAG;AAAE,WAAO0B,EAAE,MAAMhC,GAAI,SAAUqB,GAAG;AAAE,aAAQY,EAASZ,CAAC,IAAIW,EAAE,GAAGX,CAAC,IAAIf,EAAEe,EAAE,KAAK;AAAA,IAAK,CAAA;AAAA,EAAI;AAClH;AASO,SAASa,GAAQL,GAAG;AACvB,SAAO,SAAUjC,GAAMU,GAAGI,GAAG;AAAE,WAAOmB,EAAE,IAAIjC,GAAMuC,GAAQ7B,GAAGI,CAAC,CAAC;AAAA,EAAI;AACvE;AAgBO,SAASO,GAAMY,GAAG;AACrB,SAAO,SAAUf,GAAQC,GAAS;AAAE,WAAO,SAAUf,GAAI;AAAE,aAAO6B,EAAE,IAAI7B,GAAIoC,EAAQtB,GAAQC,CAAO,CAAC;AAAA,IAAE;AAAA,EAAK;AAC/G;ACXA,IAAIsB,KAAO,SAAU7B,GAAIF,GAAG;AAAE,SAAOjB,EAAKmB,GAAID,GAAID,CAAC,CAAC;AAAI,GACpDgC,KAAS,SAAUC,GAAK/B,GAAI;AAAE,SAAOnB,EAAKkD,GAAKC,GAAGhC,CAAE,CAAC;AAAI,GASlDD,KAAM,SAAUD,GAAG;AAAE,SAAO,SAAUE,GAAI;AAAE,WAAO,WAAY;AACtE,aAAO,QAAQ,UAAU,KAAKA,CAAE,EAAE,KAAKF,CAAC;AAAA,IAC5C;AAAA,EAAI;AAAG,GAIIkC,KAAK,SAAUhC,GAAI;AAAE,SAAO,SAAU+B,GAAK;AAAE,WAAO,WAAY;AACvE,aAAO,QAAQ,IAAI,CAAC,QAAQ,QAAS,EAAC,KAAKA,CAAG,GAAG,QAAQ,QAAO,EAAG,KAAK/B,CAAE,CAAC,CAAC,EAAE,KAAK,SAAUiC,GAAI;AAC7F,YAAInC,IAAImC,EAAG,CAAC,GAAG,IAAIA,EAAG,CAAC;AACvB,eAAOnC,EAAE,CAAC;AAAA,MAClB,CAAK;AAAA,IACL;AAAA,EAAI;AAAG,GAKIoC,KAAK,SAAUhE,GAAG;AAAE,SAAO,WAAY;AAAE,WAAO,QAAQ,QAAQA,CAAC;AAAA,EAAE;AAAK,GAKxE2B,KAAwB,gBAAAd,EAAK,GAAG,SAAUS,GAAIM,GAAG;AACxD,SAAO,WAAY;AACf,WAAO,QAAQ,QAAO,EACjB,KAAKN,CAAE,EACP,KAAK,SAAUtB,GAAG;AAAE,aAAO4B,EAAE5B,CAAC,EAAG;AAAA,KAAG;AAAA,EAC5C;AACL,CAAC,GAUUiE,KAAM,QA+BNC,KAAU;AAAA,EACjB,KAAKD;AAAA,EACL,KAAKN;AACT,GAwBWQ,KAAU;AAAA,EAEjB,IAAIH;AACR,GAyEWI,KAAQ;AAAA,EACf,KAAKH;AAAA,EACL,KAAKN;AAAA,EACL,IAAIK;AAAA,EACJ,IAAIJ;AAAA,EACJ,OAAOjC;AACX,GCnMWJ,KAAqB8C,gBAAAA,GAAQC,EAAS,GAKtC9C,KAAsB+C,gBAAAA,GAASD,EAAS,GAuDxC/B,KACGiC,gBAAAA,GAASC,EAAS,GAqQrBjB,KAAwB,gBAAA3C,EAAK,GAAG6D,GAAWD,EAAS,CAAC,GAoDrD9C,KAAwB,gBAAAd,EAAK,GAAG8D,GAAWC,EAAO,CAAC,GAi4BnD/B,KAAQlB,IAORiB,KAASjB;ACpzCb,MAAMkD,WAA+BC,EAE1C,0BAA0B,CAACC,GAAQC,MAAY;AAAA,EAC/C,WAAWD,CAAM,yCAAyCC,CAAO;AACnE,CAAC,EAAE;AACH;AAEO,MAAMC,WAAwCH,EAEnD,mCAAmC,CAACC,GAAQG,GAAOF,MAAY;AAAA,EAC/D,cAAcE,CAAK,SAASH,CAAM,gDAAgDC,CAAO;AAC3F,CAAC,EAAE;AACH;AAEO,MAAMG,WAAkCC;AAAA,EAI7C;AAAA,EACA,CAAAC,OAAW,EAAE,QAAAA;EACb,CAAUA,MAAA;AAAA,IACR;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,GAAGA,EAAO,IAAI,CAAC,EAAE,QAAAC,GAAQ,OAAAC,QAChB,WAAWD,CAAM,MAAMC,aAAiB,QAAQA,EAAM,UAAU,OAAOA,CAAK,CAAC,EACrF;AAAA,IACH,EAAE,KAAK;AAAA,CAAI;AAAA,EAAA;AAEf,EAAE;AACF;AAEO,MAAMC,WAAiCV,EAE5C,4BAA4B,CAACW,GAAcC,MAAU;AAAA,EACrD,oCAAoCD,CAAY;AAAA,EAChD,EAAE,OAAAC,EAAM;AACV,CAAC,EAAE;AACH;AAEa,MAAAC,WAAwBb,EAAW,iBAAiB,EAAE;AACnE;AAEO,MAAMc,WAAsCd;AAAA,EACjD;AAAA,EACA,CAASS,MAAA,CAAC,0BAA0BA,CAAK,EAAE;AAC7C,EAAE;AACF;ACzCA,MAAMM,IAAsB;AAa5B,SAASC,EAAkBC,GAA2B;AACpD,SAAOA,EAEJ,QAAQ,eAAe,EAAE,EAGzB,QAAQ,SAAS,GAAG;AACzB;AAKO,MAAMC,KAGT/F,EAAKgG,GAA2BC,GAASC,EAAwB,CAAC,GAKzDC,KACXC,EAAaL,EAAsB,GAKxBM,KACXrG,EAAKgG,GAA2BM,GAAM,CAAOC,MAAA;AAC3C,QAAMC,IAAI,IAAI,gBAAgBD,CAAG,EAAE,IAAI,cAAc;AACrD,SAAOC,IAAIC,GAAOD,CAAC,IAAIE;AACzB,CAAC,CAAC,GAKSC,KAAgD3G;AAAA,EAC3DqG;AAAA,EACAO,GAAO,CAAOC,MAAA;AACN,UAAAA;AAAA,EAAA,GACL,OAAKL,CAAC;AAAA,EACTM,GAAQ,MAAM;AAAA,KAAW,OAAKN,CAAC;AACjC;AAKO,SAASR,IAA4E;AAC1F,QAAMZ,IAA+C,CAAC;AAE3C,aAAA,CAAC2B,GAAU1B,CAAM,KAAK;AAAA;AAAA;AAAA;AAAA,IAI/B,CAAC,MAAMQ,EAAkB,OAAO,SAAS,IAAI,GAAG,sBAAsB;AAAA;AAAA,IAEtE,CAAC,MAAM;AACL,YAAMmB,IAAkB,YAAY,iBAAiB,YAAY,EAAE,CAAC;AAC7D,aAAAA,KAAmBnB,EAAkBmB,EAAgB,IAAI;AAAA,OAC/D,gCAAgC;AAAA;AAAA,IAEnC,CAAC,MAAMC,GAAwBrB,CAAmB,GAAG,eAAe;AAAA,EAAA,GAC1D;AACV,UAAMY,IAAIO,EAAS;AACnB,QAAI,CAACP,GAAG;AACC,MAAApB,EAAA,KAAK,EAAE,QAAAC,GAAQ,OAAO,IAAI,MAAM,iBAAiB,GAAG;AAC3D;AAAA,IAAA;AAEF,UAAM6B,IAAaxG;AAAA,MACjBwF,GAAyBM,CAAC;AAAA,MAC1BW,GAAQ,CAAON,MAAAA,GAAK,MAAM,EAAa;AAAA,IACzC;AACI,QAAA,OAAOK,KAAe,WAAW;AACnC,MAAA9B,EAAO,KAAK,EAAE,QAAAC,GAAQ,OAAO6B,GAAY;AACzC;AAAA,IAAA;AAEF,WAAAE,GAAgBxB,GAAqBY,CAAC,GAC/BrD,EAAQqD,CAAC;AAAA,EAAA;AAElB,SAAOpD,EAAO,IAAI8B,GAA0BE,CAAM,CAAC;AACrD;AAKa,MAAAiC,KAA0BjB,EAAaJ,CAAyB;AC/C7D,SAAAsB,GACdC,GACAC,GAMA;AAiCM,QAAAC,wBAAyB,IAAgC,GAEzDC,IAAWC,GAEwB,GAEnCC,IAAgB,CACpBC,GACAC,GACAC,IAAO,OACJ;AACH,UAAMC,IAA2BP,EAAmB,IAAII,CAAK,yBAAS,IAAI;AACvD,IAAAJ,EAAA,IAAII,GAAOG,CAAW;AAEzC,UAAMC,IAAWD,EAAY,IAAIF,CAAO,KAAK,CAAC;AAClC,IAAAE,EAAA,IAAIF,GAASG,CAAQ;AAEjC,UAAMC,IAAQD,EAAS,UAAU,OAAQE,EAAK,CAAC,MAAMJ,CAAI;AACzD,QAAIG,KAAS,MAEXR,EAAQ,IAAIG,GAAOI,EAASC,CAAK,EAAE,CAAC,CAAC,GAG5BD,EAAA,OAAOC,GAAO,CAAC,GAGpB,CAACD,EAAS,WACZD,EAAY,OAAOF,CAAO,GACtB,CAACE,EAAY,QAAM;AACrB,YAAMI,IAAWX,EAAmB;AACpC,MAAAA,EAAmB,OAAOI,CAAK,GACnBO,KAAA,CAACX,EAAmB,QAAQD,EAAQ;AAAA,IAAA;AAAA,EAIxD;AAEO,SAAA;AAAA,IACL,GAAGK,GAAsBC,GAAkCC,GAAgB;AAExE,OAAAN,EAAmB,QAAQF,EAAQ;AAEpC,YAAMc,IAAU,MAAM;AAChB,QAAAT,EAAAC,GAAcC,GAASC,CAAI;AAAA,MACjC,GAEMO,IAAkB,IAAItH,MAAgB;AAC1C,QAAA+G,KAAQM,EAAQ,GACZR,MAAU,MACJC,EAAA,EAAE,MAAM9G,EAAK,CAAC,GAAG,SAASA,EAAK,CAAC,GAAG,IAE3C8G,EAAQ,GAAG9G,CAAI;AAAA,MAEnB;AAEQ,MAAA0G,EAAA,GAAGG,GAAOS,CAAe;AAGjC,YAAMN,IAA2BP,EAAmB,IAAII,CAAK,yBAAS,IAAI;AACvD,MAAAJ,EAAA,IAAII,GAAOG,CAAW;AAEzC,YAAMC,IAAWD,EAAY,IAAIF,CAAO,KAAK,CAAC;AAClC,aAAAE,EAAA,IAAIF,GAASG,CAAQ,GACjCA,EAAS,KAAK,CAACK,GAAiBP,KAAQ,EAAK,CAAC,GAEvCM;AAAA,IACT;AAAA,IACA,KAAAT;AAAA;AAAA,IAEA,MAAMF,EAAQ;AAAA,IACd,QAAQ;AACN,YAAMU,IAAWX,EAAmB;AACpC,MAAAC,EAAQ,IAAI,MAAM,GAClBD,EAAmB,MAAM,GACzBW,KAAYZ,EAAQ;AAAA,IAAA;AAAA,EAExB;AACF;AC3HgB,SAAAe,EAAUC,GAAmBC,GAA2B;AAC/D,SAAA,cAAc,IAAI,aAAa,WAAW;AAAA,IAC/C,MAAM,KAAK,UAAU,EAAE,WAAAD,GAAW,WAAAC,GAAW;AAAA;AAAA;AAAA;AAAA,IAI7C,QAAQ,OAAO;AAAA,EAAA,CAChB,CAAC;AACJ;ACvDA,MAAMC,IAASC,EAAO,EAAK,GAIrBC,IAAgBD,EAAO,0BAA0B,GAEjDE,KAAqC,CAAShB,MAAA;AAC3C,EAAAiB,IAAE,IAAI,mBAAmBjB,CAAK;AACvC,GAQakB,KAAQC,GAASN,CAAM;AAS7B,SAASO,GAAS/J,GAAsB;AACzC,EAAAA,MAAUwJ,QACZA,EAAO,IAAIxJ,CAAK,IACfA,IAAQgK,IAAKtB,IAAK,KAAKiB,EAAe;AAE3C;AAUa,MAAAM,KAAeH,GAASJ,CAAa;AAU3C,SAASQ,GAAgBC,GAAgB;AAC9C,EAAAT,EAAc,IAAIS,CAAM,GACjBP,IAAE,IAAI,yBAAyBO,CAAM;AAC9C;AAQa,MAAAC,IAAkBX,EAAoB,IAAI3H,MAAS;AACvD,SAAA,OAAO,YAAY,GAAGA,CAA0C;AACzE,CAAC,GAKY8H,IAASH,EAAeY,GAAa,UAAU;AAAA,EAC1D,SAAS;AAAA,EACT,WAAW;AAAA,EACX,WAAWR;AACb,CAAC,CAAC;AAMK,SAASS,KAAe;AACtB,EAAAC,GAAA,GACN,CAAAH,GAAiBV,GAAeO,IAAcT,GAAQK,IAAOD,CAAM,EAAE,QAAQ,CAAKY,MAAA;AACjF,IAAAA,EAAE,SAAS,GACA,WAAAA,KAAKA,EAAE,MAAM;AAAA,EAAA,CACzB;AACH;AC9EgB,SAAAC,EACdC,GACAC,GACAC,GACM;AACA,QAAAC,IAA2B,CAACD,CAAS,GAErCE,IAAWJ,EAAIC,CAAY;AAC7B,EAAA,OAAOG,KAAa,cACtBD,EAAkB,KAAKC,CAAQ;AAG3B,QAAAC,IAAwB,IAAIjJ,MAAc;AAC9C,IAAA+I,EAAkB,QAAQ,CAAA1K,MAAMA,EAAG,GAAG2B,CAAI,CAAC;AAAA,EAC7C,GAGMkJ,IAAmC,OAAO,OAAO,IAAIlJ,MAAc;AACvE,IAAAiJ,EAAsB,GAAGjJ,CAAI;AAAA,EAAA,GAC5B;AAAA;AAAA,IAED,SAAS;AACD,YAAA,EAAE,QAAQmJ,EAAA,IAAaJ;AAC7B,UAAII,MAAa,GAAG;AAElB,eAAOP,EAAIC,CAAY;AACvB;AAAA,MAAA;AAEF,UAAIM,MAAa,GAAG;AAElB,QAAAC,EAAqBR,GAAKC,GAAcE,EAAkB,CAAC,CAAC;AAC5D;AAAA,MAAA;AAKF,MAAAA,EAAkB,QAAQ,CAAC,GACNK,EAAAR,GAAKC,GAAcI,CAAqB;AAAA,IAAA;AAAA,EAC/D,CACD;AAID,EAAAI;AAAA,IACET;AAAA,IACAC;AAAA,IACA,MAAMK;AAAA,IACN,CAAAhL,MAAS6K,EAAkB,KAAK7K,CAAK;AAAA,EACvC;AACF;AAQgB,SAAAoL,EAAwBV,GAAUW,GAAoB;AAC9D,QAAArL,IAAQ0K,EAAIW,CAAI;AACtB,EAAAF,GAAsBT,GAAKW,GAAM,MAAMrL,GAAO,CAAKsH,MAAA;AAC1C,WAAA,QAAQA,CAAC,EAAE,QAAQ,CAAC,CAACgE,GAAQC,CAAQ,MAAM;AAChD,MAAAvL,EAAMsL,CAAM,IAAIC;AAAA,IAAA,CACjB;AAAA,EAAA,CACF;AACH;AASO,SAASJ,GACdT,GACAW,GACAG,GACAC,GACA;AACO,SAAA,eAAef,GAAKW,GAAM;AAAA,IAC/B,YAAY;AAAA,IACZ,cAAc;AAAA,IACd,KAAAG;AAAA,IACA,KAAAC;AAAA,EAAA,CACD;AACH;AAQgB,SAAAP,EAAqBR,GAAUW,GAAcrL,GAAkB;AACtE,SAAA,eAAe0K,GAAKW,GAAM;AAAA,IAC/B,YAAY;AAAA,IACZ,cAAc;AAAA,IACd,UAAU;AAAA,IACV,OAAArL;AAAA,EAAA,CACD;AACH;AC9FA,MAAM0L,KAAe;AAAA,EACnB,yBAAyBxL,EAAY;AAAA,IACnC,QAAQyL,EAAO;AAAA,IACf,MAAMC,EAAQD,EAAQ,CAAA;AAAA,EAAA,CACvB;AAAA,EACD,uBAAuBzL,EAAY;AAAA,IACjC,QAAQyL,EAAO;AAAA,IACf,QAAQE,EAASC,IAAS;AAAA,IAC1B,OAAOD,EAASF,EAAQ,CAAA;AAAA,EAAA,CACzB;AAAA,EACD,cAAcC;AAAA,IACZ1L,EAAY,EAAE,WAAW0L,EAAQD,KAAU,MAAA;AAAA,KAAe,GAAG;AAAA,IAC7D,CAAA;AAAA,EACF;AAAA,EACA,kBAAkBC;AAAA,IAChB1L,EAAY;AAAA,MACV,QAAQ6L,EAAO;AAAA,MACf,OAAOH,EAAQG,EAAU,GAAA,MAAM,OAAO,UAAU;AAAA,MAChD,iBAAiBC,EAAQ;AAAA,MACzB,aAAaA,EAAQ;AAAA,IAAA,CACtB;AAAA;AAAA;AAAA,IAGD,OAAO;AAAA,MACL,QAAQ,OAAO;AAAA,MACf,iBAAiB;AAAA,MACjB,aAAa;AAAA,IACf;AAAA,EACF;AAAA,EACA,eAAe9L,EAAY;AAAA,IACzB,cAAc+L,GAAY;AAAA,EAC3B,CAAA;AACH;AAEA,SAASC,EAAsBvD,GAA2B;AAEpD,MAAAA,EAAM,WAAW,OAAO;AAC1B;AAIE,MAAAwD;AACA,MAAA;AACF,IAAAA,IAAUC,EAAMC,GAAiBC,GAAA,CAAiB,GAAG3D,EAAM,IAAI;AAAA,EAAA,QACzD;AAEN;AAAA,EAAA;AAGI,QAAA,EAAE,WAAAW,GAAW,WAAAC,EAAA,IAAc4C,GAC3BI,IAASb,GAAapC,CAAsC;AAE9D,MAAAkD;AACA,MAAA;AACF,IAAAA,IAAOD,IAASH,EAAMG,GAAQhD,CAAS,IAAIA;AAAA,WACpChD,GAAO;AACd,WAAOqD,EAAS,EAAA;AAAA,MACd;AAAA,QACE,qCAAqCN,CAAS;AAAA,QAC9C;AAAA,QACA;AAAA,MAAA,EACA,KAAK;AAAA,CAAI;AAAA,MACX6C;AAAA,MACA5F;AAAA,IACF;AAAA,EAAA;AAEF,EAAAkG,GAAKnD,GAAkBkD,CAAI;AAC7B;AAEa,MAAA;AAAA,EACX,IAAAxC;AAAA,EACA,KAAAtB;AAAA,EACA,MAAA+D;AAAA,EACA,OAAOlC;AACT,IAAInC;AAAA,EACF,MAAM;AACJ,UAAMsE,IAAM;AAgBZ,KAACA,EAAI,sBAAsBA,EAAI,oBAAoB,CAAA,IAClCjC,EAAAiC,EAAI,mBAAmB,gBAAgBrD,CAAS,GACjE+B,EAAwBsB,GAAK,mBAAmB,GAGhD,CAACA,EAAI,aAAaA,EAAI,WAAW,CAAA,IACjC,CAACA,EAAI,SAAS,YAAYA,EAAI,SAAS,UAAU,KACjDjC,EAAiBiC,EAAI,SAAS,SAAS,gBAAgBrD,CAAS,GACxC+B,EAAAsB,EAAI,UAAU,SAAS,GAG9BjC,EAAAiC,GAAK,kCAAkCrD,CAAS,GAK1D,OAAA,iBAAiB,WAAW6C,CAAqB;AAAA,EAC1D;AAAA,EACA,MAAM;AACJ;AAAA,MACE,CAAC,gCAAgC;AAAA,MACjC,CAAC,qBAAqB,cAAc;AAAA,MACpC,CAAC,YAAY,WAAW,cAAc;AAAA,IAAA,EACtC,QAAQ,CAAQS,MAAA;AAChB,YAAMD,IAAM;AAIR,UAAAE,IAAyC,CAAC,QAAWF,CAAG;AAC5D,iBAAWzD,KAAQ0D;AAEb,YADKC,IAAA,CAACA,EAAO,CAAC,GAAGA,EAAO,CAAC,EAAE3D,CAAI,CAAC,GAChC,CAAC2D,EAAO,CAAC;AACX;AAGE,YAAA,CAACC,GAAmBC,CAAY,IAAIF;AAC1C,MAAI,YAAYE,MACdA,EAAa,OAAO,GAElBD,KACGA,MAAsBH,KACtB,CAAC,OAAO,KAAKG,CAAiB,EAAE,UAE5B,OAAAH,EAAIC,EAAK,CAAC,CAAC;AAAA,IAEtB,CACD,GACM,OAAA,oBAAoB,WAAWT,CAAqB;AAAA,EAAA;AAE/D,GC1Jaa,KAA2B,IAAIjL,MACnCsI,EAAA,EAAkB,GAAGtI,CAA0C;AC+BxD,SAAAkL,GACd1D,GACAC,GACM;AACN,EAAA/H;AAAA,IACEyL;AAAA;AAAA,MAEE3D;AAAA,MACAC;AAAA,IACF;AAAA,IACA2D,GAAU,CAAOvF,MAAA;AACT,YAAAA;AAAA,IACP,CAAA;AAAA,EACH;AACF;AA4BgB,SAAAsF,EACd3D,GACAC,GACgC;AACzB,EAAAK,EAAA,EAAE,IAAI,kBAAkBL,IAAY,EAAE,WAAAD,GAAW,WAAAC,EAAU,IAAI,EAAE,WAAAD,GAAW;AAEnF,QAAM6D,IAAI,QACJhB,IAAU,KAAK,UAAU,EAAE,WAAA7C,GAAW,WAAAC,GAAW;AAGvD,SAAInJ,QACU2M,GAAAZ,GAASlC,IAAc,GAC5BhG,EAAQ,MAAS,KAItBlE,GAAgBoN,CAAC,KACnBA,EAAE,qBAAqB,UAAU7D,GAAW,KAAK,UAAUC,CAAS,CAAC,GAC9DtF,EAAQ,MAAS,KAItBhE,EAAGC,EAAY,EAAE,UAAUA,EAAY,EAAE,QAAQC,KAAM,CAAA,GAAG,GAAGgN,CAAC,KAC9DA,EAAA,SAAS,OAAOhB,CAAO,GAClBlI,EAAQ,MAAS,KAInBC,EAAO,IAAIsC,IAAiB;AACrC;ACRO,SAAS4G,EAKdxH,GACAyH,GACAC,IAA+D,CAAA,GACD;AACxD,QAAA;AAAA;AAAA,IAEJ,SAAAC,IAAU,MAAM;AAAA,IAChB,WAAAP,IAAYC;AAAA,EAAA,IACVK,GAIEE,IAAS/D,EAAwC,GACjD,CAACgE,GAAYtE,CAAO,IAAIuE,GAAkB;AAG/C,GAAA,MAAM,QAAQL,CAAa,IAAIA,IAAgB,CAACA,CAAa,GAAG,QAAQ,CAAS1E,MAAA;AAIhF,IAAA8E;AAAA,MACEzD,EAAGrB,GAAO,CAAWgF,MAAA;AACb,cAAAC,IAAgB,MAAM,QAAQP,CAAa;AAE/C,QACKE,EADLK,IACsD,EAAE,OAAAjF,GAAO,SAAAgF,MACZA,CADqB,KAGxEH,EAAO,IAAI;AAAA,UACRI,IAAgB,EAAE,OAAAjF,GAAO,SAAAgF,MAAYA;AAAA,QAAA,CACvC;AAAA,MAEJ,CAAA;AAAA,IACH;AAAA,EAAA,CACD;AACK,QAAAE,IAAc,CAAI7N,OACdmJ,EAAA,GACDnJ;AAGF,SAAAwB;AAAA,IACL,YAAYwL,EAAUpH,GAAgB0H,EAAgB,MAAM;AAAA,IAC5DQ,GAAU,MACDC,GAAgD,CAACC,GAASC,GAAGC,MAAY;AAI9E,YAAM1B,IAAOgB,EAAO;AACpB,UAAIhB;AACK,eAAAwB,EAAQxB,EAAK,CAAC,CAAC;AAGlB,YAAA2B,IAAW,CAAC3B,MAA0C;AAC1D,QAAIA,KACMA,EAAAA,EAAK,CAAC,CAAC;AAAA,MAEnB,GACM4B,IAAQ,MAAM;AAClB,QAAAZ,EAAO,MAAMW,CAAQ;AAAA,MACvB;AACA,MAAAX,EAAO,IAAIW,CAAQ,GACXD,EAAA,GAAG,aAAaE,CAAK;AAAA,OAC5Bd,CAAO,CACX;AAAA,IACDe,GAAWR,GAAaA,CAAW;AAAA,EACrC;AACF;AA6BgB,SAAAS,GACd1I,GACAyH,GACAC,GACkC;AAClC,QAAM,EAAE,WAAAN,MAAcM,KAAW,CAAC;AAE3B,SAAAiB;AAAA;AAAA,IAELnB,EAAWxH,GAAQyH,GAAe;AAAA,MAChC,GAAGC;AAAA,MACH,WAAWN,IACP,IAAIlL,MAAgB;AAChB,YAAA;AAEF,iBAAAkL,EAAU,GAAGlL,CAAI,GACVmC,EAAQ,MAAS;AAAA,iBACjBT,GAAG;AACH,iBAAAU,EAAOV,CAAC;AAAA,QAAA;AAAA,MACjB,IAEAyJ;AAAA,IACL,CAAA;AAAA,EACH;AACF;AC3MgB,SAAAuB,GACdC,GACAnB,GACkC;AAClC,QAAMoB,IAAQC;AAAA;AAAA,IAEZF;AAAA,IACAnB;AAAA,EACF;AACO,SAAA,OAAOoB,KAAU,aACpBE,GAAc,GAAG,MAAML,EAAkBG,CAAK,CAAC,IAC/CA;AACN;AAwBgB,SAAAC,GACdF,GACAnB,GAC8C;AACxC,QAAAuB,IAAW9O,GAAgB,MAAM;AACvC,MAAI,CAAC0O;AACI,WAAAI,KAAYrN,EAAKsF,EAA6B,GAAAvC,EAAQ,MAAM,IAAO,MAAM,EAAI,CAAC;AAEvF,MAAIsK;AACK,WAAAC,GAAS,EAAI;AAEtB,QAAM,EAAE,SAAAC,IAAU,IAAI,IAAIzB,KAAW,CAAC;AAE/B,SAAA9L;AAAA,IACL4L,EAAW,yBAAyB,iBAAiB,EAAE,GAAGE,GAAS,SAAAyB,GAAS;AAAA,IAC5EC;AAAAA,MACE,CACE5I,MAAA6I,GAAa,GAAG7I,CAAK,KAAKI,GAAgB,GAAGJ,CAAK,IAC9CnC,EAAQ,EAAK,IACbC,EAAOkC,CAAK;AAAA,MAElB,MAAMnC,EAAQ,EAAI;AAAA,IAAA;AAAA,EAEtB;AACF;ACrDO,SAASiL,GAAgB,EAAE,cAAA5I,GAAc,SAAA6I,GAAS,kBAAAC,EAAiB,IAsCtE,CAAA,GAAU;AACZ,MAAI9I,GAAc;AAGhB,UAAM+I,IACJ,OAAO/I,KAAiB,YAAYA,aAAwB,kBACxDA,EAAa,SAAS;AAAA;AAAA;AAAA;AAAA,MAKtBgJ,GAA2B,EAAE,GAAGhJ,GAAc,cAAc,QAAW,KAEpEA,EAAa,eAAe,iBAAiB,mBAAmBA,EAAa,aAAa,SAAU,CAAA,CAAC,KAAK;AAAA;AAI/G,QAAA;AACF,MAAAiJ,GAAuBF,CAAiB;AAAA,aACjC7L,GAAG;AACJ,YAAA,IAAI6C,GAAyBgJ,GAAmB7L,CAAC;AAAA,IAAA;AAEzD,IAAA0E,GAAgB,gBAAgBmH,CAAiB;AAAA,EAAA;AAKnD,MAAIjP,MAAY;AACd,QAAI,CAAC+O;AACH;AAGF,IAAIC,KACFhF,EAAgB,MAAM;AAGxB,UAAMoF,IAAWpF,EAAgB;AACjB,IAAAA,EAAA,IAAI,IAAItI,MAAS;AACzB,YAAA,CAACqK,CAAO,IAAIrK,GACZ2N,IAAO,MAAM;AAChB,QAAAD,EAAiB,GAAG1N,CAAI;AAAA,MAC3B;AAII,UAAA;AACF,cAAM0K,IAAOJ,EAAMC,GAAiBC,GAAiB,CAAA,GAAGH,CAAO;AACvD,QAAAgD,EAAA,EAAE,MAAM3C,EAAK,WAAW,QAAQA,EAAK,aAAaiD,CAAI;AAAA,MAAA,QACxD;AACD,QAAAA,EAAA;AAAA,MAAA;AAAA,IACP,CACD;AACD;AAAA,EAAA;AAII,QAAAC,IAAS,OAAe,wBAAwB,CAAC,GACjDC,IAAqBD,EAAM,cAAc,MAAM;AAAA;AACpD,SAAe,uBAAuB;AAAA,IACrC,GAAGA;AAAA,IACH,UAAUpG,GAAmBC,GAAmB;AAC9C,YAAMkG,IAAO,MAAM;AACjB,QAAAE,EAAmBrG,GAAWC,CAAS;AAAA,MACzC;AACA,MAAA4F,IACIA,EAAQ;AAAA,QACR,MAAM7F;AAAA,QACN,QAAQC,IAAY,KAAK,MAAMA,CAAS,IAAI;AAAA,MAAA,GAC3CkG,CAAI,IACLA,EAAK;AAAA,IAAA;AAAA,EAEb,GAEO7F,EAAA,EAAE,IAAI,wDAAwD;AACvE;ACzIO,SAASgG,GAAeC,GAAiC;AAC9D,SAAO,CAAC,EAAE,QAAAC,QAAaA,MAAWD;AACpC;ACDA,MAAME,IAAW;AAAA,EACf,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,KAAK;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,KAAK,CAAC,oBAAoB;AAAA,EAC1B,KAAK;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA,EAAE,QAAQ,qBAAqB,OAAO,mBAAmB;AAAA,EAC3D;AAAA,EACA,KAAK,CAAC,6BAA6B;AAAA,EACnC,KAAK;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA,EAAE,QAAQ,4BAA4B,OAAO,QAAQ;AAAA,EACvD;AAAA,EACA,QAAQ,CAAC,+BAA+B;AAAA,EACxC,KAAK;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,KAAK;AAAA,IACH,EAAE,QAAQ,qBAAqB,OAAO,cAAc;AAAA,IACpD,EAAE,QAAQ,iBAAiB,OAAO,cAAc;AAAA,EAClD;AAAA,EACA,KAAK,CAAC,8BAA8B;AAAA,EACpC,KAAK,CAAC,wBAAwB;AAAA,EAC9B,QAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA,EAAE,QAAQ,6BAA6B,OAAO,mBAAmB;AAAA,EACnE;AAAA,EACA,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,KAAK,CAAC,uBAAuB;AAC/B;AAmBgB,SAAAC,EAAkBpK,GAAoBG,GAAgC;AAE7E,SADU,OAAO,KAAKgK,CAAQ,EACrB,KAAK,CAAWlK,MACvBkK,EAASlK,CAAO,EAAE,KAAK,CAAQoD,MAChClD,IACK,OAAOkD,KAAS,YAClBA,EAAK,WAAWrD,KAChBqD,EAAK,UAAUlD,IAEfkD,MAASrD,CACjB,CACF,KAAK;AACR;AC5HA,SAASqK,EAAMpP,GAAsB;AACnC,SAAOA,EAAE,MAAM,GAAG,EAAE,IAAI,MAAM;AAChC;AAUgB,SAAAqP,GAAgBrP,GAAYsP,GAAoB;AACxD,QAAAC,IAASH,EAAMpP,CAAC,GAChBwP,IAASJ,EAAME,CAAC,GAChBG,IAAM,KAAK,IAAIF,EAAO,QAAQC,EAAO,MAAM;AAIjD,WAAS5P,IAAI,GAAGA,IAAI6P,GAAK7P,KAAK,GAAG;AACzB,UAAA8P,IAAOH,EAAO3P,CAAC,KAAK,GACpB+P,IAAOH,EAAO5P,CAAC,KAAK;AAE1B,QAAI8P,MAASC;AAGN,aAAAD,IAAOC,IAAO,IAAI;AAAA,EAAA;AAEpB,SAAA;AACT;ACFgB,SAAAC,GACd7K,GACA8K,GACAC,GACS;AACT,QAAM9K,IAAU8K,IACZX;AAAA,IACApK;AAAA,IACA8K;AAAA,EAAA,IAEAV,EAAkBpK,CAAM;AAC5B,SAAOC,IACHqK,GAAgBrK,GAAS8K,KAAaD,CAAc,KAAK,IACzD;AACN;ACFgB,SAAAE,GACd/K,GACAgL,IAA6D,UAChD;AACb,QAAMC,IAAiC,OAAOD,KAAwB,aAClEA,IACA,CAAQrE,MAAA;AACR,UAAM,EAAE,QAAA5G,GAAQ,SAAAC,EAAY,IAAA2G,GACtBpG,IAAQ,WAAWoG,IACrB,IAAI1G,GAAgCF,GAAQ4G,EAAK,OAAO3G,CAAO,IAC/D,IAAIH,GAAuBE,GAAQC,CAAO;AAE9C,QAAIgL,MAAwB;AACpB,YAAAzK;AAER,WAAOwD,EAAO,EAAE,UAAUxD,EAAM,OAAO;AAAA,EACzC;AAEM,SAAA,CAACR,GAAamL,MAEfN,GAAS7K,GAAQC,CAAO,IAO3BD,MAAW,8BACR3F,EAAGC,EAAY,EAAE,OAAO8Q,GAAI,EAAG,CAAA,GAAGD,CAAM,KACxC,CAACN,GAAS7K,GAAQ,SAASC,CAAO,IAE9BiL,EAAc,EAAE,SAAAjL,GAAS,QAAAD,GAAQ,OAAO,SAAS,IAGnDoH,GAAUpH,GAAQmL,CAAM,IAbtBD,EAAc,EAAE,SAAAjL,GAAS,QAAAD,GAAQ;AAe9C;AC1BO,SAASqL,GACdrL,GACAmL,GACAG,GACA5D,GACiD;AAC1C,SAAA9L;AAAA,IACL4L,EAAW,gCAAgC,yBAAyB;AAAA,MAClE,GAAGE,KAAW,CAAC;AAAA,MACf,QAAQ,EAAE,QAAA1H,GAAQ,QAAAmL,GAAQ,QAAQG,EAAU;AAAA,MAC5C,SAAStB,GAAesB,CAAS;AAAA,IAAA,CAClC;AAAA,IACDC,GAAS,CAAC,EAAE,QAAA3D,GAAQ,OAAApH,QACXA,IACHgL,GAAQ,IAAI3K,GAA8BL,CAAK,CAAC,IAChD0I,GAAStB,CAAM,CACpB;AAAA,EACH;AACF;AAsBO,SAAS6D,GACdzL,GACAmL,GACAG,GACA5D,GACwB;AACjB,SAAAsB,GAAc,GAAG,MACfpN;AAAA;AAAA,IAELyP,GAAqBrL,GAAQmL,GAAQG,GAAW5D,CAAO;AAAA,IACvD0B;AAAAA,MACE,CAAS5I,MAAA;AACD,cAAAA;AAAA,MACR;AAAA,MACA,CAAUoH,MAAAA;AAAA,IAAA;AAAA,EACZ,EACA,CACH;AACH;ACoDO,SAAS8D,GAKd1L,GACAyH,GACAC,IAA8D,CAAA,GACF;AACtD,QAAA;AAAA;AAAA,IAEJ,SAAAC,IAAU,MAAM;AAAA,IAChB,WAAAP,IAAYC;AAAA,EAAA,IACVK,GAEEE,IAAS/D,EAAuC,GAChD,CAACgE,GAAYtE,CAAO,IAAIuE,GAAkB;AAG/C,GAAA,MAAM,QAAQL,CAAa,IAAIA,IAAgB,CAACA,CAAa,GAAG,QAAQ,CAAS1E,MAAA;AAIhF,IAAA8E;AAAA,MACEzD,EAAGrB,GAAO,CAAWgF,MAAA;AACnB,SACE,MAAM,QAAQN,CAAa,IACtBE,EAAgD,EAAE,OAAA5E,GAAO,SAAAgF,EAAS,CAAA,IAClEJ,EAA6CI,CAAO,MAElDH,EAAA,IAAI,CAACG,CAA2B,CAAC;AAAA,MAE3C,CAAA;AAAA,IACH;AAAA,EAAA,CACD;AACK,QAAAE,IAAc,CAAI7N,OACdmJ,EAAA,GACDnJ;AAGF,SAAAwB;AAAA,IACL,YAAYwL,EAAUpH,GAAgB0H,EAAgB,MAAM;AAAA,IAC5DQ,GAAU,MACDC,GAA+C,CAACC,GAASC,GAAGC,MAAY;AAI7E,YAAM1B,IAAOgB,EAAO;AACpB,UAAIhB;AACK,eAAAwB,EAAQxB,EAAK,CAAC,CAAC;AAGlB,YAAA2B,IAAW,CAAC3B,MAAyC;AACzD,QAAIA,KACMA,EAAAA,EAAK,CAAC,CAAC;AAAA,MAEnB,GACM4B,IAAQ,MAAM;AAClB,QAAAZ,EAAO,MAAMW,CAAQ;AAAA,MACvB;AACA,MAAAX,EAAO,IAAIW,CAAQ,GACXD,EAAA,GAAG,aAAaE,CAAK;AAAA,OAC5Bd,CAAO,CACX;AAAA,IACDe,GAAWR,GAAaA,CAAW;AAAA,EACrC;AACF;AAmCgB,SAAA0D,GACd3L,GACAyH,GACAC,GACiC;AACjC,QAAM,EAAE,WAAAN,MAAcM,KAAW,CAAC;AAE3B,SAAAiB;AAAA;AAAA,IAEL+C,GAAU1L,GAAQyH,GAAe;AAAA,MAC/B,GAAGC;AAAA,MACH,WAAWN,IACP,IAAIlL,MAAgB;AAChB,YAAA;AAEF,iBAAAkL,EAAU,GAAGlL,CAAI,GACVmC,EAAQ,MAAS;AAAA,iBACjBT,GAAG;AACH,iBAAAU,EAAOV,CAAC;AAAA,QAAA;AAAA,MACjB,IAEAyJ;AAAA,IACL,CAAA;AAAA,EACH;AACF;AC1RO,SAASuE,KAAuB;AACjC,EAAC,OAAO,WACH,OAAA,SAAS,SAAS9G,GAAKW,GAAM;AAClC,WAAO,OAAO,UAAU,eAAe,KAAKX,GAAKW,CAAI;AAAA,EACvD;AAEJ;ACGO,SAASoG,GAAkBzR,GAAuD;AAChF,SAAA0R,EAAW,MACT;AAAA,IACL;AAAA,MACE1R,EACG,QAAQ,MAAM,GAAG,EACjB,QAAQ,MAAM,GAAG;AAAA,IAAA,EAEnB,MAAM,EAAE,EACR,IAAI,CAAK2R,MAAA,OAAO,OAAOA,EAAE,WAAW,CAAC,EAAE,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,EAC9D,KAAK,EAAE;AAAA,EACZ,GACC,OAAKnO,CAAiB;AAC3B;AAKa,MAAAoO,KAAkB1K,EAAauK,EAAiB;AAUtD,SAASI,GAAgB7R,GAAuB;AAI9C,SAAA;AAAA,IACL,mBAAmBA,CAAK,EAAE,QAAQ,mBAAmB,CAACiO,GAAG6D,MAChD,OAAO,aAAa,SAAS,KAAKA,CAAE,EAAE,CAAC,CAC/C;AAAA,EAAA,EAEA,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,GAAG;AACvB;AClCO,IAAI1F,KAAQ,SAAU5B,GAAG;AAAE,SAAOlH,EAAS,WAAY;AAAE,WAAO,KAAK,MAAMkH,CAAC;AAAA,KAAM5J,EAAQ;AAAI;ACF9F,SAASmR,GAAmB/R,GAAyC;AACpE,QAAAgS,IAAMH,GAAgB,OAAO7R,KAAU,WAAWA,IAAQ,KAAK,UAAUA,CAAK,CAAC;AACrF,SAAOgS,EAAI,SAAS,MAChB9N,EAAO,IAAI,MAAM,uCAAuC,CAAC,IACzDD,EAAQ+N,CAAG;AACjB;AAKa,MAAAC,KAAmB/K,EAAa6K,EAAkB;AAc/C,SAAAG,GACdlS,GACAmS,GACsB;AACf,SAAA5D;AAAA,IACL6D;AAAA,MACEpS;AAAA;AAAA,MAEA,OAAOmS,KAAS,aACZ,CAACnS,MAAkB0R,EAAW,MAAMS,EAAKnS,CAAK,GAAG,CAAAwD,MAAKA,CAAC,IACvD2O;AAAA,IAAA;AAAA,EAER;AACF;AAyBgB,SAAAC,GACdpS,GACAmS,GACuE;AAChE,SAAA3Q;AAAA,IACLiQ,GAAkBzR,CAAK;AAAA,IACvBqS,GAA6E,CAAWC,MACjFH,IAGD,OAAOA,KAAS,aACXA,EAAKG,CAAO,IAEdC,GAAQD,CAAO,IALbrO,EAAQqO,CAAO,CAMzB;AAAA,EACH;AACF;AAQO,SAASE,GAAyBxS,GAAwB;AACxD,SAAA6R,GAAgB7R,CAAK,EAAE,UAAU;AAC1C;","x_google_ignoreList":[2,3,4,5,6,7,8,30]}
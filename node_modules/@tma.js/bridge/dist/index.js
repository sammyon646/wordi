import { is as U, looseObject as m, function as te, nullish as E, boolean as V, number as B, string as P, optional as D, unknown as Me, parse as R, any as Ce } from "valibot";
import { throwifyFpFn as $, getStorageValue as Le, setStorageValue as re, createLogger as qe, throwifyAnyEither as M, createCbCollector as ne, BetterTaskEither as oe } from "@tma.js/toolkit";
import { createLogger as fr, deepSnakeToCamelObjKeys as lr } from "@tma.js/toolkit";
import { BetterPromise as ae, TimeoutError as Fe } from "better-promises";
import { CancelledError as wr, TimeoutError as hr } from "better-promises";
import { errorClass as k, errorClassWithData as We } from "error-kid";
import { parseLaunchParamsQueryFp as se, themeParams as Re, pipeJsonToSchema as ie, miniAppsMessage as ue, serializeLaunchParamsQuery as Ue, parseLaunchParamsQuery as Ie } from "@tma.js/transformers";
import { signal as d, computed as ce } from "@tma.js/signals";
import Oe from "mitt";
function pe(e) {
  return U(
    m({ TelegramWebviewProxy: m({ postEvent: te() }) }),
    e
  );
}
function _e() {
  try {
    return window.self !== window.top;
  } catch {
    return !0;
  }
}
var je = function(e, t, r) {
  if (r || arguments.length === 2) for (var n = 0, a = t.length, o; n < a; n++)
    (o || !(n in t)) && (o || (o = Array.prototype.slice.call(t, 0, n)), o[n] = t[n]);
  return e.concat(o || Array.prototype.slice.call(t));
};
function ze(e) {
  return e;
}
function S(e, t, r, n, a, o, s, i, c) {
  switch (arguments.length) {
    case 1:
      return e;
    case 2:
      return function() {
        return t(e.apply(this, arguments));
      };
    case 3:
      return function() {
        return r(t(e.apply(this, arguments)));
      };
    case 4:
      return function() {
        return n(r(t(e.apply(this, arguments))));
      };
    case 5:
      return function() {
        return a(n(r(t(e.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return o(a(n(r(t(e.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return s(o(a(n(r(t(e.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return i(s(o(a(n(r(t(e.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return c(i(s(o(a(n(r(t(e.apply(this, arguments)))))))));
      };
  }
}
function l(e, t, r, n, a, o, s, i, c) {
  switch (arguments.length) {
    case 1:
      return e;
    case 2:
      return t(e);
    case 3:
      return r(t(e));
    case 4:
      return n(r(t(e)));
    case 5:
      return a(n(r(t(e))));
    case 6:
      return o(a(n(r(t(e)))));
    case 7:
      return s(o(a(n(r(t(e))))));
    case 8:
      return i(s(o(a(n(r(t(e)))))));
    case 9:
      return c(i(s(o(a(n(r(t(e))))))));
    default: {
      for (var u = arguments[0], p = 1; p < arguments.length; p++)
        u = arguments[p](u);
      return u;
    }
  }
}
var C = function(e, t) {
  var r = typeof e == "number" ? function(n) {
    return n.length >= e;
  } : e;
  return function() {
    var n = Array.from(arguments);
    return r(arguments) ? t.apply(this, n) : function(a) {
      return t.apply(void 0, je([a], n, !1));
    };
  };
}, Ge = { _tag: "None" }, Ve = function(e) {
  return { _tag: "Some", value: e };
}, Be = function(e) {
  return e._tag === "Left";
}, De = function(e) {
  return { _tag: "Left", left: e };
}, Ne = function(e) {
  return { _tag: "Right", right: e };
}, w = De, _ = Ne, fe = /* @__PURE__ */ C(2, function(e, t) {
  return v(e) ? e : t(e.right);
}), Je = function(e) {
  return function(t) {
    return v(t) ? t : _(e(t.right));
  };
}, Qe = function(e, t) {
  return function(r) {
    return v(r) ? w(e(r.left)) : _(t(r.right));
  };
}, He = function(e) {
  return function(t) {
    return v(t) ? w(e(t.left)) : t;
  };
}, v = Be, le = function(e, t) {
  return function(r) {
    return v(r) ? e(r.left) : t(r.right);
  };
}, Ke = le, I = le, Ye = I, O = function(e, t) {
  try {
    return _(e());
  } catch (r) {
    return w(t(r));
  }
}, Xe = fe, Ze = fe, et = Ge, tt = Ve, rt = function(e) {
  return e._tag === "None";
}, nt = function(e, t) {
  return function(r) {
    return rt(r) ? e() : t(r.value);
  };
}, ot = nt;
function at(e) {
  return S(_, e.of);
}
function st(e) {
  return S(w, e.of);
}
function it(e) {
  return function(t, r) {
    return e.chain(t, function(n) {
      return v(n) ? e.of(n) : r(n.right);
    });
  };
}
function ut(e) {
  return function(t, r, n) {
    return e.map(t, Qe(r, n));
  };
}
function ct(e) {
  return function(t, r) {
    return function(n) {
      return e.map(n, I(t, r));
    };
  };
}
var me = function(e, t) {
  return l(e, _t(t));
}, pt = function(e, t) {
  return l(e, ft(t));
}, _t = function(e) {
  return function(t) {
    return function() {
      return Promise.resolve().then(t).then(e);
    };
  };
}, ft = function(e) {
  return function(t) {
    return function() {
      return Promise.all([Promise.resolve().then(t), Promise.resolve().then(e)]).then(function(r) {
        var n = r[0], a = r[1];
        return n(a);
      });
    };
  };
}, we = function(e) {
  return function() {
    return Promise.resolve(e);
  };
}, lt = /* @__PURE__ */ C(2, function(e, t) {
  return function() {
    return Promise.resolve().then(e).then(function(r) {
      return t(r)();
    });
  };
}), he = "Task", ge = {
  URI: he,
  map: me
}, de = {
  of: we
}, mt = {
  URI: he,
  map: me,
  of: we,
  ap: pt,
  chain: lt
}, wt = /* @__PURE__ */ st(de), ve = /* @__PURE__ */ at(de), be = /* @__PURE__ */ ct(ge), ye = /* @__PURE__ */ C(3, ut(ge)), Ee = /* @__PURE__ */ C(2, it(mt)), ht = Ee, Pe = Ee;
class gt extends k("MethodUnsupportedError", (t, r) => [
  `Method "${t}" is unsupported in Mini Apps version ${r}`
]) {
}
class dt extends k("MethodParameterUnsupportedError", (t, r, n) => [
  `Parameter "${r}" of "${t}" method is unsupported in Mini Apps version ${n}`
]) {
}
class vt extends We(
  "LaunchParamsRetrieveError",
  (t) => ({ errors: t }),
  (t) => [
    [
      "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
      "ðŸ“– Refer to docs for more information:",
      "https://docs.telegram-mini-apps.com/packages/tma-js-bridge/environment",
      "",
      "Collected errors:",
      ...t.map(({ source: r, error: n }) => `Source: ${r} / ${n instanceof Error ? n.message : String(n)}`)
    ].join(`
`)
  ]
) {
}
class bt extends k("InvalidLaunchParamsError", (t, r) => [
  `Invalid value for launch params: ${t}`,
  { cause: r }
]) {
}
class xe extends k("UnknownEnvError") {
}
class yt extends k(
  "InvokeCustomMethodError",
  (t) => [`Server returned error: ${t}`]
) {
}
const N = "launchParams";
function J(e) {
  return e.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&");
}
const Et = S(L, Xe(se)), Jt = $(Et), Pt = S(L, Je((e) => {
  const t = new URLSearchParams(e).get("tgWebAppData");
  return t ? tt(t) : et;
})), Qt = S(
  Pt,
  Ye((e) => {
    throw e;
  }, (e) => e),
  ot(() => {
  }, (e) => e)
);
function L() {
  const e = [];
  for (const [t, r] of [
    // Try to retrieve launch parameters from the current location. This method
    // can return nothing in case, location was changed, and then the page was
    // reloaded.
    [() => J(window.location.href), "window.location.href"],
    // Then, try using the lower level API - window.performance.
    [() => {
      const n = performance.getEntriesByType("navigation")[0];
      return n && J(n.name);
    }, "performance navigation entries"],
    // Finally, try using the session storage.
    [() => Le(N), "local storage"]
  ]) {
    const n = t();
    if (!n) {
      e.push({ source: r, error: new Error("Source is empty") });
      continue;
    }
    const a = l(
      se(n),
      Ke((o) => o, () => !0)
    );
    if (typeof a != "boolean") {
      e.push({ source: r, error: a });
      continue;
    }
    return re(N, n), _(n);
  }
  return w(new vt(e));
}
const Ht = $(L);
function xt(e, t) {
  const r = /* @__PURE__ */ new Map(), n = Oe(), a = (o, s, i = !1) => {
    const c = r.get(o) || /* @__PURE__ */ new Map();
    r.set(o, c);
    const u = c.get(s) || [];
    c.set(s, u);
    const p = u.findIndex((f) => f[1] === i);
    if (p >= 0 && (n.off(o, u[p][0]), u.splice(p, 1), !u.length && (c.delete(s), !c.size))) {
      const f = r.size;
      r.delete(o), f && !r.size && t();
    }
  };
  return {
    on(o, s, i) {
      !r.size && e();
      const c = () => {
        a(o, s, i);
      }, u = (...h) => {
        i && c(), o === "*" ? s({ name: h[0], payload: h[1] }) : s(...h);
      };
      n.on(o, u);
      const p = r.get(o) || /* @__PURE__ */ new Map();
      r.set(o, p);
      const f = p.get(s) || [];
      return p.set(s, f), f.push([u, i || !1]), c;
    },
    off: a,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    emit: n.emit,
    clear() {
      const o = r.size;
      n.all.clear(), r.clear(), o && t();
    }
  };
}
function F(e, t) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e, eventData: t }),
    // We specify this kind of source here in order to allow the package's "on" function to
    // capture it. The reason is this function always checks the event source and relies on
    // it to be the parent window.
    source: window.parent
  }));
}
const T = d(!1), j = d("https://web.telegram.org"), kt = (e) => {
  g().log("Event received:", e);
}, ke = ce(T);
function Kt(e) {
  e !== T() && (T.set(e), (e ? z : At)("*", kt));
}
const Se = ce(j);
function Yt(e) {
  j.set(e), g().log("New target origin set", e);
}
const x = d((...e) => {
  window.parent.postMessage(...e);
}), g = d(qe("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog: ke
}));
function Xt() {
  $t(), [x, j, Se, T, ke, g].forEach((e) => {
    e.unsubAll(), "reset" in e && e.reset();
  });
}
function W(e, t, r) {
  const n = [r], a = e[t];
  typeof a == "function" && n.push(a);
  const o = (...i) => {
    n.forEach((c) => c(...i));
  }, s = Object.assign((...i) => {
    o(...i);
  }, {
    // Unwraps the composer.
    unwrap() {
      const { length: i } = n;
      if (i === 1) {
        delete e[t];
        return;
      }
      if (i === 2) {
        H(e, t, n[1]);
        return;
      }
      n.unshift(1), H(e, t, o);
    }
  });
  Ae(
    e,
    t,
    () => s,
    (i) => n.push(i)
  );
}
function Q(e, t) {
  const r = e[t];
  Ae(e, t, () => r, (n) => {
    Object.entries(n).forEach(([a, o]) => {
      r[a] = o;
    });
  });
}
function Ae(e, t, r, n) {
  Object.defineProperty(e, t, {
    enumerable: !0,
    configurable: !0,
    get: r,
    set: n
  });
}
function H(e, t, r) {
  Object.defineProperty(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
  });
}
const St = {
  clipboard_text_received: m({
    req_id: P(),
    data: E(P())
  }),
  custom_method_invoked: m({
    req_id: P(),
    result: D(Me()),
    error: D(P())
  }),
  popup_closed: E(
    m({ button_id: E(P(), () => {
    }) }),
    {}
  ),
  viewport_changed: E(
    m({
      height: B(),
      width: E(B(), () => window.innerWidth),
      is_state_stable: V(),
      is_expanded: V()
    }),
    // TODO: At the moment, macOS has a bug with the invalid event payload - it is always equal to
    //  null. Leaving this default value until the bug is fixed.
    () => ({
      height: window.innerHeight,
      is_state_stable: !0,
      is_expanded: !0
    })
  ),
  theme_changed: m({
    theme_params: Re()
  })
};
function K(e) {
  if (e.source !== window.parent)
    return;
  let t;
  try {
    t = R(ie(ue()), e.data);
  } catch {
    return;
  }
  const { eventType: r, eventData: n } = t, a = St[r];
  let o;
  try {
    o = a ? R(a, n) : n;
  } catch (s) {
    return g().forceError(
      [
        `An error occurred processing the "${r}" event from the Telegram application.`,
        "Please, file an issue here:",
        "https://github.com/Telegram-Mini-Apps/tma.js/issues/new/choose"
      ].join(`
`),
      t,
      s
    );
  }
  Tt(r, o);
}
const {
  on: z,
  off: At,
  emit: Tt,
  clear: $t
} = xt(
  () => {
    const e = window;
    !e.TelegramGameProxy && (e.TelegramGameProxy = {}), W(e.TelegramGameProxy, "receiveEvent", F), Q(e, "TelegramGameProxy"), !e.Telegram && (e.Telegram = {}), !e.Telegram.WebView && (e.Telegram.WebView = {}), W(e.Telegram.WebView, "receiveEvent", F), Q(e.Telegram, "WebView"), W(e, "TelegramGameProxy_receiveEvent", F), window.addEventListener("message", K);
  },
  () => {
    [
      ["TelegramGameProxy_receiveEvent"],
      ["TelegramGameProxy", "receiveEvent"],
      ["Telegram", "WebView", "receiveEvent"]
    ].forEach((e) => {
      const t = window;
      let r = [void 0, t];
      for (const o of e)
        if (r = [r[1], r[1][o]], !r[1])
          return;
      const [n, a] = r;
      "unwrap" in a && (a.unwrap(), n && n !== t && !Object.keys(n).length && delete t[e[0]]);
    }), window.removeEventListener("message", K);
  }
), Mt = (...e) => x()(...e);
function Ct(e, t) {
  l(
    A(
      // @ts-expect-error It's ok, TS can't determine a specific override.
      e,
      t
    ),
    He((r) => {
      throw r;
    })
  );
}
function A(e, t) {
  g().log("Posting event:", t ? { eventType: e, eventData: t } : { eventType: e });
  const r = window, n = JSON.stringify({ eventType: e, eventData: t });
  return _e() ? (Mt(n, Se()), _(void 0)) : pe(r) ? (r.TelegramWebviewProxy.postEvent(e, JSON.stringify(t)), _(void 0)) : U(m({ external: m({ notify: te() }) }), r) ? (r.external.notify(n), _(void 0)) : w(new xe());
}
function G(e, t, r = {}) {
  const {
    // If no capture function was passed, we capture the first compatible event.
    capture: n = () => !0,
    postEvent: a = A
  } = r, o = d(), [s, i] = ne();
  (Array.isArray(t) ? t : [t]).forEach((u) => {
    s(
      z(u, (p) => {
        const f = Array.isArray(t);
        n(f ? { event: u, payload: p } : p) && o.set([
          f ? { event: u, payload: p } : p
        ]);
      })
    );
  });
  const c = (u) => (i(), u);
  return l(
    async () => a(e, r.params),
    Pe(() => oe((u, p, f) => {
      const h = o();
      if (h)
        return u(h[0]);
      const b = (y) => {
        y && u(y[0]);
      }, q = () => {
        o.unsub(b);
      };
      o.sub(b), f.on("finalized", q);
    }, r)),
    ye(c, c)
  );
}
function Zt(e, t, r) {
  const { postEvent: n } = r || {};
  return M(
    // @ts-expect-error TypeScript will not be able to handle our overrides here.
    G(e, t, {
      ...r,
      postEvent: n ? (...a) => {
        try {
          return n(...a), _(void 0);
        } catch (o) {
          return w(o);
        }
      } : A
    })
  );
}
function er(e, t) {
  const r = Lt(
    // @ts-expect-error TS doesn't get what override we are going to use.
    e,
    t
  );
  return typeof r == "function" ? ae.fn(() => M(r)) : r;
}
function Lt(e, t) {
  const r = pe(window);
  if (!e)
    return r || l(L(), I(() => !1, () => !0));
  if (r)
    return ve(!0);
  const { timeout: n = 100 } = t || {};
  return l(
    G("web_app_request_theme", "theme_changed", { ...t, timeout: n }),
    be(
      (a) => Fe.is(a) || xe.is(a) ? _(!1) : w(a),
      () => _(!0)
    )
  );
}
function tr({ launchParams: e, onEvent: t, resetPostMessage: r } = {}) {
  if (e) {
    const o = typeof e == "string" || e instanceof URLSearchParams ? e.toString() : (
      // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid
      // value. We are doing it because we are working with tgWebAppData presented as a
      // string, not an object as serializeLaunchParamsQuery requires.
      Ue({ ...e, tgWebAppData: void 0 }) + (e.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(e.tgWebAppData.toString())}` : "")
    );
    try {
      Ie(o);
    } catch (s) {
      throw new bt(o, s);
    }
    re("launchParams", o);
  }
  if (_e()) {
    if (!t)
      return;
    r && x.reset();
    const o = x();
    x.set((...s) => {
      const [i] = s, c = () => {
        o(...s);
      };
      try {
        const u = R(ie(ue()), i);
        t({ name: u.eventType, params: u.eventData }, c);
      } catch {
        c();
      }
    });
    return;
  }
  const n = window.TelegramWebviewProxy || {}, a = n.postEvent || (() => {
  });
  window.TelegramWebviewProxy = {
    ...n,
    postEvent(o, s) {
      const i = () => {
        a(o, s);
      };
      t ? t({
        name: o,
        params: s ? JSON.parse(s) : void 0
      }, i) : i();
    }
  }, g().log("Environment was mocked by the mockTelegramEnv function");
}
function qt(e) {
  return ({ req_id: t }) => t === e;
}
const Y = {
  "6.0": [
    "iframe_ready",
    "iframe_will_reload",
    "web_app_close",
    "web_app_data_send",
    "web_app_expand",
    "web_app_open_link",
    "web_app_ready",
    "web_app_request_theme",
    "web_app_request_viewport",
    "web_app_setup_main_button",
    "web_app_setup_closing_behavior"
  ],
  6.1: [
    "web_app_open_tg_link",
    "web_app_open_invoice",
    "web_app_setup_back_button",
    "web_app_set_background_color",
    "web_app_set_header_color",
    "web_app_trigger_haptic_feedback"
  ],
  6.2: ["web_app_open_popup"],
  6.4: [
    "web_app_close_scan_qr_popup",
    "web_app_open_scan_qr_popup",
    "web_app_read_text_from_clipboard",
    { method: "web_app_open_link", param: "try_instant_view" }
  ],
  6.7: ["web_app_switch_inline_query"],
  6.9: [
    "web_app_invoke_custom_method",
    "web_app_request_write_access",
    "web_app_request_phone",
    { method: "web_app_set_header_color", param: "color" }
  ],
  "6.10": ["web_app_setup_settings_button"],
  7.2: [
    "web_app_biometry_get_info",
    "web_app_biometry_open_settings",
    "web_app_biometry_request_access",
    "web_app_biometry_request_auth",
    "web_app_biometry_update_token"
  ],
  7.6: [
    { method: "web_app_open_link", param: "try_browser" },
    { method: "web_app_close", param: "return_back" }
  ],
  7.7: ["web_app_setup_swipe_behavior"],
  7.8: ["web_app_share_to_story"],
  "7.10": [
    "web_app_setup_secondary_button",
    "web_app_set_bottom_bar_color",
    { method: "web_app_setup_main_button", param: "has_shine_effect" }
  ],
  "8.0": [
    "web_app_request_safe_area",
    "web_app_request_content_safe_area",
    "web_app_request_fullscreen",
    "web_app_exit_fullscreen",
    "web_app_set_emoji_status",
    "web_app_add_to_home_screen",
    "web_app_check_home_screen",
    "web_app_request_emoji_status_access",
    "web_app_check_location",
    "web_app_open_location_settings",
    "web_app_request_file_download",
    "web_app_request_location",
    "web_app_send_prepared_message",
    "web_app_start_accelerometer",
    "web_app_start_device_orientation",
    "web_app_start_gyroscope",
    "web_app_stop_accelerometer",
    "web_app_stop_device_orientation",
    "web_app_stop_gyroscope",
    "web_app_toggle_orientation_lock"
  ],
  "9.0": [
    "web_app_device_storage_clear",
    "web_app_device_storage_get_key",
    "web_app_device_storage_save_key",
    "web_app_secure_storage_clear",
    "web_app_secure_storage_get_key",
    "web_app_secure_storage_restore_key",
    "web_app_secure_storage_save_key"
  ],
  9.1: ["web_app_hide_keyboard"]
};
function X(e, t) {
  return Object.keys(Y).find((n) => Y[n].some((a) => t ? typeof a == "object" && a.method === e && a.param === t : a === e)) || null;
}
function Z(e) {
  return e.split(".").map(Number);
}
function Ft(e, t) {
  const r = Z(e), n = Z(t), a = Math.max(r.length, n.length);
  for (let o = 0; o < a; o += 1) {
    const s = r[o] || 0, i = n[o] || 0;
    if (s !== i)
      return s > i ? 1 : -1;
  }
  return 0;
}
function ee(e, t, r) {
  const n = r ? X(
    e,
    t
  ) : X(e);
  return n ? Ft(n, r || t) <= 0 : !1;
}
function rr(e, t = "strict") {
  const r = typeof t == "function" ? t : (n) => {
    const { method: a, version: o } = n, s = "param" in n ? new dt(a, n.param, o) : new gt(a, o);
    if (t === "strict")
      throw s;
    return g().forceWarn(s.message);
  };
  return (n, a) => ee(n, e) ? n === "web_app_set_header_color" && U(m({ color: Ce() }), a) && !ee(n, "color", e) ? r({ version: e, method: n, param: "color" }) : Ct(n, a) : r({ version: e, method: n });
}
function Wt(e, t, r, n) {
  return l(
    G("web_app_invoke_custom_method", "custom_method_invoked", {
      ...n || {},
      params: { method: e, params: t, req_id: r },
      capture: qt(r)
    }),
    ht(({ result: a, error: o }) => o ? wt(new yt(o)) : ve(a))
  );
}
function nr(e, t, r, n) {
  return ae.fn(() => l(
    // @ts-expect-error TypeScript is unable to determine required override.
    Wt(e, t, r, n),
    be(
      (a) => {
        throw a;
      },
      (a) => a
    )
  )());
}
function Rt(e, t, r = {}) {
  const {
    // If no capture function was passed, we capture the first compatible event.
    capture: n = () => !0,
    postEvent: a = A
  } = r, o = d(), [s, i] = ne();
  (Array.isArray(t) ? t : [t]).forEach((u) => {
    s(
      z(u, (p) => {
        (Array.isArray(t) ? n({ event: u, payload: p }) : n(p)) && o.set([p]);
      })
    );
  });
  const c = (u) => (i(), u);
  return l(
    async () => a(e, r.params),
    Pe(() => oe((u, p, f) => {
      const h = o();
      if (h)
        return u(h[0]);
      const b = (y) => {
        y && u(y[0]);
      }, q = () => {
        o.unsub(b);
      };
      o.sub(b), f.on("finalized", q);
    }, r)),
    ye(c, c)
  );
}
function or(e, t, r) {
  const { postEvent: n } = r || {};
  return M(
    // @ts-expect-error TypeScript will not be able to handle our overrides here.
    Rt(e, t, {
      ...r,
      postEvent: n ? (...a) => {
        try {
          return n(...a), _(void 0);
        } catch (o) {
          return w(o);
        }
      } : A
    })
  );
}
function ar() {
  Object.hasOwn || (Object.hasOwn = function(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  });
}
function Te(e) {
  return O(() => decodeURIComponent(
    atob(
      e.replace(/-/g, "+").replace(/_/g, "/")
    ).split("").map((t) => "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2)).join("")
  ), (t) => t);
}
const sr = $(Te);
function $e(e) {
  return btoa(
    encodeURIComponent(e).replace(/%([0-9A-F]{2})/g, (t, r) => String.fromCharCode(parseInt(`0x${r}`)))
  ).replace(/\+/g, "-").replace(/\//g, "_");
}
var Ut = function(e) {
  return O(function() {
    return JSON.parse(e);
  }, ze);
};
function It(e) {
  const t = $e(typeof e == "string" ? e : JSON.stringify(e));
  return t.length > 512 ? w(new Error("Value is too long for start parameter")) : _(t);
}
const ir = $(It);
function ur(e, t) {
  return M(
    Ot(
      e,
      // @ts-expect-error TypeScript is unable to detect a correct override.
      typeof t == "function" ? (r) => O(() => t(r), (n) => n) : t
    )
  );
}
function Ot(e, t) {
  return l(
    Te(e),
    Ze((r) => t ? typeof t == "function" ? t(r) : Ut(r) : _(r))
  );
}
function cr(e) {
  return $e(e).length <= 512;
}
export {
  wr as CancelledError,
  bt as InvalidLaunchParamsError,
  yt as InvokeCustomMethodFailedError,
  vt as LaunchParamsRetrieveError,
  dt as MethodParameterUnsupportedError,
  gt as MethodUnsupportedError,
  hr as TimeoutError,
  xe as UnknownEnvError,
  ar as applyPolyfills,
  qt as captureSameReq,
  Ft as compareVersions,
  fr as createLogger,
  rr as createPostEvent,
  ir as createStartParam,
  It as createStartParamFp,
  ke as debug,
  sr as decodeBase64Url,
  Te as decodeBase64UrlFp,
  ur as decodeStartParam,
  Ot as decodeStartParamFp,
  lr as deepSnakeToCamelObjKeys,
  F as emitEvent,
  $e as encodeBase64Url,
  X as getReleaseVersion,
  pe as hasWebviewProxy,
  nr as invokeCustomMethod,
  Wt as invokeCustomMethodFp,
  _e as isIframe,
  cr as isSafeToCreateStartParam,
  er as isTMA,
  Lt as isTMAFp,
  g as logger,
  tr as mockTelegramEnv,
  At as off,
  $t as offAll,
  z as on,
  Ct as postEvent,
  A as postEventFp,
  Mt as postMessage,
  x as postMessageImpl,
  or as request,
  Zt as request2,
  G as request2Fp,
  Rt as requestFp,
  Xt as resetGlobals,
  Jt as retrieveLaunchParams,
  Et as retrieveLaunchParamsFp,
  Qt as retrieveRawInitData,
  Pt as retrieveRawInitDataFp,
  Ht as retrieveRawLaunchParams,
  L as retrieveRawLaunchParamsFp,
  Kt as setDebug,
  Yt as setTargetOrigin,
  ee as supports,
  Se as targetOrigin
};
//# sourceMappingURL=index.js.map
